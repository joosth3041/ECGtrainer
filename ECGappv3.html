<!DOCTYPE html>
<html lang="nl">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>IC ECG Trainer Pro v2.5</title>
 <style>
 /* ==================== RESET & BASE ==================== */
 * {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
 }

 :root {
 --bg-dark: #0a0f1a;
 --bg-card: #111827;
 --bg-elevated: #1a2332;
 --bg-hover: #1f2937;
 --text-primary: #f1f5f9;
 --text-secondary: #94a3b8;
 --text-muted: #64748b;
 --border: #374151;
 --primary: #3b82f6;
 --primary-dark: #2563eb;
 --success: #22c55e;
 --warning: #f59e0b;
 --danger: #ef4444;
 --info: #06b6d4;
 --purple: #8b5cf6;
 --ecg-green: #22c55e;
 }

 body {
 font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
 background: var(--bg-dark);
 color: var(--text-primary);
 min-height: 100vh;
 line-height: 1.6;
 }

 /* ==================== SCROLLBAR ==================== */
 ::-webkit-scrollbar {
 width: 8px;
 height: 8px;
 }
 ::-webkit-scrollbar-track {
 background: var(--bg-dark);
 }
 ::-webkit-scrollbar-thumb {
 background: var(--border);
 border-radius: 4px;
 }
 ::-webkit-scrollbar-thumb:hover {
 background: #4b5563;
 }

 /* ==================== LAYOUT ==================== */
 .app-container {
 display: flex;
 min-height: 100vh;
 }

 /* ==================== SIDEBAR ==================== */
 .sidebar {
 width: 260px;
 background: var(--bg-card);
 border-right: 1px solid var(--border);
 position: fixed;
 height: 100vh;
 overflow-y: auto;
 z-index: 100;
 display: flex;
 flex-direction: column;
 }

 .sidebar-header {
 padding: 1.25rem;
 border-bottom: 1px solid var(--border);
 background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(59, 130, 246, 0.1));
 }

 .logo {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 }

 .logo-icon {
 width: 42px;
 height: 42px;
 background: linear-gradient(135deg, var(--success), var(--primary));
 border-radius: 10px;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 1.5rem;
 }

 .logo-text {
 font-size: 1.1rem;
 font-weight: 700;
 color: var(--success);
 }

 .logo-subtitle {
 font-size: 0.7rem;
 color: var(--text-muted);
 font-weight: 400;
 }

 .sidebar-nav {
 flex: 1;
 padding: 0.75rem;
 overflow-y: auto;
 }

 .nav-section {
 margin-bottom: 1.25rem;
 }

 .nav-section-title {
 font-size: 0.65rem;
 text-transform: uppercase;
 letter-spacing: 0.1em;
 color: var(--text-muted);
 padding: 0.5rem 0.75rem;
 font-weight: 600;
 }

 .nav-item {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.7rem 0.75rem;
 border-radius: 8px;
 cursor: pointer;
 color: var(--text-secondary);
 font-size: 0.9rem;
 transition: all 0.15s ease;
 margin-bottom: 2px;
 }

 .nav-item:hover {
 background: var(--bg-hover);
 color: var(--text-primary);
 }

 .nav-item.active {
 background: rgba(59, 130, 246, 0.15);
 color: var(--primary);
 font-weight: 500;
 }

 .nav-item-icon {
 font-size: 1.1rem;
 width: 24px;
 text-align: center;
 }

 .nav-item-badge {
 margin-left: auto;
 font-size: 0.65rem;
 padding: 0.15rem 0.5rem;
 border-radius: 10px;
 font-weight: 600;
 }

 .nav-item-badge.red { background: var(--danger); color: white; }
 .nav-item-badge.green { background: var(--success); color: white; }
 .nav-item-badge.yellow { background: var(--warning); color: black; }
 .nav-item-badge.blue { background: var(--primary); color: white; }

 .sidebar-stats {
 padding: 1rem;
 border-top: 1px solid var(--border);
 background: var(--bg-elevated);
 }

 .stat-row {
 display: flex;
 justify-content: space-between;
 padding: 0.4rem 0;
 font-size: 0.85rem;
 }

 .stat-label { color: var(--text-muted); }
 .stat-value { font-weight: 600; color: var(--success); }

 /* ==================== MAIN CONTENT ==================== */
 .main-content {
 flex: 1;
 margin-left: 260px;
 display: flex;
 flex-direction: column;
 min-height: 100vh;
 }

 .top-bar {
 background: var(--bg-card);
 border-bottom: 1px solid var(--border);
 padding: 0.875rem 1.5rem;
 display: flex;
 justify-content: space-between;
 align-items: center;
 position: sticky;
 top: 0;
 z-index: 50;
 }

 .top-bar-heading {
 display: flex;
 flex-direction: column;
 gap: 0.1rem;
 }

 .top-bar-title {
 font-size: 1.15rem;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 0.5rem;
 }

 .page-breadcrumb {
 font-size: 0.78rem;
 color: var(--text-muted);
 }

 .top-bar-actions {
 display: flex;
 gap: 0.75rem;
 align-items: center;
 }

 .context-help-card {
 background: linear-gradient(135deg, rgba(6, 182, 212, 0.08), rgba(59, 130, 246, 0.08));
 border: 1px solid rgba(59, 130, 246, 0.35);
 border-radius: 10px;
 padding: 0.85rem 1rem;
 margin-bottom: 1rem;
 font-size: 0.88rem;
 color: var(--text-secondary);
 }
 .content-area {
 flex: 1;
 padding: 1.5rem;
 overflow-y: auto;
 }

 /* ==================== SECTIONS ==================== */
 .section {
 display: none;
 animation: fadeIn 0.25s ease;
 }

 .section.active {
 display: block;
 }

 @keyframes fadeIn {
 from { opacity: 0; transform: translateY(8px); }
 to { opacity: 1; transform: translateY(0); }
 }

 /* ==================== CARDS ==================== */
 .card {
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 12px;
 margin-bottom: 1.25rem;
 overflow: hidden;
 }

 .card-header {
 padding: 1rem 1.25rem;
 border-bottom: 1px solid var(--border);
 display: flex;
 justify-content: space-between;
 align-items: center;
 background: var(--bg-elevated);
 }

 .card-title {
 font-size: 1rem;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 0.5rem;
 }

 .card-body {
 padding: 1.25rem;
 }

 .card-footer {
 padding: 1rem 1.25rem;
 border-top: 1px solid var(--border);
 background: var(--bg-elevated);
 }

 /* ==================== BUTTONS ==================== */
 .btn {
 display: inline-flex;
 align-items: center;
 justify-content: center;
 gap: 0.5rem;
 padding: 0.6rem 1.25rem;
 border: none;
 border-radius: 8px;
 cursor: pointer;
 font-size: 0.9rem;
 font-weight: 500;
 transition: all 0.15s ease;
 white-space: nowrap;
 }

 .btn:hover {
 transform: translateY(-1px);
 box-shadow: 0 4px 12px rgba(0,0,0,0.2);
 }

 .btn:active {
 transform: translateY(0);
 }

 .btn-primary { background: var(--primary); color: white; }
 .btn-primary:hover { background: var(--primary-dark); }
 
 .btn-success { background: var(--success); color: white; }
 .btn-success:hover { background: #16a34a; }
 
 .btn-danger { background: var(--danger); color: white; }
 .btn-danger:hover { background: #dc2626; }
 
 .btn-warning { background: var(--warning); color: black; }
 .btn-warning:hover { background: #d97706; }

 .btn-outline {
 background: transparent;
 border: 1px solid var(--border);
 color: var(--text-primary);
 }
 .btn-outline:hover {
 border-color: var(--primary);
 color: var(--primary);
 background: rgba(59, 130, 246, 0.1);
 }

 .btn-ghost {
 background: transparent;
 color: var(--text-secondary);
 }
 .btn-ghost:hover {
 background: var(--bg-hover);
 color: var(--text-primary);
 }

 .btn-sm { padding: 0.4rem 0.875rem; font-size: 0.8rem; }
 .btn-lg { padding: 0.875rem 1.75rem; font-size: 1rem; }

 .btn-group {
 display: flex;
 gap: 0.5rem;
 flex-wrap: wrap;
 }

 /* ==================== BADGES ==================== */
 .badge {
 display: inline-flex;
 align-items: center;
 padding: 0.2rem 0.6rem;
 border-radius: 20px;
 font-size: 0.7rem;
 font-weight: 600;
 }

 .badge-easy { background: rgba(34, 197, 94, 0.15); color: var(--success); }
 .badge-medium { background: rgba(245, 158, 11, 0.15); color: var(--warning); }
 .badge-hard { background: rgba(239, 68, 68, 0.15); color: var(--danger); }
 .badge-warning { background: rgba(245, 158, 11, 0.15); color: var(--warning); }
 .badge-critical { background: var(--danger); color: white; }
 .badge-info { background: rgba(59, 130, 246, 0.15); color: var(--primary); }
 .badge-success { background: rgba(34, 197, 94, 0.15); color: var(--success); }

 /* ==================== GRIDS ==================== */
 .grid-2 {
 display: grid;
 grid-template-columns: repeat(2, 1fr);
 gap: 1.25rem;
 }

 .grid-3 {
 display: grid;
 grid-template-columns: repeat(3, 1fr);
 gap: 1.25rem;
 }

 .grid-4 {
 display: grid;
 grid-template-columns: repeat(4, 1fr);
 gap: 1rem;
 }

 @media (max-width: 1200px) {
 .grid-4 { grid-template-columns: repeat(3, 1fr); }
 .grid-3 { grid-template-columns: repeat(2, 1fr); }
 }

 @media (max-width: 900px) {
 .grid-4 { grid-template-columns: repeat(2, 1fr); }
 .grid-3 { grid-template-columns: 1fr; }
 .grid-2 { grid-template-columns: 1fr; }
 }

 @media (max-width: 768px) {
 .sidebar {
 transform: translateX(-100%);
 transition: transform 0.3s ease;
 }
 .sidebar.open {
 transform: translateX(0);
 }
 .main-content {
 margin-left: 0;
 }
 }

 /* ==================== ECG MONITOR ==================== */
 .ecg-monitor {
 background: #000;
 border-radius: 10px;
 overflow: hidden;
 border: 1px solid #222;
 }

 .ecg-monitor-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 0.6rem 1rem;
 background: linear-gradient(180deg, #1a1a1a, #111);
 border-bottom: 1px solid #333;
 }

 .ecg-monitor-title {
 color: var(--success);
 font-size: 0.85rem;
 font-weight: 500;
 display: flex;
 align-items: center;
 gap: 0.5rem;
 }

 .ecg-monitor-vitals {
 display: flex;
 gap: 1.5rem;
 }

 .vital-display {
 text-align: right;
 }

 .vital-label {
 font-size: 0.6rem;
 color: var(--text-muted);
 text-transform: uppercase;
 letter-spacing: 0.05em;
 }

 .vital-value {
 font-size: 1.4rem;
 font-weight: 700;
 font-family: 'SF Mono', 'Consolas', monospace;
 line-height: 1.2;
 }

 .vital-value.green { color: var(--success); }
 .vital-value.red { color: var(--danger); }
 .vital-value.blue { color: var(--info); }
 .vital-value.yellow { color: var(--warning); }
 .vital-value.critical { color: var(--danger); animation: blink 1s infinite; }

 @keyframes blink {
 0%, 50%, 100% { opacity: 1; }
 25%, 75% { opacity: 0.3; }
 }

 .ecg-canvas-wrapper {
 position: relative;
 padding: 0.5rem;
 }

 .ecg-canvas {
 width: 100%;
 height: 200px;
 display: block;
 }

 .ecg-canvas.large {
 height: 280px;
 }

 .ecg-lead-label {
 position: absolute;
 top: 1rem;
 left: 1rem;
 background: rgba(0, 0, 0, 0.7);
 color: var(--success);
 padding: 0.2rem 0.5rem;
 border-radius: 4px;
 font-size: 0.75rem;
 font-weight: 600;
 }

 .ecg-controls {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 0.5rem 1rem;
 background: #0a0a0a;
 border-top: 1px solid #222;
 }

 .ecg-setting {
 font-size: 0.7rem;
 color: var(--text-muted);
 }

 .ecg-setting span {
 color: var(--text-secondary);
 margin-left: 0.25rem;
 }

 /* ==================== QUIZ OPTIONS ==================== */
 .quiz-options {
 display: grid;
 grid-template-columns: repeat(2, 1fr);
 gap: 0.875rem;
 }

 @media (max-width: 700px) {
 .quiz-options {
 grid-template-columns: 1fr;
 }
 }

 .quiz-option {
 display: flex;
 align-items: flex-start;
 gap: 0.875rem;
 padding: 1rem;
 background: var(--bg-elevated);
 border: 2px solid var(--border);
 border-radius: 10px;
 cursor: pointer;
 transition: all 0.15s ease;
 }

 .quiz-option:hover:not(.disabled) {
 border-color: var(--primary);
 background: rgba(59, 130, 246, 0.08);
 transform: translateY(-2px);
 }

 .quiz-option.selected {
 border-color: var(--primary);
 background: rgba(59, 130, 246, 0.12);
 }

 .quiz-option.correct {
 border-color: var(--success);
 background: rgba(34, 197, 94, 0.12);
 }

 .quiz-option.incorrect {
 border-color: var(--danger);
 background: rgba(239, 68, 68, 0.12);
 }

 .quiz-option.disabled {
 cursor: not-allowed;
 opacity: 0.7;
 }

 .quiz-option-key {
 width: 28px;
 height: 28px;
 background: var(--border);
 border-radius: 6px;
 display: flex;
 align-items: center;
 justify-content: center;
 font-weight: 700;
 font-size: 0.85rem;
 flex-shrink: 0;
 }

 .quiz-option.selected .quiz-option-key {
 background: var(--primary);
 color: white;
 }

 .quiz-option.correct .quiz-option-key {
 background: var(--success);
 color: white;
 }

 .quiz-option.incorrect .quiz-option-key {
 background: var(--danger);
 color: white;
 }

 .quiz-option-content {
 flex: 1;
 min-width: 0;
 }

 .quiz-option-title {
 font-weight: 500;
 margin-bottom: 0.2rem;
 }

 .quiz-option-desc {
 font-size: 0.8rem;
 color: var(--text-muted);
 overflow: hidden;
 text-overflow: ellipsis;
 white-space: nowrap;
 }

 /* ==================== FEEDBACK PANELS ==================== */
 .feedback-panel {
 padding: 1.25rem;
 border-radius: 10px;
 margin-top: 1.25rem;
 display: none;
 }

 .feedback-panel.show {
 display: block;
 animation: slideIn 0.25s ease;
 }

 @keyframes slideIn {
 from { opacity: 0; transform: translateY(8px); }
 to { opacity: 1; transform: translateY(0); }
 }

 .feedback-panel.correct {
 background: rgba(34, 197, 94, 0.1);
 border: 1px solid rgba(34, 197, 94, 0.3);
 }

 .feedback-panel.incorrect {
 background: rgba(239, 68, 68, 0.1);
 border: 1px solid rgba(239, 68, 68, 0.3);
 }

 .feedback-panel.info {
 background: rgba(59, 130, 246, 0.1);
 border: 1px solid rgba(59, 130, 246, 0.3);
 }

 .feedback-header {
 display: flex;
 align-items: center;
 gap: 0.875rem;
 margin-bottom: 0.875rem;
 }

 .feedback-icon {
 width: 42px;
 height: 42px;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 1.25rem;
 flex-shrink: 0;
 }

 .feedback-panel.correct .feedback-icon { background: var(--success); }
 .feedback-panel.incorrect .feedback-icon { background: var(--danger); }
 .feedback-panel.info .feedback-icon { background: var(--primary); }

 .feedback-title {
 font-size: 1.1rem;
 font-weight: 600;
 }

 .feedback-subtitle {
 font-size: 0.85rem;
 color: var(--text-muted);
 }

 /* ==================== PROGRESS BAR ==================== */
 .progress-bar {
 height: 6px;
 background: var(--border);
 border-radius: 3px;
 overflow: hidden;
 }

 .progress-fill {
 height: 100%;
 background: linear-gradient(90deg, var(--primary), var(--success));
 border-radius: 3px;
 transition: width 0.3s ease;
 }

 /* ==================== TOPIC CARDS ==================== */
 .topic-card {
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 12px;
 padding: 1.25rem;
 cursor: pointer;
 transition: all 0.2s ease;
 }

 .topic-card:hover {
 border-color: var(--primary);
 transform: translateY(-3px);
 box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
 }

 .topic-card-icon {
 width: 44px;
 height: 44px;
 background: linear-gradient(135deg, var(--primary), var(--purple));
 border-radius: 10px;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 1.4rem;
 margin-bottom: 0.875rem;
 }

 .topic-card-title {
 font-size: 0.95rem;
 font-weight: 600;
 margin-bottom: 0.4rem;
 }

 .topic-card-desc {
 font-size: 0.8rem;
 color: var(--text-muted);
 line-height: 1.5;
 }

 .topic-card-meta {
 display: flex;
 justify-content: space-between;
 align-items: center;
 margin-top: 0.875rem;
 font-size: 0.75rem;
 color: var(--text-muted);
 }

 /* ==================== QUICK ACTIONS ==================== */
 .quick-actions {
 display: grid;
 grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
 gap: 1rem;
 }

 .quick-action {
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: 12px;
 padding: 1.25rem;
 text-align: center;
 cursor: pointer;
 transition: all 0.2s ease;
 }

 .quick-action:hover {
 border-color: var(--primary);
 transform: translateY(-2px);
 box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
 }

 .quick-action-icon {
 font-size: 2rem;
 margin-bottom: 0.625rem;
 }

 .quick-action-title {
 font-weight: 600;
 margin-bottom: 0.25rem;
 }

 .quick-action-desc {
 font-size: 0.75rem;
 color: var(--text-muted);
 }

 /* ==================== INFO BOXES ==================== */
 .info-box {
 display: flex;
 gap: 0.875rem;
 padding: 1rem;
 border-radius: 8px;
 margin: 1rem 0;
 }

 .info-box.info {
 background: rgba(59, 130, 246, 0.1);
 border: 1px solid rgba(59, 130, 246, 0.25);
 }

 .info-box.success {
 background: rgba(34, 197, 94, 0.1);
 border: 1px solid rgba(34, 197, 94, 0.25);
 }

 .info-box.warning {
 background: rgba(245, 158, 11, 0.1);
 border: 1px solid rgba(245, 158, 11, 0.25);
 }

 .info-box.danger {
 background: rgba(239, 68, 68, 0.1);
 border: 1px solid rgba(239, 68, 68, 0.25);
 }

 .info-box-icon {
 font-size: 1.25rem;
 flex-shrink: 0;
 }

 .info-box-content h4 {
 font-size: 0.9rem;
 font-weight: 600;
 margin-bottom: 0.25rem;
 }

 .info-box-content p {
 font-size: 0.85rem;
 color: var(--text-secondary);
 }

 /* ==================== TABLES ==================== */
 .data-table {
 width: 100%;
 border-collapse: collapse;
 }

 .data-table th,
 .data-table td {
 padding: 0.75rem 1rem;
 text-align: left;
 border-bottom: 1px solid var(--border);
 }

 .data-table th {
 background: var(--bg-elevated);
 font-weight: 600;
 font-size: 0.75rem;
 text-transform: uppercase;
 letter-spacing: 0.05em;
 color: var(--text-muted);
 }

 .data-table tbody tr:hover {
 background: var(--bg-hover);
 }

 /* ==================== ACCORDION ==================== */
 .accordion {
 border: 1px solid var(--border);
 border-radius: 8px;
 overflow: hidden;
 }

 .accordion-item {
 border-bottom: 1px solid var(--border);
 }

 .accordion-item:last-child {
 border-bottom: none;
 }

 .accordion-header {
 padding: 1rem 1.25rem;
 background: var(--bg-elevated);
 cursor: pointer;
 display: flex;
 justify-content: space-between;
 align-items: center;
 transition: background 0.15s ease;
 }

 .accordion-header:hover {
 background: var(--bg-hover);
 }

 .accordion-header h4 {
 font-size: 0.9rem;
 font-weight: 500;
 }

 .accordion-icon {
 transition: transform 0.2s ease;
 color: var(--text-muted);
 }

 .accordion-item.open .accordion-icon {
 transform: rotate(180deg);
 }

 .accordion-body {
 max-height: 0;
 overflow: hidden;
 transition: max-height 0.3s ease;
 }

 .accordion-item.open .accordion-body {
 max-height: 1000px;
 }

 .accordion-content {
 padding: 1rem 1.25rem;
 }

 /* ==================== TABS ==================== */
 .tabs {
 display: flex;
 border-bottom: 1px solid var(--border);
 margin-bottom: 1.25rem;
 overflow-x: auto;
 }

 .tab {
 padding: 0.75rem 1.25rem;
 cursor: pointer;
 color: var(--text-muted);
 font-size: 0.9rem;
 font-weight: 500;
 border-bottom: 2px solid transparent;
 transition: all 0.15s ease;
 white-space: nowrap;
 }

 .tab:hover {
 color: var(--text-primary);
 }

 .tab.active {
 color: var(--primary);
 border-bottom-color: var(--primary);
 }

 .tab-content {
 display: none;
 }

 .tab-content.active {
 display: block;
 }

 /* ==================== VITALS GRID ==================== */
 .vitals-grid {
 display: grid;
 grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
 gap: 0.75rem;
 }

 .vital-card {
 background: var(--bg-elevated);
 border-radius: 8px;
 padding: 0.875rem;
 text-align: center;
 }

 .vital-card-label {
 font-size: 0.65rem;
 text-transform: uppercase;
 letter-spacing: 0.05em;
 color: var(--text-muted);
 margin-bottom: 0.25rem;
 }

 .vital-card-value {
 font-size: 1.5rem;
 font-weight: 700;
 font-family: 'SF Mono', 'Consolas', monospace;
 }

 .vital-card-unit {
 font-size: 0.7rem;
 color: var(--text-muted);
 }

 /* ==================== ALGORITHM BOX ==================== */
 .algorithm-box {
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: 8px;
 padding: 1.25rem;
 margin: 1rem 0;
 }

 .algorithm-box.critical {
 border-left: 4px solid var(--danger);
 background: rgba(239, 68, 68, 0.05);
 }

 .algorithm-box.warning {
 border-left: 4px solid var(--warning);
 background: rgba(245, 158, 11, 0.05);
 }

 .algorithm-box.success {
 border-left: 4px solid var(--success);
 background: rgba(34, 197, 94, 0.05);
 }

 .algorithm-box.info {
 border-left: 4px solid var(--primary);
 background: rgba(59, 130, 246, 0.05);
 }

 .algorithm-title {
 font-weight: 600;
 margin-bottom: 0.75rem;
 display: flex;
 align-items: center;
 gap: 0.5rem;
 }

 .algorithm-steps {
 display: flex;
 flex-direction: column;
 gap: 0.5rem;
 }

 .algorithm-step {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.6rem 0.75rem;
 background: var(--bg-card);
 border-radius: 6px;
 font-size: 0.9rem;
 }

 .algorithm-step-num {
 width: 24px;
 height: 24px;
 background: var(--primary);
 color: white;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 0.75rem;
 font-weight: 600;
 flex-shrink: 0;
 }

 .algorithm-step.critical {
 background: rgba(239, 68, 68, 0.15);
 border: 1px solid rgba(239, 68, 68, 0.3);
 }

 .algorithm-step.critical .algorithm-step-num {
 background: var(--danger);
 }

 /* ==================== MODAL ==================== */
 .modal-overlay {
 position: fixed;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 background: rgba(0, 0, 0, 0.8);
 display: none;
 align-items: center;
 justify-content: center;
 z-index: 1000;
 padding: 1.5rem;
 overflow-y: auto;
 }

 .modal-overlay.show {
 display: flex;
 }

 .modal {
 background: var(--bg-card);
 border-radius: 16px;
 max-width: 800px;
 width: 100%;
 max-height: 90vh;
 overflow: hidden;
 display: flex;
 flex-direction: column;
 animation: modalIn 0.2s ease;
 }

 @keyframes modalIn {
 from { opacity: 0; transform: scale(0.95) translateY(10px); }
 to { opacity: 1; transform: scale(1) translateY(0); }
 }

 .modal-header {
 padding: 1rem 1.5rem;
 border-bottom: 1px solid var(--border);
 display: flex;
 justify-content: space-between;
 align-items: center;
 background: var(--bg-elevated);
 }

 .modal-title {
 font-size: 1.1rem;
 font-weight: 600;
 }

 .modal-close {
 width: 32px;
 height: 32px;
 border: none;
 background: transparent;
 color: var(--text-muted);
 border-radius: 8px;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 1.25rem;
 transition: all 0.15s ease;
 }

 .modal-close:hover {
 background: var(--danger);
 color: white;
 }

 .modal-body {
 padding: 1.5rem;
 overflow-y: auto;
 flex: 1;
 }

 .modal-footer {
 padding: 1rem 1.5rem;
 border-top: 1px solid var(--border);
 display: flex;
 justify-content: flex-end;
 gap: 0.75rem;
 background: var(--bg-elevated);
 }

 /* ==================== CASE DISPLAY ==================== */
 .case-header {
 display: flex;
 gap: 1.25rem;
 margin-bottom: 1.25rem;
 }

 .case-avatar {
 width: 70px;
 height: 70px;
 background: var(--bg-elevated);
 border-radius: 12px;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 2.5rem;
 flex-shrink: 0;
 }

 .case-info h3 {
 font-size: 1.1rem;
 margin-bottom: 0.25rem;
 }

 .case-info p {
 color: var(--text-muted);
 font-size: 0.9rem;
 }

 /* ==================== EMERGENCY BANNER ==================== */
 .emergency-banner {
 background: linear-gradient(90deg, var(--danger), #b91c1c);
 color: white;
 padding: 0.875rem 1.5rem;
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 0.75rem;
 font-weight: 600;
 margin-bottom: 1.5rem;
 border-radius: 8px;
 }

 .emergency-banner .pulse {
 animation: pulse 1.5s infinite;
 }

 @keyframes pulse {
 0%, 100% { opacity: 1; }
 50% { opacity: 0.4; }
 }

 /* ==================== RHYTHM SELECTOR ==================== */
 .rhythm-grid {
 display: grid;
 grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
 gap: 0.75rem;
 }

 .rhythm-btn {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.875rem 1rem;
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: 8px;
 cursor: pointer;
 transition: all 0.15s ease;
 color: var(--text-primary);
 text-align: left;
 }

 .rhythm-btn:hover {
 border-color: var(--primary);
 background: rgba(59, 130, 246, 0.08);
 }

 .rhythm-btn.active {
 border-color: var(--primary);
 background: rgba(59, 130, 246, 0.15);
 }

 .rhythm-indicator {
 width: 12px;
 height: 12px;
 border-radius: 50%;
 flex-shrink: 0;
 }

 .rhythm-indicator.green { background: var(--success); }
 .rhythm-indicator.yellow { background: var(--warning); }
 .rhythm-indicator.red { background: var(--danger); }
 .rhythm-indicator.gray { background: #666; }

 /* ==================== SPLIT VIEW ==================== */
 .split-view {
 display: grid;
 grid-template-columns: 1fr 1fr;
 gap: 1.5rem;
 }

 @media (max-width: 900px) {
 .split-view {
 grid-template-columns: 1fr;
 }
 }

 /* ==================== LISTS ==================== */
 .styled-list {
 list-style: none;
 padding: 0;
 }

 .styled-list li {
 position: relative;
 padding-left: 1.5rem;
 margin-bottom: 0.5rem;
 line-height: 1.6;
 }

 .styled-list li::before {
 content: '*';
 position: absolute;
 left: 0;
 color: var(--primary);
 font-weight: bold;
 }

 /* ==================== SCORE CIRCLE ==================== */
 .score-display {
 text-align: center;
 padding: 2rem;
 }

 .score-circle {
 width: 150px;
 height: 150px;
 border-radius: 50%;
 background: conic-gradient(
 var(--success) calc(var(--score, 0) * 1%),
 var(--border) calc(var(--score, 0) * 1%)
 );
 display: flex;
 align-items: center;
 justify-content: center;
 margin: 0 auto 1.5rem;
 }

 .score-inner {
 width: 120px;
 height: 120px;
 background: var(--bg-card);
 border-radius: 50%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 }

 .score-value {
 font-size: 2.25rem;
 font-weight: 700;
 color: var(--success);
 }

 .score-label {
 font-size: 0.85rem;
 color: var(--text-muted);
 }

 /* ==================== LOADING SPINNER ==================== */
 .spinner {
 width: 40px;
 height: 40px;
 border: 3px solid var(--border);
 border-top-color: var(--primary);
 border-radius: 50%;
 animation: spin 0.8s linear infinite;
 }

 @keyframes spin {
 to { transform: rotate(360deg); }
 }

 /* ==================== UTILITIES ==================== */
 .text-center { text-align: center; }
 .text-muted { color: var(--text-muted); }
 .text-success { color: var(--success); }
 .text-danger { color: var(--danger); }
 .text-warning { color: var(--warning); }
 .text-primary { color: var(--primary); }

 .mt-1 { margin-top: 0.5rem; }
 .mt-2 { margin-top: 1rem; }
 .mt-3 { margin-top: 1.5rem; }
 .mb-1 { margin-bottom: 0.5rem; }
 .mb-2 { margin-bottom: 1rem; }
 .mb-3 { margin-bottom: 1.5rem; }

 .hidden { display: none !important; }
 </style>

 <!-- ==================== DEEL 6: COMPLETE CSS STYLING ==================== -->
<style>
/* ==================== CSS VARIABLES & RESET ==================== */
:root {
 /* Colors - Dark Medical Theme */
 --bg-primary: #0a0f1a;
 --bg-secondary: #111827;
 --bg-elevated: #1f2937;
 --bg-hover: #374151;
 
 --text-primary: #f9fafb;
 --text-secondary: #d1d5db;
 --text-muted: #9ca3af;
 
 --border: #374151;
 --border-light: #4b5563;
 
 /* Accent Colors */
 --primary: #3b82f6;
 --primary-hover: #2563eb;
 --primary-light: rgba(59, 130, 246, 0.1);
 
 --success: #22c55e;
 --success-hover: #16a34a;
 --success-light: rgba(34, 197, 94, 0.1);
 
 --danger: #ef4444;
 --danger-hover: #dc2626;
 --danger-light: rgba(239, 68, 68, 0.1);
 
 --warning: #f59e0b;
 --warning-hover: #d97706;
 --warning-light: rgba(245, 158, 11, 0.1);
 
 --info: #06b6d4;
 --info-light: rgba(6, 182, 212, 0.1);
 
 --purple: #8b5cf6;
 --purple-light: rgba(139, 92, 246, 0.1);
 
 /* ECG Colors */
 --ecg-green: #22c55e;
 --ecg-grid: #1a3d1a;
 --ecg-grid-minor: #0d1f0d;
 --ecg-bg: #000000;
 
 /* Shadows */
 --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
 --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
 --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.5);
 --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.3);
 
 /* Spacing */
 --sidebar-width: 260px;
 --header-height: 60px;
 
 /* Transitions */
 --transition-fast: 150ms ease;
 --transition-normal: 250ms ease;
 --transition-slow: 350ms ease;
 
 /* Border Radius */
 --radius-sm: 6px;
 --radius-md: 10px;
 --radius-lg: 16px;
 --radius-xl: 24px;
}

/* Reset */
*, *::before, *::after {
 box-sizing: border-box;
 margin: 0;
 padding: 0;
}

html {
 font-size: 16px;
 scroll-behavior: smooth;
}

body {
 font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
 background: var(--bg-primary);
 color: var(--text-primary);
 line-height: 1.6;
 min-height: 100vh;
 overflow-x: hidden;
}

/* ==================== TYPOGRAPHY ==================== */
h1, h2, h3, h4, h5, h6 {
 font-weight: 600;
 line-height: 1.3;
 color: var(--text-primary);
}

h1 { font-size: 2rem; }
h2 { font-size: 1.5rem; }
h3 { font-size: 1.25rem; }
h4 { font-size: 1.1rem; }

p { margin-bottom: 0.75rem; }

a {
 color: var(--primary);
 text-decoration: none;
 transition: color var(--transition-fast);
}

a:hover { color: var(--primary-hover); }

.text-primary { color: var(--primary) !important; }
.text-success { color: var(--success) !important; }
.text-danger { color: var(--danger) !important; }
.text-warning { color: var(--warning) !important; }
.text-info { color: var(--info) !important; }
.text-muted { color: var(--text-muted) !important; }
.text-center { text-align: center; }

/* ==================== LAYOUT ==================== */
.app-container {
 display: flex;
 min-height: 100vh;
}

/* Sidebar */
.sidebar {
 width: var(--sidebar-width);
 background: var(--bg-secondary);
 border-right: 1px solid var(--border);
 display: flex;
 flex-direction: column;
 position: fixed;
 top: 0;
 left: 0;
 height: 100vh;
 z-index: 100;
 transition: transform var(--transition-normal);
}

.sidebar-header {
 padding: 1.25rem;
 border-bottom: 1px solid var(--border);
 display: flex;
 align-items: center;
 gap: 0.75rem;
}

.sidebar-logo {
 font-size: 2rem;
 animation: pulse-heart 1.5s ease-in-out infinite;
}

@keyframes pulse-heart {
 0%, 100% { transform: scale(1); }
 50% { transform: scale(1.1); }
}

.sidebar-title h1 {
 font-size: 1.1rem;
 font-weight: 700;
 background: linear-gradient(135deg, var(--primary), var(--purple));
 -webkit-background-clip: text;
 -webkit-text-fill-color: transparent;
 background-clip: text;
}

.sidebar-title span {
 font-size: 0.7rem;
 color: var(--text-muted);
}

/* Sidebar Stats */
.sidebar-stats {
 display: grid;
 grid-template-columns: repeat(3, 1fr);
 gap: 0.5rem;
 padding: 1rem;
 border-bottom: 1px solid var(--border);
}

.stat-item {
 text-align: center;
 padding: 0.5rem;
 background: var(--bg-elevated);
 border-radius: var(--radius-sm);
}

.stat-value {
 font-size: 1.1rem;
 font-weight: 700;
 color: var(--primary);
}

.stat-label {
 font-size: 0.65rem;
 color: var(--text-muted);
 text-transform: uppercase;
 letter-spacing: 0.5px;
}

/* Sidebar Navigation */
.sidebar-nav {
 flex: 1;
 overflow-y: auto;
 padding: 0.75rem;
}

.nav-section {
 margin-bottom: 1.5rem;
}

.nav-section-title {
 font-size: 0.7rem;
 font-weight: 600;
 color: var(--text-muted);
 text-transform: uppercase;
 letter-spacing: 1px;
 padding: 0.5rem 0.75rem;
 margin-bottom: 0.25rem;
}

.nav-item {
 display: flex;
 align-items: center;
 gap: 0.75rem;
 padding: 0.75rem;
 border-radius: var(--radius-md);
 cursor: pointer;
 transition: all var(--transition-fast);
 margin-bottom: 2px;
 font-size: 0.9rem;
}

.nav-item:hover {
 background: var(--bg-hover);
}

.nav-item.active {
 background: var(--primary-light);
 color: var(--primary);
 font-weight: 500;
}

.nav-item.active::before {
 content: '';
 position: absolute;
 left: 0;
 width: 3px;
 height: 24px;
 background: var(--primary);
 border-radius: 0 3px 3px 0;
}

.nav-icon {
 font-size: 1.1rem;
 width: 24px;
 text-align: center;
}

/* Main Content */
.main-content {
 flex: 1;
 margin-left: var(--sidebar-width);
 min-height: 100vh;
 display: flex;
 flex-direction: column;
}

.content-header {
 padding: 1.25rem 2rem;
 background: var(--bg-secondary);
 border-bottom: 1px solid var(--border);
 display: flex;
 justify-content: space-between;
 align-items: center;
 position: sticky;
 top: 0;
 z-index: 50;
}

.content-header h2 {
 display: flex;
 align-items: center;
 gap: 0.75rem;
}

.content-area {
 flex: 1;
 padding: 1.5rem 2rem;
 max-width: 1600px;
}

/* ==================== CARDS ==================== */
.card {
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: var(--radius-lg);
 overflow: hidden;
 transition: all var(--transition-normal);
}

.card:hover {
 border-color: var(--border-light);
}

.card-header {
 padding: 1rem 1.25rem;
 border-bottom: 1px solid var(--border);
 display: flex;
 justify-content: space-between;
 align-items: center;
}

.card-title {
 font-size: 1rem;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 0.5rem;
}

.card-body {
 padding: 1.25rem;
}

.card-footer {
 padding: 1rem 1.25rem;
 border-top: 1px solid var(--border);
 background: var(--bg-elevated);
}

/* ==================== GRIDS ==================== */
.grid-2 {
 display: grid;
 grid-template-columns: repeat(2, 1fr);
 gap: 1.5rem;
}

.grid-3 {
 display: grid;
 grid-template-columns: repeat(3, 1fr);
 gap: 1rem;
}

.grid-4 {
 display: grid;
 grid-template-columns: repeat(4, 1fr);
 gap: 1rem;
}

.split-view {
 display: grid;
 grid-template-columns: 2fr 1fr;
 gap: 1.5rem;
}

.split-view > div {
 min-width: 0;
}

@media (max-width: 1200px) {
 .grid-4 { grid-template-columns: repeat(2, 1fr); }
 .split-view { grid-template-columns: 1fr; }
}

@media (max-width: 900px) {
 .grid-2, .grid-3 { grid-template-columns: 1fr; }
}

/* ==================== BUTTONS ==================== */
.btn {
 display: inline-flex;
 align-items: center;
 justify-content: center;
 gap: 0.5rem;
 padding: 0.625rem 1.25rem;
 font-size: 0.9rem;
 font-weight: 500;
 border: none;
 border-radius: var(--radius-md);
 cursor: pointer;
 transition: all var(--transition-fast);
 text-decoration: none;
 white-space: nowrap;
}

.btn:disabled {
 opacity: 0.5;
 cursor: not-allowed;
}

.btn-primary {
 background: var(--primary);
 color: white;
}

.btn-primary:hover:not(:disabled) {
 background: var(--primary-hover);
 transform: translateY(-1px);
 box-shadow: var(--shadow-md);
}

.btn-success {
 background: var(--success);
 color: white;
}

.btn-success:hover:not(:disabled) {
 background: var(--success-hover);
}

.btn-danger {
 background: var(--danger);
 color: white;
}

.btn-danger:hover:not(:disabled) {
 background: var(--danger-hover);
}

.btn-warning {
 background: var(--warning);
 color: #000;
}

.btn-outline {
 background: transparent;
 border: 1px solid var(--border);
 color: var(--text-primary);
}

.btn-outline:hover:not(:disabled) {
 background: var(--bg-hover);
 border-color: var(--border-light);
}

.btn-sm {
 padding: 0.4rem 0.8rem;
 font-size: 0.8rem;
}

.btn-lg {
 padding: 0.875rem 1.75rem;
 font-size: 1rem;
}

.btn-group {
 display: flex;
 gap: 0.75rem;
 flex-wrap: wrap;
}

/* ==================== BADGES ==================== */
.badge {
 display: inline-flex;
 align-items: center;
 padding: 0.25rem 0.625rem;
 font-size: 0.75rem;
 font-weight: 600;
 border-radius: 100px;
 text-transform: capitalize;
}

.badge-easy {
 background: var(--success-light);
 color: var(--success);
}

.badge-medium {
 background: var(--warning-light);
 color: var(--warning);
}

.badge-hard {
 background: var(--danger-light);
 color: var(--danger);
}

.badge-info {
 background: var(--info-light);
 color: var(--info);
}

.badge-primary {
 background: var(--primary-light);
 color: var(--primary);
}

.badge-critical {
 background: var(--danger);
 color: white;
 animation: pulse-badge 1.5s ease-in-out infinite;
}

@keyframes pulse-badge {
 0%, 100% { opacity: 1; }
 50% { opacity: 0.7; }
}

/* ==================== ECG MONITOR ==================== */
.ecg-monitor {
 background: var(--ecg-bg);
 border-radius: var(--radius-lg);
 overflow: hidden;
 border: 2px solid #1f4f1f;
 box-shadow: 0 0 0 1px rgba(57, 255, 20, 0.12), 0 0 18px rgba(57, 255, 20, 0.08);
}

.ecg-monitor-header {
 background: linear-gradient(180deg, #101010, #060606);
 padding: 0.75rem 1rem;
 display: flex;
 justify-content: space-between;
 align-items: center;
 border-bottom: 1px solid #1f4f1f;
}

.ecg-monitor-title {
 display: flex;
 align-items: center;
 gap: 0.5rem;
 font-weight: 600;
 font-size: 0.9rem;
 color: #d7ffd0;
}

.ecg-monitor-vitals {
 display: flex;
 gap: 1.5rem;
}

.vital-display {
 text-align: center;
}

.vital-label {
 font-size: 0.65rem;
 color: #7fbf7f;
 text-transform: uppercase;
 letter-spacing: 1px;
}

.vital-value {
 font-size: 1.5rem;
 font-weight: 700;
 font-family: 'Courier New', monospace;
}

.vital-value.green { color: var(--ecg-green); }
.vital-value.yellow { color: var(--warning); }
.vital-value.red, .vital-value.critical { color: var(--danger); }
.vital-value.blue { color: var(--info); }

.ecg-canvas-wrapper {
 position: relative;
 background: var(--ecg-bg);
 background-image:
 linear-gradient(rgba(57, 255, 20, 0.08) 1px, transparent 1px),
 linear-gradient(90deg, rgba(57, 255, 20, 0.08) 1px, transparent 1px);
 background-size: 20px 20px;
}

.ecg-canvas {
 width: 100%;
 height: 200px;
 display: block;
}

.ecg-canvas.large {
 height: 280px;
}

.ecg-lead-label {
 position: absolute;
 top: 10px;
 left: 15px;
 background: rgba(0, 0, 0, 0.7);
 color: var(--ecg-green);
 padding: 4px 10px;
 border-radius: 4px;
 font-family: 'Courier New', monospace;
 font-size: 0.85rem;
 font-weight: bold;
}

.ecg-controls {
 background: #111;
 padding: 0.75rem 1rem;
 display: flex;
 justify-content: space-between;
 align-items: center;
 border-top: 1px solid #333;
}

.ecg-setting {
 font-size: 0.8rem;
 color: #888;
}

.ecg-setting span {
 color: var(--ecg-green);
 font-weight: 600;
}

/* Monitor layout v2.4.1 */
.monitor-layout-single {
 display: grid;
 gap: 1rem;
}

.monitor-print-card .card-body {
 display: grid;
 gap: 0.9rem;
}

.monitor-paper-wrapper {
 border: 1px solid #efb5bf;
 border-radius: 12px;
 padding: 0.35rem;
 background: #fff9fa;
 box-shadow: inset 0 0 0 1px rgba(190, 24, 93, 0.06);
}

.monitor-paper-grid {
 display: grid;
 grid-template-columns: repeat(4, minmax(0, 1fr));
 gap: 0;
 border: 1px solid #efc6cf;
 border-radius: 8px;
 overflow: hidden;
}

.monitor-paper-lead {
 position: relative;
 border-right: 1px solid #efc6cf;
 border-bottom: 1px solid #efc6cf;
 border-radius: 0;
 overflow: hidden;
 background: #fffdfd;
 cursor: pointer;
 transition: background var(--transition-fast), box-shadow var(--transition-fast);
}

.monitor-paper-lead:nth-child(4n) {
 border-right: none;
}

.monitor-paper-lead:nth-child(n + 9) {
 border-bottom: none;
}

.monitor-paper-lead:hover {
 background: #fff5f7;
}

.monitor-paper-lead.active {
 background: #fff0f3;
 box-shadow: inset 0 0 0 1px rgba(190, 24, 93, 0.26);
}

.monitor-paper-canvas {
 width: 100%;
 height: 102px;
 display: block;
}

.monitor-paper-lead-label {
 position: absolute;
 top: 6px;
 left: 8px;
 font-size: 0.72rem;
 font-weight: 700;
 color: #1f2937;
 background: transparent;
 letter-spacing: 0.02em;
}

.monitor-rhythm-strip {
 margin-top: 0.55rem;
 border-top: 1px dashed #efb5bf;
 padding-top: 0.55rem;
}

.monitor-rhythm-strip-header {
 display: flex;
 justify-content: space-between;
 gap: 0.5rem;
 align-items: center;
 margin-bottom: 0.35rem;
}

.monitor-rhythm-strip-title {
 font-size: 0.8rem;
 font-weight: 600;
 color: #7a1633;
}

.monitor-rhythm-canvas {
 width: 100%;
 height: 190px;
 display: block;
}

.monitor-paper-note {
 font-size: 0.75rem;
 color: #9a2444;
}

.monitor-paper-footer {
 display: flex;
 justify-content: space-between;
 gap: 0.75rem;
 flex-wrap: wrap;
 font-size: 0.73rem;
 color: #7a1633;
 border-top: 1px dashed #efb5bf;
 margin-top: 0.45rem;
 padding-top: 0.4rem;
}

.monitor-controls {
 background: rgba(9, 13, 24, 0.68);
 border: 1px solid var(--border);
 border-radius: 10px;
 padding: 0.85rem;
}

.monitor-quickbar {
 display: grid;
 gap: 0.75rem;
}

.monitor-quick-row {
 display: flex;
 gap: 0.65rem;
 align-items: center;
 flex-wrap: wrap;
}

.monitor-quick-row .btn-group {
 gap: 0.45rem;
}

.monitor-quick-slider {
 display: grid;
 gap: 0.35rem;
}

.monitor-quick-slider label {
 font-size: 0.78rem;
 color: #9dd89d;
}

.monitor-quick-slider input[type="range"] {
 width: 100%;
}

.monitor-quick-selects {
 display: grid;
 gap: 0.4rem;
 grid-template-columns: minmax(150px, 240px) auto auto;
 align-items: center;
}

.monitor-quick-selects label {
 font-size: 0.74rem;
 color: #9dd89d;
 text-transform: uppercase;
 letter-spacing: 0.04em;
}

.monitor-quick-selects select {
 padding: 0.45rem 0.55rem;
 background: #111a11;
 border: 1px solid #285228;
 color: #d7ffd0;
 border-radius: 8px;
}

.monitor-meta-line {
 display: flex;
 gap: 0.45rem;
 align-items: center;
 flex-wrap: wrap;
}

.monitor-advanced-panel {
 margin-top: 0.75rem;
 border: 1px solid #234823;
 border-radius: 10px;
 background: rgba(3, 9, 4, 0.88);
 padding: 0.65rem;
 display: grid;
 gap: 0.65rem;
}

.monitor-advanced-grid {
 display: grid;
 grid-template-columns: repeat(2, minmax(0, 1fr));
 gap: 0.6rem;
}

.monitor-advanced-card {
 border: 1px solid #1d3d1d;
 border-radius: 8px;
 background: rgba(7, 14, 7, 0.8);
 padding: 0.5rem;
}

.monitor-advanced-title {
 font-size: 0.72rem;
 color: #8cc78c;
 text-transform: uppercase;
 letter-spacing: 0.04em;
 margin-bottom: 0.35rem;
}

.monitor-lead-grid {
 display: grid;
 grid-template-columns: repeat(3, minmax(0, 1fr));
 gap: 0.3rem;
}

.rhythm-browser .card-body {
 display: grid;
 gap: 0.75rem;
}

.rhythm-browser-search {
 width: 100%;
 padding: 0.65rem 0.75rem;
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: 8px;
 color: var(--text-primary);
}

.monitor-filter-chips {
 display: flex;
 gap: 0.45rem;
 flex-wrap: wrap;
}

.monitor-filter-chips .btn.btn-sm {
 padding: 0.3rem 0.58rem;
}

.rhythm-browser-list {
 max-height: 420px;
 overflow-y: auto;
 border: 1px solid var(--border);
 border-radius: 10px;
 padding: 0.5rem;
 background: rgba(6, 12, 20, 0.35);
}

.library-grid-readable {
 display: grid;
 grid-template-columns: repeat(2, minmax(0, 1fr));
 gap: 1rem;
}

.library-rhythm-card {
 cursor: pointer;
}

.library-rhythm-card .card-body {
 display: grid;
 gap: 0.68rem;
}

.library-meta-row {
 display: flex;
 align-items: center;
 flex-wrap: wrap;
 gap: 0.42rem;
}

.library-calibration-chip {
 display: inline-flex;
 align-items: center;
 gap: 0.35rem;
 background: #fff3f5;
 border: 1px solid #efb5bf;
 color: #8b1d42;
 padding: 0.22rem 0.52rem;
 border-radius: 999px;
 font-size: 0.72rem;
 font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
}

.library-preview-monitor {
 border-radius: 10px;
 overflow: hidden;
}

.library-preview-canvas {
 width: 100%;
 height: 140px;
 display: block;
}

.library-signature {
 font-size: 0.84rem;
 color: #7a1633;
 line-height: 1.42;
}

.library-diff-block {
 border: 1px solid #efc6cf;
 border-radius: 8px;
 background: #fff6f8;
 padding: 0.52rem 0.62rem;
 display: grid;
 gap: 0.35rem;
 font-size: 0.79rem;
 line-height: 1.36;
 color: #6d1f3a;
}

.library-diff-block strong {
 color: #8e1b40;
}

.library-desc {
 font-size: 0.8rem;
 color: var(--text-muted);
 line-height: 1.45;
}

@media (max-width: 1100px) {
 .monitor-paper-grid {
 grid-template-columns: repeat(3, minmax(0, 1fr));
 }

 .monitor-quick-selects {
 grid-template-columns: 1fr;
 align-items: start;
 }

 .monitor-advanced-grid {
 grid-template-columns: 1fr;
 }

 .library-grid-readable {
 grid-template-columns: 1fr;
 }

 .library-preview-canvas {
 height: 120px;
 }
}

@media (max-width: 768px) {
 .monitor-paper-grid {
 grid-template-columns: repeat(2, minmax(0, 1fr));
 }

 .monitor-paper-lead:nth-child(4n) {
 border-right: 1px solid #efc6cf;
 }

 .monitor-paper-lead:nth-child(2n) {
 border-right: none;
 }

 .monitor-paper-lead:nth-child(n + 9) {
 border-bottom: 1px solid #efc6cf;
 }

 .monitor-paper-lead:nth-child(n + 11) {
 border-bottom: none;
 }

 .monitor-rhythm-canvas {
 height: 180px;
 }

 .monitor-lead-grid {
 grid-template-columns: repeat(2, minmax(0, 1fr));
 }

 .rhythm-browser-list {
 max-height: 340px;
 }

 .library-preview-canvas {
 height: 96px;
 }

 .library-meta-row {
 gap: 0.32rem;
 }

 .library-calibration-chip {
 font-size: 0.68rem;
 padding: 0.2rem 0.45rem;
 }
}

/* Pulse Animation */
.pulse {
 display: inline-block;
 color: var(--danger);
 animation: pulse 1s ease-in-out infinite;
}

@keyframes pulse {
 0%, 100% { opacity: 1; transform: scale(1); }
 50% { opacity: 0.5; transform: scale(0.95); }
}

/* ==================== VITALS GRID ==================== */
.vitals-grid {
 display: grid;
 grid-template-columns: repeat(4, 1fr);
 gap: 1rem;
}

.vital-card {
 background: var(--bg-elevated);
 padding: 1rem;
 border-radius: var(--radius-md);
 text-align: center;
 border: 1px solid var(--border);
}

.vital-card-label {
 font-size: 0.75rem;
 color: var(--text-muted);
 text-transform: uppercase;
 letter-spacing: 0.5px;
 margin-bottom: 0.25rem;
}

.vital-card-value {
 font-size: 1.5rem;
 font-weight: 700;
}

@media (max-width: 768px) {
 .vitals-grid {
 grid-template-columns: repeat(2, 1fr);
 }
}

/* ==================== QUICK ACTIONS ==================== */
.quick-actions {
 display: grid;
 grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
 gap: 1rem;
}

.quick-action {
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: var(--radius-md);
 padding: 1.25rem;
 text-align: center;
 cursor: pointer;
 transition: all var(--transition-normal);
}

.quick-action:hover {
 background: var(--bg-hover);
 border-color: var(--primary);
 transform: translateY(-2px);
}

.quick-action-icon {
 font-size: 2rem;
 margin-bottom: 0.5rem;
}

.quick-action-title {
 font-weight: 600;
 margin-bottom: 0.25rem;
}

.quick-action-desc {
 font-size: 0.8rem;
 color: var(--text-muted);
}

.quick-action.locked {
 opacity: 0.6;
 cursor: not-allowed;
 border-style: dashed;
}

.quick-action.locked:hover {
 background: var(--bg-elevated);
 border-color: var(--border);
 transform: none;
}

.quick-action-help {
 font-size: 0.78rem;
 color: var(--text-muted);
 margin-top: 0.5rem;
}

/* ==================== TOPIC/RHYTHM CARDS ==================== */
.topic-card {
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: var(--radius-md);
 padding: 1.25rem;
 cursor: pointer;
 transition: all var(--transition-normal);
}

.topic-card:hover {
 border-color: var(--primary);
 transform: translateY(-2px);
 box-shadow: var(--shadow-md);
}

.topic-card-icon {
 font-size: 2rem;
 margin-bottom: 0.75rem;
}

.topic-card-title {
 font-weight: 600;
 margin-bottom: 0.25rem;
}

.topic-card-desc {
 font-size: 0.85rem;
 color: var(--text-muted);
 margin-bottom: 0.75rem;
}

.topic-card-meta {
 display: flex;
 justify-content: space-between;
 align-items: center;
 font-size: 0.8rem;
 color: var(--text-muted);
}

/* Rhythm Buttons Grid */
.rhythm-grid {
 display: flex;
 flex-wrap: wrap;
 gap: 0.5rem;
}

.rhythm-btn {
 display: inline-flex;
 align-items: center;
 gap: 0.5rem;
 padding: 0.5rem 0.875rem;
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: var(--radius-md);
 color: var(--text-primary);
 font-size: 0.85rem;
 cursor: pointer;
 transition: all var(--transition-fast);
}

.rhythm-btn:hover {
 background: var(--bg-hover);
 border-color: var(--primary);
}

.rhythm-btn.active {
 background: var(--primary-light);
 border-color: var(--primary);
 color: var(--primary);
}

.rhythm-indicator {
 width: 8px;
 height: 8px;
 border-radius: 50%;
}

.rhythm-indicator.green { background: var(--success); }
.rhythm-indicator.yellow { background: var(--warning); }
.rhythm-indicator.red { background: var(--danger); }

/* ==================== QUIZ COMPONENTS ==================== */
.quiz-options {
 display: flex;
 flex-direction: column;
 gap: 0.75rem;
}

.quiz-option {
 display: flex;
 align-items: center;
 gap: 1rem;
 padding: 1rem 1.25rem;
 background: var(--bg-elevated);
 border: 2px solid var(--border);
 border-radius: var(--radius-md);
 cursor: pointer;
 transition: all var(--transition-fast);
}

.quiz-option:hover:not(.disabled) {
 border-color: var(--primary);
 background: var(--primary-light);
}

.quiz-option.selected {
 border-color: var(--primary);
 background: var(--primary-light);
}

.quiz-option.correct {
 border-color: var(--success);
 background: var(--success-light);
}

.quiz-option.incorrect {
 border-color: var(--danger);
 background: var(--danger-light);
}

.quiz-option.disabled {
 cursor: default;
 opacity: 0.8;
}

.quiz-option-key {
 width: 32px;
 height: 32px;
 display: flex;
 align-items: center;
 justify-content: center;
 background: var(--bg-hover);
 border-radius: var(--radius-sm);
 font-weight: 700;
 font-size: 0.9rem;
}

.quiz-option.correct .quiz-option-key {
 background: var(--success);
 color: white;
}

.quiz-option.incorrect .quiz-option-key {
 background: var(--danger);
 color: white;
}

.quiz-option-content {
 flex: 1;
}

.quiz-option-title {
 font-weight: 600;
 margin-bottom: 0.25rem;
}

.quiz-option-desc {
 font-size: 0.85rem;
 color: var(--text-muted);
}

/* Quiz ECG hybrid 12-lead */
.quiz-hybrid-layout {
 display: grid;
 gap: 0.65rem;
}

.quiz-ecg-toolbar {
 display: flex;
 justify-content: space-between;
 align-items: center;
 gap: 0.75rem;
 flex-wrap: wrap;
 margin-bottom: 0.6rem;
}

.quiz-ecg-meta-compact {
 display: flex;
 gap: 0.45rem;
 align-items: center;
 flex-wrap: wrap;
}

.quiz-calibration-chip {
 display: inline-flex;
 align-items: center;
 gap: 0.45rem;
 background: #fff3f5;
 border: 1px solid #f2b9c1;
 color: #9f1239;
 padding: 0.28rem 0.6rem;
 border-radius: 999px;
 font-size: 0.74rem;
 font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
}

.quiz-lead-hint {
 font-size: 0.78rem;
 color: var(--text-muted);
}

.quiz-focus-panel {
 border: 1px solid #f2b9c1;
 border-radius: var(--radius-md);
 overflow: hidden;
 background: #fff7f8;
}

.quiz-focus-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 0.45rem 0.75rem;
 background: #fff0f3;
 border-bottom: 1px solid #f4c7cf;
}

.quiz-focus-title {
 font-size: 0.82rem;
 font-weight: 600;
 color: #831843;
}

.quiz-focus-lead {
 color: #be123c;
 font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
 font-weight: 700;
}

.quiz-focus-canvas-wrap {
 position: relative;
}

.quiz-focus-canvas {
 width: 100%;
 height: 250px;
 display: block;
}

.quiz-lead-groups {
 border: 1px solid #efb5bf;
 border-radius: var(--radius-md);
 padding: 0.25rem;
 background: #fff9fa;
 overflow: hidden;
}

.quiz-lead-grid {
 display: grid;
 grid-template-columns: repeat(4, minmax(0, 1fr));
 gap: 0;
 border: 1px solid #efc6cf;
 border-radius: 8px;
 overflow: hidden;
}

.quiz-lead-card {
 border-right: 1px solid #efc6cf;
 border-bottom: 1px solid #efc6cf;
 border-radius: 0;
 background: #fffdfd;
 padding: 0.2rem;
 cursor: pointer;
 transition: all var(--transition-fast);
}

.quiz-lead-card:nth-child(4n) {
 border-right: none;
}

.quiz-lead-card:nth-child(n + 9) {
 border-bottom: none;
}

.quiz-lead-card:hover {
 background: #fff5f7;
}

.quiz-lead-card.active {
 background: #ffe8ee;
 box-shadow: inset 0 0 0 1px rgba(190, 24, 93, 0.24);
}

.quiz-lead-card.key-lead {
 box-shadow: inset 0 0 0 1px rgba(219, 39, 119, 0.2);
}

.quiz-lead-canvas {
 width: 100%;
 height: 96px;
 display: block;
}

.quiz-lead-caption {
 display: flex;
 justify-content: space-between;
 align-items: center;
 margin-top: 0.1rem;
 font-size: 0.68rem;
}

.quiz-lead-name {
 color: #831843;
 font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
 font-weight: 700;
}

.quiz-lead-role {
 color: var(--text-muted);
 font-size: 0.62rem;
}

/* Feedback Panel */
.feedback-panel {
 display: none;
 margin-top: 1.5rem;
 padding: 1.25rem;
 border-radius: var(--radius-md);
 animation: slideIn 0.3s ease-out;
}

.feedback-panel.show {
 display: block;
}

.feedback-panel.correct {
 background: var(--success-light);
 border: 1px solid var(--success);
}

.feedback-panel.incorrect {
 background: var(--danger-light);
 border: 1px solid var(--danger);
}

@keyframes slideIn {
 from {
 opacity: 0;
 transform: translateY(-10px);
 }
 to {
 opacity: 1;
 transform: translateY(0);
 }
}

.feedback-header {
 display: flex;
 align-items: center;
 gap: 1rem;
}

.feedback-icon {
 width: 48px;
 height: 48px;
 display: flex;
 align-items: center;
 justify-content: center;
 border-radius: 50%;
 font-size: 1.5rem;
 font-weight: 700;
}

.feedback-panel.correct .feedback-icon {
 background: var(--success);
 color: white;
}

.feedback-panel.incorrect .feedback-icon {
 background: var(--danger);
 color: white;
}

.feedback-title {
 font-size: 1.1rem;
 font-weight: 700;
}

.feedback-subtitle {
 color: var(--text-muted);
 font-size: 0.9rem;
}

/* Score Display */
.score-display {
 text-align: center;
 padding: 2rem;
}

.score-circle {
 width: 150px;
 height: 150px;
 border-radius: 50%;
 background: conic-gradient(var(--primary) calc(var(--score) * 1%), var(--bg-elevated) 0);
 display: flex;
 align-items: center;
 justify-content: center;
 margin: 0 auto 1.5rem;
 position: relative;
}

.score-circle::before {
 content: '';
 position: absolute;
 width: 120px;
 height: 120px;
 background: var(--bg-secondary);
 border-radius: 50%;
}

.score-inner {
 position: relative;
 z-index: 1;
}

.score-value {
 font-size: 2rem;
 font-weight: 700;
 color: var(--primary);
}

.score-label {
 font-size: 0.75rem;
 color: var(--text-muted);
 text-transform: uppercase;
}

/* Progress Bar */
.progress-bar {
 height: 10px;
 background: var(--bg-elevated);
 border-radius: 100px;
 overflow: hidden;
}

.progress-fill {
 height: 100%;
 background: linear-gradient(90deg, var(--primary), var(--purple));
 border-radius: 100px;
 transition: width var(--transition-normal);
}

.progress-fill.warning {
 background: linear-gradient(90deg, var(--warning), var(--danger));
}

.progress-fill.danger {
 background: var(--danger);
}

/* ==================== TABLES ==================== */
.data-table {
 width: 100%;
 border-collapse: collapse;
}

.data-table th,
.data-table td {
 padding: 0.875rem 1rem;
 text-align: left;
 border-bottom: 1px solid var(--border);
}

.data-table th {
 font-weight: 600;
 color: var(--text-muted);
 font-size: 0.85rem;
 text-transform: uppercase;
 letter-spacing: 0.5px;
 background: var(--bg-elevated);
}

.data-table tbody tr:hover {
 background: var(--bg-elevated);
}

/* ==================== LISTS ==================== */
.styled-list {
 list-style: none;
 padding: 0;
 margin: 0;
}

.styled-list li {
 position: relative;
 padding-left: 1.5rem;
 margin-bottom: 0.5rem;
}

.styled-list li::before {
 content: '*';
 position: absolute;
 left: 0;
 color: var(--primary);
 font-weight: bold;
}

/* ==================== INFO BOXES ==================== */
.info-box {
 display: flex;
 gap: 1rem;
 padding: 1rem 1.25rem;
 border-radius: var(--radius-md);
 border: 1px solid;
}

.info-box.info {
 background: var(--info-light);
 border-color: var(--info);
}

.info-box.success {
 background: var(--success-light);
 border-color: var(--success);
}

.info-box.warning {
 background: var(--warning-light);
 border-color: var(--warning);
}

.info-box.danger {
 background: var(--danger-light);
 border-color: var(--danger);
}

.info-box-icon {
 font-size: 1.25rem;
 flex-shrink: 0;
}

.info-box-content h4 {
 margin-bottom: 0.25rem;
 font-size: 0.95rem;
}

.info-box-content p {
 font-size: 0.9rem;
 margin: 0;
}

/* ==================== ALGORITHM BOXES ==================== */
.algorithm-box {
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: var(--radius-md);
 padding: 1.25rem;
 border-left: 4px solid var(--border);
}

.algorithm-box.info { border-left-color: var(--info); }
.algorithm-box.success { border-left-color: var(--success); }
.algorithm-box.warning { border-left-color: var(--warning); }
.algorithm-box.critical { border-left-color: var(--danger); background: var(--danger-light); }

.algorithm-title {
 font-weight: 700;
 font-size: 1rem;
 margin-bottom: 0.75rem;
 display: flex;
 align-items: center;
 gap: 0.5rem;
}

.algorithm-steps {
 display: flex;
 flex-direction: column;
 gap: 0.75rem;
}

.algorithm-step {
 display: flex;
 align-items: flex-start;
 gap: 0.75rem;
 padding: 0.75rem;
 background: var(--bg-secondary);
 border-radius: var(--radius-sm);
}

.algorithm-step.critical {
 background: var(--danger-light);
 border: 1px solid var(--danger);
}

.algorithm-step-num {
 width: 28px;
 height: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 background: var(--primary);
 color: white;
 border-radius: 50%;
 font-weight: 700;
 font-size: 0.85rem;
 flex-shrink: 0;
}

.algorithm-step.critical .algorithm-step-num {
 background: var(--danger);
}

/* ==================== ACCORDIONS ==================== */
.accordion-item {
 border: 1px solid var(--border);
 border-radius: var(--radius-md);
 overflow: hidden;
}

.accordion-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 1rem 1.25rem;
 background: var(--bg-elevated);
 cursor: pointer;
 transition: background var(--transition-fast);
}

.accordion-header:hover {
 background: var(--bg-hover);
}

.accordion-header h4 {
 display: flex;
 align-items: center;
 gap: 0.5rem;
 font-size: 0.95rem;
}

.accordion-icon {
 transition: transform var(--transition-fast);
 font-size: 0.8rem;
}

.accordion-item.open .accordion-icon {
 transform: rotate(180deg);
}

.accordion-body {
 max-height: 0;
 overflow: hidden;
 transition: max-height var(--transition-normal);
}

.accordion-item.open .accordion-body {
 max-height: 2000px;
}

.accordion-content {
 padding: 1.25rem;
 border-top: 1px solid var(--border);
}

/* ==================== TABS ==================== */
.tabs {
 display: flex;
 gap: 0.5rem;
 margin-bottom: 1.5rem;
 border-bottom: 1px solid var(--border);
 padding-bottom: 0.5rem;
 flex-wrap: wrap;
}

.tab {
 padding: 0.625rem 1rem;
 background: transparent;
 border: 1px solid transparent;
 border-radius: var(--radius-md);
 cursor: pointer;
 font-size: 0.9rem;
 color: var(--text-muted);
 transition: all var(--transition-fast);
}

.tab:hover {
 color: var(--text-primary);
 background: var(--bg-elevated);
}

.tab.active {
 background: var(--primary-light);
 color: var(--primary);
 border-color: var(--primary);
 font-weight: 500;
}

.tab-content {
 display: none;
}

.tab-content.active {
 display: block;
 animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
 from { opacity: 0; }
 to { opacity: 1; }
}

/* ==================== CLINICAL CASE ==================== */
.case-header {
 display: flex;
 gap: 1rem;
 align-items: center;
}

.case-avatar {
 width: 64px;
 height: 64px;
 background: var(--bg-elevated);
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 2rem;
 border: 2px solid var(--border);
}

.case-info h3 {
 margin-bottom: 0.25rem;
}

.case-info p {
 color: var(--text-muted);
 font-size: 0.9rem;
 margin: 0;
}

/* ==================== EMERGENCY BANNER ==================== */
.emergency-banner {
 background: linear-gradient(90deg, var(--danger), var(--warning));
 color: white;
 padding: 0.875rem 1.5rem;
 display: flex;
 align-items: center;
 gap: 0.75rem;
 font-weight: 600;
 margin-bottom: 1.5rem;
 border-radius: var(--radius-md);
}

/* ==================== SETTINGS ==================== */
.settings-group {
 background: var(--bg-elevated);
 border-radius: var(--radius-md);
 overflow: hidden;
 border: 1px solid var(--border);
}

.setting-item {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 1rem 1.25rem;
 border-bottom: 1px solid var(--border);
}

.setting-item:last-child {
 border-bottom: none;
}

.setting-name {
 font-weight: 500;
 margin-bottom: 0.125rem;
}

.setting-desc {
 font-size: 0.8rem;
 color: var(--text-muted);
}

.setting-item select {
 padding: 0.5rem 1rem;
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: var(--radius-sm);
 color: var(--text-primary);
 min-width: 120px;
}

/* ==================== ACHIEVEMENTS ==================== */
.achievement-card {
 background: var(--bg-elevated);
 border: 1px solid var(--border);
 border-radius: var(--radius-md);
 padding: 1.25rem;
 text-align: center;
 transition: all var(--transition-normal);
}

.achievement-card.unlocked {
 border-color: var(--warning);
 background: var(--warning-light);
}

.achievement-card.locked {
 opacity: 0.6;
}

.achievement-card-icon {
 font-size: 2.5rem;
 margin-bottom: 0.5rem;
}

.achievement-card-name {
 font-weight: 600;
 margin-bottom: 0.25rem;
}

.achievement-card-desc {
 font-size: 0.8rem;
 color: var(--text-muted);
 margin-bottom: 0.5rem;
}

.achievement-card-reward {
 font-size: 0.85rem;
 color: var(--primary);
 font-weight: 600;
}

/* Achievement Notification */
.achievement-notification {
 position: fixed;
 top: 20px;
 right: 20px;
 background: var(--bg-secondary);
 border: 2px solid var(--warning);
 border-radius: var(--radius-lg);
 padding: 1.25rem;
 display: flex;
 gap: 1rem;
 align-items: center;
 z-index: 9999;
 box-shadow: var(--shadow-lg);
 transform: translateX(120%);
 transition: transform var(--transition-normal);
 max-width: 350px;
}

.achievement-notification.show {
 transform: translateX(0);
}

.achievement-notification .achievement-icon {
 font-size: 2.5rem;
}

.achievement-notification .achievement-title {
 font-size: 0.75rem;
 color: var(--warning);
 text-transform: uppercase;
 letter-spacing: 1px;
}

.achievement-notification .achievement-name {
 font-weight: 700;
 font-size: 1.1rem;
}

.achievement-notification .achievement-desc {
 font-size: 0.85rem;
 color: var(--text-muted);
}

.achievement-notification .achievement-reward {
 font-size: 0.9rem;
 color: var(--primary);
 font-weight: 600;
 margin-top: 0.25rem;
}

/* ==================== MODAL ==================== */
.modal-overlay {
 position: fixed;
 inset: 0;
 background: rgba(0, 0, 0, 0.8);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 1000;
 opacity: 0;
 visibility: hidden;
 transition: all var(--transition-normal);
 padding: 1rem;
}

.modal-overlay.show {
 opacity: 1;
 visibility: visible;
}

.modal {
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: var(--radius-lg);
 max-width: 700px;
 width: 100%;
 max-height: 90vh;
 overflow: hidden;
 display: flex;
 flex-direction: column;
 transform: scale(0.9);
 transition: transform var(--transition-normal);
}

.modal-overlay.show .modal {
 transform: scale(1);
}

.modal-header {
 padding: 1.25rem 1.5rem;
 border-bottom: 1px solid var(--border);
 display: flex;
 justify-content: space-between;
 align-items: center;
}

.modal-title {
 font-size: 1.2rem;
 font-weight: 600;
}

.modal-close {
 width: 32px;
 height: 32px;
 display: flex;
 align-items: center;
 justify-content: center;
 background: var(--bg-elevated);
 border: none;
 border-radius: var(--radius-sm);
 cursor: pointer;
 color: var(--text-muted);
 font-size: 1.25rem;
 transition: all var(--transition-fast);
}

.modal-close:hover {
 background: var(--bg-hover);
 color: var(--text-primary);
}

.modal-body {
 padding: 1.5rem;
 overflow-y: auto;
 flex: 1;
}

.modal-footer {
 padding: 1rem 1.5rem;
 border-top: 1px solid var(--border);
 display: flex;
 justify-content: flex-end;
 gap: 0.75rem;
}

/* ==================== UTILITIES ==================== */
.mt-2 { margin-top: 1rem; }
.mt-3 { margin-top: 1.5rem; }
.mb-2 { margin-bottom: 1rem; }
.mb-3 { margin-bottom: 1.5rem; }

.hidden { display: none !important; }

/* ==================== RESPONSIVE ==================== */
@media (max-width: 1024px) {
 .sidebar {
 transform: translateX(-100%);
 }
 
 .sidebar.open {
 transform: translateX(0);
 }
 
 .main-content {
 margin-left: 0;
 }
 
 .content-area {
 padding: 1rem;
 }
 
 .ecg-canvas.large {
 height: 200px;
 }

 .quiz-lead-grid {
 grid-template-columns: repeat(3, minmax(0, 1fr));
 }

 .quiz-lead-card:nth-child(4n) {
 border-right: 1px solid #efc6cf;
 }

 .quiz-lead-card:nth-child(3n) {
 border-right: none;
 }

 .quiz-lead-card:nth-child(n + 9) {
 border-bottom: 1px solid #efc6cf;
 }

 .quiz-lead-card:nth-child(n + 10) {
 border-bottom: none;
 }
}

@media (max-width: 768px) {
 .content-header {
 padding: 1rem;
 }
 
 .vitals-grid {
 grid-template-columns: repeat(2, 1fr);
 }
 
 .quick-actions {
 grid-template-columns: 1fr 1fr;
 }
 
 .grid-3 {
 grid-template-columns: 1fr;
 }
 
 .modal {
 max-height: 100vh;
 border-radius: 0;
 }
 
 .achievement-notification {
 left: 10px;
 right: 10px;
 max-width: none;
 }

 .quiz-focus-panel {
 position: sticky;
 top: 62px;
 z-index: 5;
 }

 .quiz-focus-canvas {
 height: 230px;
 }

 .quiz-lead-grid {
 grid-template-columns: repeat(2, minmax(0, 1fr));
 }

 .quiz-lead-card:nth-child(3n) {
 border-right: 1px solid #efc6cf;
 }

 .quiz-lead-card:nth-child(2n) {
 border-right: none;
 }

 .quiz-lead-card:nth-child(n + 10) {
 border-bottom: 1px solid #efc6cf;
 }

 .quiz-lead-card:nth-child(n + 11) {
 border-bottom: none;
 }
}

@media (max-width: 480px) {
 html {
 font-size: 14px;
 }
 
 .quick-actions {
 grid-template-columns: 1fr;
 }
 
 .btn-group {
 flex-direction: column;
 }
 
 .tabs {
 overflow-x: auto;
 flex-wrap: nowrap;
 }
}

/* ==================== PRINT STYLES ==================== */
@media print {
 .sidebar,
 .content-header,
 .btn,
 .modal-overlay {
 display: none !important;
 }
 
 .main-content {
 margin-left: 0;
 }
 
 .card {
 break-inside: avoid;
 border: 1px solid #ccc;
 }
}

/* ==================== SCROLLBAR ==================== */
::-webkit-scrollbar {
 width: 8px;
 height: 8px;
}

::-webkit-scrollbar-track {
 background: var(--bg-primary);
}

::-webkit-scrollbar-thumb {
 background: var(--bg-hover);
 border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
 background: var(--border-light);
}

/* ==================== SELECTION ==================== */
::selection {
 background: var(--primary);
 color: white;
}
</style>
</head>
<body>
 <div class="app-container">
 <!-- SIDEBAR -->
 <aside class="sidebar" id="sidebar">
 <div class="sidebar-header">
 <div class="logo">
<div class="logo-icon">&#x1F9E0;</div>
 <div>
 <div class="logo-text">ECG Trainer Pro</div>
 <div class="logo-subtitle">Intensive Care Editie v2.5</div>
 </div>
 </div>
 </div>

 <nav class="sidebar-nav">
 <div class="nav-section">
 <div class="nav-section-title">Hoofdmenu</div>
 <div class="nav-item active" data-section="dashboard">
<span class="nav-item-icon">&#x1F4CA;</span>
 <span>Dashboard</span>
 </div>
 <div class="nav-item" data-section="monitor">
<span class="nav-item-icon">&#x1F4FA;</span>
 <span>Monitor Simulator</span>
 <span class="nav-item-badge yellow">Live</span>
 </div>
 </div>

 <div class="nav-section">
 <div class="nav-section-title">Leren</div>
 <div class="nav-item" data-section="coach">
<span class="nav-item-icon">&#x1F9ED;</span>
 <span>Leercoach</span>
 <span class="nav-item-badge blue">Adaptief</span>
 </div>
 <div class="nav-item" data-section="learningPath">
<span class="nav-item-icon">&#x1F5FA;</span>
 <span>Leerpad</span>
 <span class="nav-item-badge blue">Nieuw</span>
 </div>
 <div class="nav-item" data-section="library">
<span class="nav-item-icon">&#x1F4DA;</span>
 <span>ECG Bibliotheek</span>
 <span class="nav-item-badge green">40+</span>
 </div>
 <div class="nav-item" data-section="systematic">
<span class="nav-item-icon">&#x1F4DD;</span>
 <span>Systematische Analyse</span>
 </div>
 </div>

 <div class="nav-section">
 <div class="nav-section-title">Oefenen</div>
 <div class="nav-item" data-section="quiz">
<span class="nav-item-icon">&#x2753;</span>
 <span>Quiz Modus</span>
 </div>
 <div class="nav-item" data-section="cases">
<span class="nav-item-icon">&#x1F3E5;</span>
 <span>Klinische Cases</span>
 </div>
 </div>

 <div class="nav-section">
 <div class="nav-section-title">Protocollen</div>
 <div class="nav-item" data-section="acls">
<span class="nav-item-icon">&#x1F6A8;</span>
 <span>ACLS Algoritmes</span>
 <span class="nav-item-badge red">Spoed</span>
 </div>
 <div class="nav-item" data-section="drugs">
<span class="nav-item-icon">&#x1F48A;</span>
 <span>Medicatie & ECG</span>
 </div>
 </div>

 <div class="nav-section">
 <div class="nav-section-title">Referentie</div>
 <div class="nav-item" data-section="criteria">
<span class="nav-item-icon">&#x1F4CF;</span>
 <span>Criteria & Waarden</span>
 </div>
 </div>

 <div class="nav-section">
 <div class="nav-section-title">Profiel</div>
 <div class="nav-item" data-section="progress">
<span class="nav-item-icon">&#x1F4C8;</span>
 <span>Voortgang</span>
 </div>
 <div class="nav-item" data-section="achievements">
<span class="nav-item-icon">&#x1F3C6;</span>
 <span>Prestaties</span>
 </div>
 <div class="nav-item" data-section="settings">
<span class="nav-item-icon">&#x2699;</span>
 <span>Instellingen</span>
 </div>
 </div>
 </nav>

 <div class="sidebar-stats">
 <div class="stat-row">
<span class="stat-label">&#x1F525; Reeks</span>
 <span class="stat-value" id="sidebarStreak">0</span>
 </div>
 <div class="stat-row">
<span class="stat-label">&#x2728; XP</span>
 <span class="stat-value" id="sidebarXP">0</span>
 </div>
 <div class="stat-row">
<span class="stat-label">&#x1F3AF; Nauwkeurigheid</span>
 <span class="stat-value" id="sidebarAccuracy">0%</span>
 </div>
 <div class="stat-row">
<span class="stat-label">&#x1F464; Profiel</span>
 <span class="stat-value" id="sidebarProfile">Standaard</span>
 </div>
 </div>
 </aside>

 <!-- MAIN CONTENT -->
 <main class="main-content">
 <header class="top-bar">
 <div class="top-bar-heading">
 <h1 class="top-bar-title" id="pageTitle">Dashboard</h1>
 <div class="page-breadcrumb" id="pageBreadcrumb">Dashboard</div>
 </div>
 <div class="top-bar-actions">
 <button class="btn btn-primary btn-sm" onclick="ECGApp.startQuickQuiz()"> Snelle Quiz
 </button>
 </div>
 </header>

 <div class="content-area" id="contentArea">
 <!-- Sections worden hier geladen -->
 </div>
 </main>
 </div>

 <!-- MODAL -->
 <div class="modal-overlay" id="modal">
 <div class="modal">
 <div class="modal-header">
 <h2 class="modal-title" id="modalTitle">Modal</h2>
 <button class="modal-close" onclick="ECGApp.closeModal()">×</button>
 </div>
 <div class="modal-body" id="modalBody"></div>
 <div class="modal-footer" id="modalFooter">
 <button class="btn btn-outline" onclick="ECGApp.closeModal()">Sluiten</button>
 </div>
 </div>
 </div>

 <script>
 // ==================== DEEL 2 START HIER ====================

 // ==================== STATE MANAGEMENT ====================
 const AppState = {
 currentSection: 'dashboard',
 profile: {
 id: 'default',
 name: 'Standaard'
 },
 ui: {
 onboardingCompleted: false,
 contextualHelp: true,
 compactMode: false,
 lastVisitedSection: 'dashboard'
 },
 quizQuality: {
 repeatGuardWindow: 5,
 diversityWindow: 10,
 maxCategoryShare: 0.4,
 minUniqueRatioTarget: 0.75
 },
 user: {
 streak: 0,
 xp: 0,
 totalAnswered: 0,
 totalCorrect: 0,
 level: 1,
 achievements: [],
 quizHistory: [],
 lastActive: null,
 completedTopics: [],
 masteredRhythms: []
 },
 quiz: {
 active: false,
 mode: 'standard', // 'standard', 'timed', 'survival', 'clinical', 'exam', 'recovery', 'coach', 'sprint', 'critical'
 difficulty: 'all', // 'easy', 'medium', 'hard', 'all'
 category: 'all',
 moduleId: null,
 predefinedRhythms: [],
 examBlueprintQueue: [],
 currentQuestion: 0,
 totalQuestions: 10,
 score: 0,
 answers: [],
 timeRemaining: 0,
 timerInterval: null,
 currentRhythm: null,
 selectedAnswer: null,
 showingFeedback: false,
 pendingConfidence: null,
 pendingAnswerIndex: null,
 currentOptionIds: [],
 currentAdaptiveProfile: null,
 currentQuestionPayload: null,
 questionType: 'recognition',
 questionTypeMix: {
 recognition: 0.5,
 differential: 0.3,
 first_action: 0.2
 }
 },
 quizView: {
 layout: 'hybrid12', // hybrid12 | lead_switch
 focusLead: 'II',
 showLeadLabels: true,
 showCalibrationBar: true,
 compactMeta: true,
 showDetailedCalibration: false,
 mobileLayout: 'two_col_focus', // two_col_focus | tabs
 zoom: 1
 },
 monitor: {
 currentRhythm: 'sinus_normal',
 speed: 25,
 amplitude: 1,
 zoom: 1,
 heartRate: 72,
 lead: 'II',
 artifactLevel: 'none',
 showIntervalsOverlay: false,
 freezeFrame: false,
 isRunning: false,
 animationId: null,
 ui: {
 advancedOpen: false,
 rhythmPanelOpen: true,
 rhythmSearch: '',
 rhythmCategory: 'all',
 showLeadPad: false
 }
 },
 library: {
 selectedCategory: 'all',
 searchQuery: '',
 selectedRhythm: null
 },
 libraryView: {
 defaultLead: 'II',
 previewSeconds: 8,
 highContrast: true,
 compactCards: false,
 lazyRenderBatch: 12
 },
 settings: {
 soundEnabled: true,
 animationsEnabled: true,
 showHints: true,
 darkMode: true,
 defaultQuizCount: 10,
 timerSeconds: 30,
 guidelineProfile: 'ERC/ESC',
 examinerMode: true
 },
 learningPath: {
 currentModule: 'module_1',
 modules: ['module_1', 'module_2', 'module_3', 'module_4', 'module_5', 'module_6', 'module_7', 'module_8'],
 completedModules: [],
 weeklyFocus: [],
 completedCases: [],
 dailyRoundState: {
 date: '',
 caseIds: [],
 completedCaseIds: []
 },
 checklistTraining: {
 sessions: 0,
 activeSince: null,
 lastCompleted: null
 }
 },
 coach: {
 active: false,
 mode: 'daily', // daily | recovery | sprint | exam
 queue: [],
 completed: [],
 confidenceCaptureRequired: true
 },
 coachState: {
 rhythmSchedule: {},
 recentErrors: [],
 confidenceMismatches: [],
 dailyPlanState: {
 date: '',
 items: [],
 completedIds: []
 }
 },
learningAnalytics: {
rolling14d: [],
riskFlags: [],
examWeakDomains: [],
lastReviewDate: null
},
monitorValidation: {
enabled: false,
testRhythms: ['sinus_normal', 'atrial_fibrillation', 'rbbb', 'lbbb', 'vtach_monomorphic'],
lastRun: null,
results: {}
},
diagnostics: {
lastRunAt: null,
bindingIssues: [],
sectionIssues: [],
sourceCoverage: null,
variationMetrics: null,
monitorHealth: null,
monitorVisual: null
},
runtime: {
dirty: false,
saveScheduled: false,
saveTimer: null,
lastSaveAt: 0,
diagnostics: {
quickLastRunAt: null,
fullLastRunAt: null,
fullResultCache: null
}
}
};

 const StateFactory = {
 uiTemplate: null,
 quizQualityTemplate: null,
 libraryViewTemplate: null,
 quizViewTemplate: null,
 monitorTemplate: null,
 userTemplate: null,
 settingsTemplate: null,
learningPathTemplate: null,
coachStateTemplate: null,
learningAnalyticsTemplate: null,
monitorValidationTemplate: null,
diagnosticsTemplate: null,

 clone(value) {
 return JSON.parse(JSON.stringify(value));
 },

 createUi() {
 return this.clone(this.uiTemplate);
 },

 createQuizQuality() {
 return this.clone(this.quizQualityTemplate);
 },

 createLibraryView() {
 return this.clone(this.libraryViewTemplate);
 },

 createQuizView() {
 return this.clone(this.quizViewTemplate);
 },

 createMonitor() {
 return this.clone(this.monitorTemplate);
 },

 createUser() {
 return this.clone(this.userTemplate);
 },

 createSettings() {
 return this.clone(this.settingsTemplate);
 },

 createLearningPath() {
 return this.clone(this.learningPathTemplate);
 },

 createCoachState() {
 return this.clone(this.coachStateTemplate);
 },

createLearningAnalytics() {
return this.clone(this.learningAnalyticsTemplate);
},

createMonitorValidation() {
return this.clone(this.monitorValidationTemplate);
},

createDiagnostics() {
return this.clone(this.diagnosticsTemplate);
}
};

 StateFactory.uiTemplate = StateFactory.clone(AppState.ui);
 StateFactory.quizQualityTemplate = StateFactory.clone(AppState.quizQuality);
 StateFactory.libraryViewTemplate = StateFactory.clone(AppState.libraryView);
 StateFactory.quizViewTemplate = StateFactory.clone(AppState.quizView);
 StateFactory.monitorTemplate = StateFactory.clone(AppState.monitor);
 StateFactory.userTemplate = StateFactory.clone(AppState.user);
 StateFactory.settingsTemplate = StateFactory.clone(AppState.settings);
 StateFactory.learningPathTemplate = StateFactory.clone(AppState.learningPath);
StateFactory.coachStateTemplate = StateFactory.clone(AppState.coachState);
StateFactory.learningAnalyticsTemplate = StateFactory.clone(AppState.learningAnalytics);
StateFactory.monitorValidationTemplate = StateFactory.clone(AppState.monitorValidation);
StateFactory.diagnosticsTemplate = StateFactory.clone(AppState.diagnostics);

 // ==================== LOCAL STORAGE ====================
const Storage = {
KEY: 'ecg_trainer_v2_profiles',
BACKUP_KEY: 'ecg_trainer_v2_profiles_backup',
LEGACY_KEY: 'ecg_trainer_v2_data',
ACTIVE_PROFILE_KEY: 'ecg_trainer_v2_active_profile',
SCHEMA_VERSION: 8,

markDirty() {
if (AppState.runtime) {
AppState.runtime.dirty = true;
}
},

scheduleSave(delayMs = 1500) {
const runtime = AppState.runtime;
if (!runtime) {
this.save('scheduled_fallback');
return;
}
this.markDirty();
if (runtime.saveScheduled) return;
runtime.saveScheduled = true;
runtime.saveTimer = setTimeout(() => {
runtime.saveScheduled = false;
runtime.saveTimer = null;
this.flushSave('scheduled');
}, Math.max(200, Number(delayMs) || 1500));
},

flushSave(reason = 'manual') {
const runtime = AppState.runtime;
if (!runtime || runtime.dirty || reason === 'manual' || reason === 'beforeunload') {
this.save(reason);
}
},

 createDefaultCoachState() {
 return StateFactory.createCoachState();
 },

 createDefaultLearningAnalytics() {
 return StateFactory.createLearningAnalytics();
 },

createDefaultDiagnostics() {
return StateFactory.createDiagnostics();
},

createDefaultMonitorValidation() {
return StateFactory.createMonitorValidation();
},

 createDefaultProfile(name = 'Standaard') {
 return {
 name,
 ui: StateFactory.createUi(),
 quizQuality: StateFactory.createQuizQuality(),
 libraryView: StateFactory.createLibraryView(),
 quizView: StateFactory.createQuizView(),
 monitor: StateFactory.createMonitor(),
 user: StateFactory.createUser(),
 settings: StateFactory.createSettings(),
learningPath: StateFactory.createLearningPath(),
coachState: this.createDefaultCoachState(),
learningAnalytics: this.createDefaultLearningAnalytics(),
monitorValidation: this.createDefaultMonitorValidation(),
diagnostics: this.createDefaultDiagnostics(),
createdAt: new Date().toISOString(),
savedAt: new Date().toISOString()
 };
 },

 createContainer() {
 return {
 version: this.SCHEMA_VERSION,
 profiles: {
 default: this.createDefaultProfile('Standaard')
 },
 updatedAt: new Date().toISOString()
 };
 },

 normalizeContainer(container) {
 let changed = false;
 const normalized = {
 version: Number(container.version) || 1,
 profiles: container.profiles || {},
 updatedAt: container.updatedAt || new Date().toISOString()
 };

 Object.entries(normalized.profiles).forEach(([id, profile]) => {
 const base = this.createDefaultProfile(profile?.name || id);
 normalized.profiles[id] = {
 ...base,
 ...(profile || {}),
 ui: {
 ...base.ui,
 ...(profile?.ui || {})
 },
 quizQuality: {
 ...base.quizQuality,
 ...(profile?.quizQuality || {})
 },
 libraryView: {
 ...base.libraryView,
 ...(profile?.libraryView || {})
 },
 quizView: {
 ...base.quizView,
 ...(profile?.quizView || {})
 },
 monitor: {
 ...base.monitor,
 ...(profile?.monitor || {}),
 ui: {
 ...base.monitor.ui,
 ...(profile?.monitor?.ui || {})
 },
 isRunning: false,
 animationId: null
 },
 coachState: {
 ...base.coachState,
 ...(profile?.coachState || {}),
 dailyPlanState: {
 ...base.coachState.dailyPlanState,
 ...(profile?.coachState?.dailyPlanState || {})
 }
 },
learningAnalytics: {
...base.learningAnalytics,
...(profile?.learningAnalytics || {})
},
monitorValidation: {
...base.monitorValidation,
...(profile?.monitorValidation || {})
},
diagnostics: {
...base.diagnostics,
...(profile?.diagnostics || {})
}
 };
 });

 if (normalized.version < this.SCHEMA_VERSION) {
 normalized.version = this.SCHEMA_VERSION;
 changed = true;
 }

 normalized._changed = changed;
 return normalized;
 },

 getContainer() {
 try {
 const raw = localStorage.getItem(this.KEY);
 if (raw) {
 const parsed = JSON.parse(raw);
 if (parsed && parsed.profiles && Object.keys(parsed.profiles).length > 0) {
 const normalized = this.normalizeContainer(parsed);
 if (normalized._changed) {
 delete normalized._changed;
 this.saveContainer(normalized);
 }
 return normalized;
 }
 }
 } catch (e) {
 console.warn('Profielcontainer kon niet worden gelezen, poging backup:', e);
 try {
 const backupRaw = localStorage.getItem(this.BACKUP_KEY);
 if (backupRaw) {
 const parsedBackup = JSON.parse(backupRaw);
 if (parsedBackup && parsedBackup.profiles && Object.keys(parsedBackup.profiles).length > 0) {
 const normalizedBackup = this.normalizeContainer(parsedBackup);
 if (normalizedBackup._changed) {
 delete normalizedBackup._changed;
 }
 this.saveContainer(normalizedBackup);
 return normalizedBackup;
 }
 }
 } catch (backupErr) {
 console.warn('Backup container kon ook niet worden gelezen:', backupErr);
 }
 }

 const migrated = this.migrateLegacyData();
 this.saveContainer(migrated);
 return migrated;
 },

 saveContainer(container) {
 container.updatedAt = new Date().toISOString();
 const serialized = JSON.stringify(container);
 localStorage.setItem(this.KEY, serialized);
 localStorage.setItem(this.BACKUP_KEY, serialized);
 },

 migrateLegacyData() {
 const container = this.createContainer();

 try {
 const legacyRaw = localStorage.getItem(this.LEGACY_KEY);
 if (!legacyRaw) return container;

 const legacy = JSON.parse(legacyRaw);
 const baseProfile = container.profiles.default;
 if (legacy.user) baseProfile.user = { ...baseProfile.user, ...legacy.user };
 if (legacy.settings) baseProfile.settings = { ...baseProfile.settings, ...legacy.settings };
 if (legacy.learningPath) {
 baseProfile.learningPath = {
 ...baseProfile.learningPath,
 ...legacy.learningPath,
 dailyRoundState: {
 ...baseProfile.learningPath.dailyRoundState,
 ...(legacy.learningPath.dailyRoundState || {})
 },
 checklistTraining: {
 ...baseProfile.learningPath.checklistTraining,
 ...(legacy.learningPath.checklistTraining || {})
 }
 };
 }
 baseProfile.savedAt = legacy.savedAt || new Date().toISOString();
 } catch (e) {
 console.warn('Legacy migratie mislukt, start met lege profielen:', e);
 }

 return container;
 },

 getActiveProfileId(container) {
 const selected = localStorage.getItem(this.ACTIVE_PROFILE_KEY) || 'default';
 if (container.profiles[selected]) return selected;
 const fallback = Object.keys(container.profiles)[0] || 'default';
 localStorage.setItem(this.ACTIVE_PROFILE_KEY, fallback);
 return fallback;
 },

 setActiveProfile(profileId) {
 const container = this.getContainer();
 if (!container.profiles[profileId]) return false;
 localStorage.setItem(this.ACTIVE_PROFILE_KEY, profileId);
 return true;
 },

 listProfiles() {
 const container = this.getContainer();
 return Object.entries(container.profiles).map(([id, profile]) => ({
 id,
 name: profile.name || id
 })).sort((a, b) => a.name.localeCompare(b.name, 'nl-NL'));
 },

 createProfile(name) {
 const safeName = (name || '').trim();
 if (!safeName) throw new Error('Profielnaam is verplicht.');

 const container = this.getContainer();
 const exists = Object.values(container.profiles).some(p => (p.name || '').toLowerCase() === safeName.toLowerCase());
 if (exists) throw new Error('Er bestaat al een profiel met deze naam.');

 const profileId = `profile_${Date.now()}`;
 container.profiles[profileId] = this.createDefaultProfile(safeName);
 this.saveContainer(container);
 localStorage.setItem(this.ACTIVE_PROFILE_KEY, profileId);
 return profileId;
 },

 renameActiveProfile(newName) {
 const safeName = (newName || '').trim();
 if (!safeName) throw new Error('Profielnaam is verplicht.');

 const container = this.getContainer();
 const activeId = this.getActiveProfileId(container);
 if (!container.profiles[activeId]) throw new Error('Actief profiel niet gevonden.');

 const duplicate = Object.entries(container.profiles).some(([id, p]) => id !== activeId && (p.name || '').toLowerCase() === safeName.toLowerCase());
 if (duplicate) throw new Error('Er bestaat al een profiel met deze naam.');

 container.profiles[activeId].name = safeName;
 this.saveContainer(container);
 AppState.profile.name = safeName;
 },

 deleteProfile(profileId) {
 const container = this.getContainer();
 if (!container.profiles[profileId]) throw new Error('Profiel niet gevonden.');
 const allIds = Object.keys(container.profiles);
 if (allIds.length <= 1) throw new Error('Je moet minimaal 1 profiel behouden.');

 delete container.profiles[profileId];
 this.saveContainer(container);

 const currentActive = localStorage.getItem(this.ACTIVE_PROFILE_KEY);
 if (currentActive === profileId) {
 const nextId = Object.keys(container.profiles)[0];
 localStorage.setItem(this.ACTIVE_PROFILE_KEY, nextId);
 }
 },

 resetActiveProfile() {
 const container = this.getContainer();
 const activeId = this.getActiveProfileId(container);
 const profileName = container.profiles[activeId]?.name || 'Standaard';
 container.profiles[activeId] = this.createDefaultProfile(profileName);
 this.saveContainer(container);
 },

 applyProfileToState(profileId, profileData) {
 AppState.profile.id = profileId;
 AppState.profile.name = profileData.name || 'Standaard';

 AppState.ui = { ...StateFactory.createUi(), ...(profileData.ui || {}) };
 AppState.quizQuality = { ...StateFactory.createQuizQuality(), ...(profileData.quizQuality || {}) };
 AppState.libraryView = { ...StateFactory.createLibraryView(), ...(profileData.libraryView || {}) };
 AppState.quizView = { ...StateFactory.createQuizView(), ...(profileData.quizView || {}) };
 const baseMonitor = StateFactory.createMonitor();
 AppState.monitor = {
 ...baseMonitor,
 ...(profileData.monitor || {}),
 ui: {
 ...baseMonitor.ui,
 ...(profileData.monitor?.ui || {})
 },
 isRunning: false,
 freezeFrame: false,
 animationId: null
 };
 AppState.user = { ...StateFactory.createUser(), ...(profileData.user || {}) };
 AppState.settings = { ...StateFactory.createSettings(), ...(profileData.settings || {}) };

 const baseLearningPath = StateFactory.createLearningPath();
 AppState.learningPath = {
 ...baseLearningPath,
 ...(profileData.learningPath || {}),
 dailyRoundState: {
 ...baseLearningPath.dailyRoundState,
 ...(profileData.learningPath?.dailyRoundState || {})
 },
 checklistTraining: {
 ...baseLearningPath.checklistTraining,
 ...(profileData.learningPath?.checklistTraining || {})
 }
 };
 const baseCoach = this.createDefaultCoachState();
 AppState.coachState = {
 ...baseCoach,
 ...(profileData.coachState || {}),
 dailyPlanState: {
 ...baseCoach.dailyPlanState,
 ...(profileData.coachState?.dailyPlanState || {})
 }
 };
AppState.learningAnalytics = {
...this.createDefaultLearningAnalytics(),
...(profileData.learningAnalytics || {})
};
AppState.monitorValidation = {
...this.createDefaultMonitorValidation(),
...(profileData.monitorValidation || {})
};
AppState.diagnostics = {
...this.createDefaultDiagnostics(),
...(profileData.diagnostics || {})
 };
 AppState.coach = {
 ...AppState.coach,
 active: false,
 queue: [],
 completed: []
 };
 },

 save(reason = 'manual') {
 try {
 const container = this.getContainer();
 const activeId = this.getActiveProfileId(container);
 const existing = container.profiles[activeId] || this.createDefaultProfile('Standaard');

 container.profiles[activeId] = {
 ...existing,
 name: AppState.profile.name || existing.name || 'Standaard',
 ui: AppState.ui,
 quizQuality: AppState.quizQuality,
 libraryView: AppState.libraryView,
 quizView: AppState.quizView,
 monitor: {
 ...AppState.monitor,
 ui: {
 ...(StateFactory.createMonitor().ui || {}),
 ...(AppState.monitor?.ui || {})
 },
 isRunning: false,
 animationId: null
 },
 user: AppState.user,
 settings: AppState.settings,
learningPath: AppState.learningPath,
coachState: AppState.coachState,
learningAnalytics: AppState.learningAnalytics,
monitorValidation: AppState.monitorValidation,
diagnostics: AppState.diagnostics,
savedAt: new Date().toISOString()
};

 this.saveContainer(container);
 if (AppState.runtime) {
 AppState.runtime.dirty = false;
 AppState.runtime.lastSaveAt = Date.now();
 if (AppState.runtime.saveTimer) {
 clearTimeout(AppState.runtime.saveTimer);
 AppState.runtime.saveTimer = null;
 }
 AppState.runtime.saveScheduled = false;
 }
 } catch (e) {
 console.error('Opslaan mislukt:', e);
 }
 },

 load() {
 try {
 const container = this.getContainer();
 const activeId = this.getActiveProfileId(container);
 const profileData = container.profiles[activeId] || this.createDefaultProfile('Standaard');

 this.applyProfileToState(activeId, profileData);

 // Check streak continuity per actief profiel
 if (profileData.savedAt) {
 const lastDate = new Date(profileData.savedAt).toDateString();
 const today = new Date().toDateString();
 const yesterday = new Date(Date.now() - 86400000).toDateString();

 if (lastDate !== today && lastDate !== yesterday) {
 AppState.user.streak = 0;
 }
 }
 } catch (e) {
 console.error('Laden mislukt:', e);
 }
 },

 clear() {
 this.resetActiveProfile();
 location.reload();
 }
 };

 // ==================== ECG DATABASE - COMPLETE ====================
 const ECGDatabase = {
 
// ========== CATEGORIEËN ==========
categories: {
normal: {
name: 'Normaal Sinusritme',
icon: '&#x1F49A;',
color: 'green',
description: 'Normale hartritmes'
},
bradycardia: {
name: 'Bradycardieën',
icon: '&#x1F422;',
color: 'blue',
description: 'Trage ritmes (< 60 bpm)'
},
tachycardia: {
name: 'Tachycardieën',
icon: '&#x26A1;',
color: 'yellow',
description: 'Snelle ritmes (> 100 bpm)'
},
atrial: {
name: 'Atriale Aritmieën',
icon: '&#x1F9E0;',
color: 'purple',
description: 'Stoornissen vanuit de atria'
},
ventricular: {
name: 'Ventriculaire Aritmieën',
icon: '&#x1F494;',
color: 'red',
description: 'Stoornissen vanuit ventrikels'
},
blocks: {
name: 'Geleidingsstoornissen',
icon: '&#x1F517;',
color: 'orange',
description: 'AV-blokken en bundeltak blokken'
},
ischemia: {
name: 'Ischemie & Infarcten',
icon: '&#x2764;&#xFE0F;',
color: 'red',
description: 'Coronaire problematiek'
},
pacemaker: {
name: 'Pacemaker Ritmes',
icon: '&#x1F50B;',
color: 'cyan',
description: 'Gepacede ritmes'
},
other: {
name: 'Overige',
icon: '&#x1F4CC;',
color: 'gray',
description: 'Overige ECG afwijkingen'
}
},

 // ========== COMPLETE RITME DATABASE ==========
 rhythms: {
 
 // ==================== NORMALE RITMES ====================
 sinus_normal: {
 id: 'sinus_normal',
 name: 'Normaal Sinusritme',
 shortName: 'NSR',
 category: 'normal',
 difficulty: 'easy',
 urgency: 'none',
 description: 'Normaal ritme met oorsprong in de sinusknoop',
 characteristics: {
 rate: { min: 60, max: 100, typical: 72 },
 rhythm: 'Regelmatig',
 pWave: 'Aanwezig, positief in II, negatief in aVR',
 prInterval: { min: 120, max: 200, unit: 'ms' },
 qrsComplex: { min: 60, max: 100, unit: 'ms' },
 qtInterval: 'Normaal gecorrigeerd'
 },
 ecgFeatures: [
 'P-golf voor elk QRS-complex',
 'Constante PR-interval',
 'Regelmatige R-R intervallen',
 'Smalle QRS-complexen'
 ],
 clinicalSignificance: 'Normale elektrische hartactiviteit',
 commonCauses: ['Gezond hart', 'Goede fysieke conditie'],
 treatment: 'Geen behandeling nodig',
 waveformParams: {
 pHeight: 0.15,
 pWidth: 0.08,
 qDepth: 0.05,
 rHeight: 1.0,
 sDepth: 0.15,
 tHeight: 0.25,
 tWidth: 0.16,
 prInterval: 0.16,
 qrsWidth: 0.08
 },
 quizHints: [
 'Let op de regelmatige P-golven',
 'PR-interval is constant',
 'Frequentie tussen 60-100/min'
 ]
 },

 sinus_bradycardia: {
 id: 'sinus_bradycardia',
 name: 'Sinusbradycardie',
 shortName: 'SB',
 category: 'bradycardia',
 difficulty: 'easy',
 urgency: 'low',
 description: 'Sinusritme met frequentie < 60/min',
 characteristics: {
 rate: { min: 30, max: 59, typical: 50 },
 rhythm: 'Regelmatig',
 pWave: 'Normaal aanwezig',
 prInterval: { min: 120, max: 200, unit: 'ms' },
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Normale P-golven met normaal QRS',
 'Langere R-R intervallen',
 'Frequentie < 60/min',
 'Normale geleiding'
 ],
 clinicalSignificance: 'Kan fysiologisch zijn bij sporters of pathologisch',
 commonCauses: [
 'Verhoogde vagale tonus',
 'Atleten',
 'Bètablokkers',
 'Hypothyreoïdie',
 'Sick sinus syndroom',
 'Hypothermie'
 ],
 treatment: 'Atropine bij symptomen, pacemaker bij ernstige gevallen',
 waveformParams: {
 pHeight: 0.15,
 pWidth: 0.08,
 rHeight: 1.0,
 tHeight: 0.25,
 prInterval: 0.16,
 qrsWidth: 0.08
 },
 quizHints: [
 'Normaal sinusritme maar traag',
 'P-golven zijn normaal',
 'Frequentie < 60/min'
 ]
 },

 sinus_tachycardia: {
 id: 'sinus_tachycardia',
 name: 'Sinustachycardie',
 shortName: 'ST',
 category: 'tachycardia',
 difficulty: 'easy',
 urgency: 'low',
 description: 'Sinusritme met frequentie > 100/min',
 characteristics: {
 rate: { min: 101, max: 180, typical: 120 },
 rhythm: 'Regelmatig',
 pWave: 'Normaal aanwezig (kan moeilijk te onderscheiden zijn)',
 prInterval: { min: 120, max: 200, unit: 'ms' },
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Normale P-golven (soms verborgen in T-golf)',
 'Kortere R-R intervallen',
 'Frequentie > 100/min',
 'Normale geleiding'
 ],
 clinicalSignificance: 'Meestal secundair aan onderliggende oorzaak',
 commonCauses: [
 'Koorts',
 'Pijn',
 'Angst/stress',
 'Hypovolemie',
 'Anemie',
 'Hyperthyreoïdie',
 'Medicatie (salbutamol)',
 'Sepsis'
 ],
 treatment: 'Behandel onderliggende oorzaak, bètablokkers indien geïndiceerd',
 waveformParams: {
 pHeight: 0.12,
 pWidth: 0.06,
 rHeight: 0.95,
 tHeight: 0.2,
 prInterval: 0.12,
 qrsWidth: 0.08
 },
 quizHints: [
 'Normaal sinusritme maar snel',
 'P-golven aanwezig',
 'Frequentie > 100/min'
 ]
 },

 sinus_arrhythmia: {
 id: 'sinus_arrhythmia',
 name: 'Sinusaritmie',
 shortName: 'SA',
 category: 'normal',
 difficulty: 'easy',
 urgency: 'none',
 description: 'Variatie in sinusritme, vaak gerelateerd aan ademhaling',
 characteristics: {
 rate: { min: 50, max: 100, typical: 70 },
 rhythm: 'Onregelmatig (cyclisch met ademhaling)',
 pWave: 'Normaal',
 prInterval: { min: 120, max: 200, unit: 'ms' },
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'P-golven normaal vormgegeven',
 'Variërende R-R intervallen',
 'PR-interval constant',
 'Variatie > 0.16 sec tussen langste en kortste R-R'
 ],
 clinicalSignificance: 'Fysiologisch, vooral bij jongeren',
 commonCauses: ['Respiratoire sinusaritmie', 'Normale variant'],
 treatment: 'Geen behandeling nodig',
 waveformParams: {
 pHeight: 0.15,
 pWidth: 0.08,
 rHeight: 1.0,
 tHeight: 0.25,
 prInterval: 0.16,
 qrsWidth: 0.08,
 variability: 0.2
 },
 quizHints: [
 'Onregelmatig maar met normale P-golven',
 'Variatie met ademhaling',
 'PR-interval blijft constant'
 ]
 },

 // ==================== ATRIALE ARITMIEËN ====================
 atrial_fibrillation: {
 id: 'atrial_fibrillation',
 name: 'Atriumfibrilleren',
 shortName: 'AF',
 category: 'atrial',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'Chaotische elektrische activiteit in de atria',
 characteristics: {
 rate: { min: 60, max: 180, typical: 110 },
 rhythm: 'Onregelmatig onregelmatig',
 pWave: 'Afwezig, fibrillatiegolven',
 prInterval: 'Niet meetbaar',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Geen duidelijke P-golven',
 'Fibrillatiegolven (f-golven)',
 'Onregelmatige R-R intervallen',
 'Normaal QRS (tenzij aberrante geleiding)'
 ],
 clinicalSignificance: 'Verhoogd risico op CVA, hartfalen',
 commonCauses: [
 'Hypertensie',
 'Hartfalen',
 'Kleplijden',
 'Hyperthyreoïdie',
 'Alcohol',
 'Longembolie',
 'Post-cardiochirurgie'
 ],
 treatment: 'Rate control bij stabiele AF: meestal bètablokker of non-DHP calciumantagonist (afhankelijk van LV-functie/comorbiditeit); digoxine vooral in geselecteerde situaties (bijv. hartfalen/sedentair). Daarnaast rhythm control en trombo-embolierisicobeoordeling (CHA2DS2-VASc).',
 medications: {
 rateControl: ['Metoprolol', 'Diltiazem', 'Verapamil', 'Digoxine'],
 rhythmControl: ['Flecaïnide', 'Amiodaron', 'Sotalol'],
 anticoagulation: ['DOAC', 'VKA']
 },
 waveformParams: {
 pHeight: 0,
 fibrillation: true,
 fibrillationAmplitude: 0.05,
 rHeight: 1.0,
 tHeight: 0.25,
 qrsWidth: 0.08,
 rrVariability: 0.4
 },
 quizHints: [
 'Geen P-golven zichtbaar',
 'Onregelmatige R-R intervallen',
 'Fibrillatiegolven in baseline'
 ]
 },

 atrial_flutter: {
 id: 'atrial_flutter',
 name: 'Atriumflutter',
 shortName: 'AFL',
 category: 'atrial',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'Georganiseerde re-entry in het atrium',
 characteristics: {
 rate: { min: 60, max: 150, typical: 150 },
 rhythm: 'Regelmatig of regelmatig onregelmatig',
 pWave: 'Zaagtand fluttergolven (F-golven, 250-350/min)',
 prInterval: 'Niet conventioneel meetbaar',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Zaagtand patroon (beste in II, III, aVF)',
 'Fluttergolven ~300/min',
 'Vaste of variabele AV-geleiding (2:1, 3:1, 4:1)',
 'Bij 2:1 geleiding: ventrikelfrequentie ~150/min'
 ],
 clinicalSignificance: 'Vaak instabiel, kan overgaan in AF',
 commonCauses: [
 'Structureel hartlijden',
 'Post-cardiochirurgie',
 'COPD',
 'Pulmonale hypertensie'
 ],
 treatment: 'Rate control, ablatie effectiever dan bij AF',
 waveformParams: {
 flutterWaves: true,
 flutterRate: 300,
 avConduction: 2,
 rHeight: 1.0,
 tHeight: 0.2,
 qrsWidth: 0.08
 },
 quizHints: [
 'Zaagtand patroon',
 'Flutter frequentie ~300/min',
 'Vaak 2:1 geleiding -> HF ~150/min'
 ]
 },

 svt: {
 id: 'svt',
 name: 'Supraventriculaire Tachycardie',
 shortName: 'SVT',
 category: 'tachycardia',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'Snelle tachycardie met oorsprong boven de bundel van His',
 characteristics: {
 rate: { min: 150, max: 250, typical: 180 },
 rhythm: 'Regelmatig',
 pWave: 'Vaak niet zichtbaar of retrograad',
 prInterval: 'Kort of niet meetbaar',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Regelmatig smal complex tachycardie',
 'Abrupt begin en einde',
 'P-golven vaak verborgen in QRS of T',
 'Frequentie meestal 150-250/min'
 ],
 clinicalSignificance: 'Acuut symptomatisch, meestal niet levensbedreigend',
 commonCauses: [
 'AVNRT (meest voorkomend)',
 'AVRT (accessoire bundel)',
 'Atriale tachycardie'
 ],
 treatment: 'Vagale manoeuvres, adenosine bij regelmatige smalcomplex tachycardie, cardioversie indien instabiel',
 medications: {
 acute: ['Adenosine 6mg -> 12mg -> 18mg IV bolus (alleen bij regelmatig ritme, volgens ERC/RCUK-profiel)', 'Verapamil', 'Bètablokker'],
 chronic: ['Bètablokker', 'Calciumantagonist', 'Ablatie']
 },
 waveformParams: {
 pHeight: 0,
 rHeight: 0.9,
 tHeight: 0.15,
 prInterval: 0,
 qrsWidth: 0.08
 },
 quizHints: [
 'Regelmatig smal complex',
 'Frequentie 150-250/min',
 'P-golven vaak niet zichtbaar'
 ]
 },

 atrial_tachycardia: {
 id: 'atrial_tachycardia',
 name: 'Atriale Tachycardie',
 shortName: 'AT',
 category: 'tachycardia',
 difficulty: 'medium',
 urgency: 'low',
 description: 'Tachycardie vanuit een ectopische focus in het atrium',
 characteristics: {
 rate: { min: 100, max: 250, typical: 150 },
 rhythm: 'Regelmatig',
 pWave: 'Aanwezig maar afwijkende morfologie',
 prInterval: 'Variabel',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'P-golf morfologie verschilt van sinus P',
 'PR-interval kan verkort of verlengd zijn',
 'Isoelektrische lijn tussen P-golven',
 'Warm-up en cool-down fenomeen mogelijk'
 ],
 clinicalSignificance: 'Kan leiden tot tachycardiomyopathie bij chronisch',
 commonCauses: ['Structureel hartlijden', 'Digoxine toxiciteit', 'COPD'],
 treatment: 'Bètablokker, calciumantagonist, ablatie',
 waveformParams: {
 pHeight: 0.1,
 pWidth: 0.06,
 pMorphology: 'abnormal',
 rHeight: 0.9,
 tHeight: 0.2,
 qrsWidth: 0.08
 },
 quizHints: [
 'P-golven zichtbaar maar afwijkend',
 'Isoelektrische lijn tussen P-golven',
 'Verschillend van flutter (geen zaagtand)'
 ]
 },

 pac: {
 id: 'pac',
 name: 'Premature Atriale Contractie',
 shortName: 'PAC',
 category: 'atrial',
 difficulty: 'easy',
 urgency: 'none',
 description: 'Vroegtijdige slag vanuit het atrium',
 characteristics: {
 rate: { min: 60, max: 100, typical: 75 },
 rhythm: 'Onregelmatig door extra slagen',
 pWave: 'Premature P met afwijkende morfologie',
 prInterval: 'Kan verschillen van normaal',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Vroegtijdige P-golf',
 'P-golf morfologie anders dan sinus P',
 'QRS meestal normaal',
 'Incomplete compensatoire pauze'
 ],
 clinicalSignificance: 'Meestal benigne, kan voorloper zijn van AF',
 commonCauses: ['Cafeïne', 'Alcohol', 'Stress', 'Hypoxie'],
 treatment: 'Meestal geen, trigger vermijden',
 waveformParams: {
 pHeight: 0.15,
 rHeight: 1.0,
 tHeight: 0.25,
 prematurePHeight: 0.1,
 prematurePMorphology: 'different'
 },
 quizHints: [
 'Vroegtijdige slag met P-golf',
 'P-golf morfologie afwijkend',
 'Incomplete compensatoire pauze'
 ]
 },

 wandering_pacemaker: {
 id: 'wandering_pacemaker',
 name: 'Wandelende Pacemaker',
 shortName: 'WAP',
 category: 'atrial',
 difficulty: 'hard',
 urgency: 'none',
 description: 'Wisselende pacemaker locatie in atrium/AV-knoop',
 characteristics: {
 rate: { min: 50, max: 100, typical: 70 },
 rhythm: 'Licht onregelmatig',
 pWave: 'Variërende morfologie (=3 verschillende vormen)',
 prInterval: 'Variabel',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Minimaal 3 verschillende P-golf morfologieën',
 'Variërende PR-intervallen',
 'Variërende R-R intervallen',
 'Frequentie meestal < 100/min'
 ],
 clinicalSignificance: 'Kan normaal zijn, of wijzen op atriale afwijkingen',
 commonCauses: ['Verhoogde vagale tonus', 'Digoxine', 'Hartziekte'],
 treatment: 'Meestal geen behandeling nodig',
 waveformParams: {
 variablePMorphology: true,
 pMorphologies: 3,
 variablePR: true
 },
 quizHints: [
 '=3 verschillende P-golf vormen',
 'Wisselende PR-intervallen',
 'Rustige frequentie'
 ]
 },

 mat: {
 id: 'mat',
 name: 'Multifocale Atriale Tachycardie',
 shortName: 'MAT',
 category: 'tachycardia',
 difficulty: 'hard',
 urgency: 'low',
 description: 'Snelle wandelende atriale pacemaker (>100/min)',
 characteristics: {
 rate: { min: 100, max: 180, typical: 120 },
 rhythm: 'Onregelmatig',
 pWave: '=3 verschillende morfologieën',
 prInterval: 'Variabel',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Minimaal 3 verschillende P-golf morfologieën',
 'Variërende PR-intervallen',
 'Variërende P-P intervallen',
 'Frequentie > 100/min'
 ],
 clinicalSignificance: 'Geassocieerd met ernstige pulmonale ziekte',
 commonCauses: ['COPD (meest voorkomend)', 'Hypoxie', 'Elektrolytstoornissen'],
 treatment: 'Onderliggende oorzaak behandelen, magnesium, calciumantagonist',
 waveformParams: {
 variablePMorphology: true,
 pMorphologies: 3,
 variablePR: true,
 variableRR: true
 },
 quizHints: [
 'Lijkt op AF maar heeft P-golven',
 '=3 P-golf morfologieën',
 'Vaak bij COPD patiënten'
 ]
 },

 // ==================== VENTRICULAIRE ARITMIEËN ====================
 pvc: {
 id: 'pvc',
 name: 'Premature Ventriculaire Contractie',
 shortName: 'PVC',
 category: 'ventricular',
 difficulty: 'easy',
 urgency: 'low',
 description: 'Vroegtijdige slag vanuit het ventrikel',
 characteristics: {
 rate: { min: 60, max: 100, typical: 75 },
 rhythm: 'Onregelmatig door extra slagen',
 pWave: 'Afwezig voor PVC',
 prInterval: 'N.v.t. voor PVC',
 qrsComplex: { duration: '>120ms', morphology: 'breed en bizar' }
 },
 ecgFeatures: [
 'Breed QRS-complex (>120ms)',
 'Geen voorafgaande P-golf',
 'Compensatoire pauze (volledig)',
 'T-golf tegengesteld aan QRS'
 ],
 clinicalSignificance: 'Meestal benigne, let op bij frequente/polymorfe PVCs',
 commonCauses: [
 'Cafeïne',
 'Hypokaliëmie',
 'Hypomagnesiëmie',
 'Myocardischemie',
 'Hartfalen',
 'Stress'
 ],
 treatment: 'Trigger vermijden, bètablokker bij klachten',
 patterns: {
 unifocal: 'Alle PVCs zelfde morfologie',
 multifocal: 'PVCs met verschillende morfologie',
 bigeminy: 'Elke 2e slag is PVC',
 trigeminy: 'Elke 3e slag is PVC',
 couplet: 'Twee PVCs achter elkaar',
 triplet: 'Drie PVCs achter elkaar (= NSVT)'
 },
 waveformParams: {
 pvcWidth: 0.14,
 pvcHeight: 1.3,
 pvcTInverted: true,
 compensatoryPause: true
 },
 quizHints: [
 'Breed QRS zonder P-golf',
 'Volledig compensatoire pauze',
 'T-golf tegengesteld aan QRS'
 ]
 },

 pvc_bigeminy: {
 id: 'pvc_bigeminy',
 name: 'PVC Bigeminee',
 shortName: 'PVC Bige',
 category: 'ventricular',
 difficulty: 'medium',
 urgency: 'low',
 description: 'Patroon waarbij elke normale slag gevolgd wordt door een PVC',
 characteristics: {
 rate: { min: 50, max: 80, typical: 70 },
 rhythm: 'Regelmatig onregelmatig (patroon)',
 pWave: 'Aanwezig voor normale slagen',
 qrsComplex: 'Afwisselend smal en breed'
 },
 ecgFeatures: [
 'Normale slag - PVC - normale slag - PVC patroon',
 'Effectieve hartfrequentie kan laag zijn',
 'Brede QRS-complexen afwisselend met smalle'
 ],
 clinicalSignificance: 'Kan symptomen geven door verlaagde output',
 commonCauses: ['Digoxine toxiciteit', 'Elektrolytstoornis', 'Structureel hartlijden'],
 treatment: 'Onderliggende oorzaak behandelen, bètablokker',
 waveformParams: {
 pattern: 'bigeminy',
 pvcWidth: 0.14,
 pvcHeight: 1.3
 },
 quizHints: [
 'Elke normale slag -> PVC',
 'Regelmatig patroon',
 'Effectieve HF is lager'
 ]
 },

 vtach_monomorphic: {
 id: 'vtach_monomorphic',
 name: 'Ventriculaire Tachycardie (Monomorf)',
 shortName: 'VT',
 category: 'ventricular',
 difficulty: 'medium',
 urgency: 'high',
 description: '=3 opeenvolgende ventriculaire slagen met uniforme morfologie',
 characteristics: {
 rate: { min: 100, max: 250, typical: 180 },
 rhythm: 'Regelmatig',
 pWave: 'Vaak AV-dissociatie',
 qrsComplex: { duration: '>120ms', morphology: 'breed, uniform' }
 },
 ecgFeatures: [
 'Breed QRS-complex (>120ms)',
 'Regelmatige R-R intervallen',
 'AV-dissociatie (capture beats, fusion beats)',
 'Extreme as (northwest axis)',
 'Uniforme QRS morfologie'
 ],
 clinicalSignificance: 'LEVENSBEDREIGENDE ARITMIE',
 commonCauses: [
 'Myocardinfarct (acuut/oud)',
 'Cardiomyopathie',
 'Elektrolytstoornissen',
 'Lange QT syndroom',
 'Aritmogene RV cardiomyopathie'
 ],
 treatment: 'Stabiel en regelmatig monomorf: overweeg anti-aritmicum; bij instabiliteit of diagnostische twijfel: gesynchroniseerde cardioversie volgens lokaal protocol',
 medications: {
 stable: ['Amiodaron 150mg IV over 10 min', 'Lidocaïne 1-1.5mg/kg IV'],
 unstable: ['Gesynchroniseerde cardioversie met fabrikantadviesenergie, escaleer indien nodig', 'Amiodaron conform protocol']
 },
 waveformParams: {
 qrsWidth: 0.16,
 qrsHeight: 1.4,
 uniform: true,
 avDissociation: true
 },
 quizHints: [
 'Breed complex, regelmatig, snel',
 'Uniforme QRS morfologie',
 'AV-dissociatie = diagnostisch'
 ]
 },

 vtach_polymorphic: {
 id: 'vtach_polymorphic',
 name: 'Polymorfe VT / Torsades de Pointes',
 shortName: 'TdP',
 category: 'ventricular',
 difficulty: 'hard',
 urgency: 'critical',
 description: 'VT met wisselende QRS-morfologie, draaiend om de basislijn',
 characteristics: {
 rate: { min: 150, max: 300, typical: 200 },
 rhythm: 'Onregelmatig',
 pWave: 'Niet zichtbaar',
 qrsComplex: 'Wisselende morfologie en amplitude'
 },
 ecgFeatures: [
 'QRS-complexen draaien om basislijn',
 '"Twisting of the points"',
 'Geassocieerd met verlengd QT-interval',
 'Kan degenereren naar VF'
 ],
 clinicalSignificance: 'ACUUT LEVENSBEDREIGENDE ARITMIE',
 commonCauses: [
 'Verlengd QT (medicatie)',
 'Hypokaliëmie',
 'Hypomagnesiëmie',
 'Bradycardie',
 'Congenitaal lang QT'
 ],
 treatment: 'Magnesium 2g IV, stop QT-verlengende medicatie, pacing bij bradycardie',
 medications: {
 immediate: ['Magnesiumsulfaat 2g IV push', 'Defibrillatie bij VF'],
 supportive: ['Correctie elektrolyten', 'Isoproterenol of pacing bij bradycardie']
 },
 waveformParams: {
 polymorphic: true,
 twisting: true,
 amplitudeVariation: true
 },
 quizHints: [
 'QRS draait om basislijn',
 'Vaak bij lang QT',
 'Magnesium = eerste behandeling'
 ]
 },

 vfib: {
 id: 'vfib',
 name: 'Ventrikelfibrilleren',
 shortName: 'VF',
 category: 'ventricular',
 difficulty: 'easy',
 urgency: 'critical',
 description: 'Chaotische elektrische activiteit, geen effectieve output',
 characteristics: {
 rate: { min: 150, max: 500, typical: 300 },
 rhythm: 'Chaotisch',
 pWave: 'Niet aanwezig',
 qrsComplex: 'Niet herkenbaar'
 },
 ecgFeatures: [
 'Grillig, onregelmatig patroon',
 'Geen herkenbare QRS-complexen',
 'Geen P-golven',
 'Variërende amplitude (coarse vs fine VF)',
 'GEEN POLS'
 ],
 clinicalSignificance: 'HARTSTILSTAND - ONMIDDELLIJK HANDELEN',
 commonCauses: [
 'Myocardinfarct',
 'Cardiomyopathie',
 'Elektrolytstoornissen',
 'Hypothermie',
 'Verdrinking',
 'Degeneratie vanuit VT'
 ],
 treatment: 'CPR + defibrillatie met fabrikant-adviesenergie (bij bifasisch vaak 120-200J), escaleren indien nodig',
 waveformParams: {
 chaotic: true,
 noQRS: true,
 amplitudeRange: { min: 0.1, max: 0.6 }
 },
 quizHints: [
 'Chaotisch patroon',
 'Geen herkenbare complexen',
 'DEFIBRILLATIE nodig'
 ]
 },

 idioventricular: {
 id: 'idioventricular',
 name: 'Idioventriculair Ritme',
 shortName: 'IVR',
 category: 'ventricular',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'Escape ritme vanuit ventrikel (20-40/min)',
 characteristics: {
 rate: { min: 20, max: 40, typical: 35 },
 rhythm: 'Regelmatig',
 pWave: 'Kan aanwezig zijn (AV-dissociatie)',
 qrsComplex: { duration: '>120ms' }
 },
 ecgFeatures: [
 'Breed QRS-complex',
 'Traag (20-40/min)',
 'Regelmatig',
 'Kan laatste redmiddel zijn bij totaal AV-blok'
 ],
 clinicalSignificance: 'Teken van ernstige geleidingsstoornis',
 commonCauses: ['Compleet hartblok', 'Ernstige sinusbradycardie', 'Medicatie-toxiciteit'],
 treatment: 'Atropine, pacing, behandel oorzaak',
 waveformParams: {
 qrsWidth: 0.16,
 slow: true
 },
 quizHints: [
 'Breed complex, zeer traag',
 'Escape ritme',
 '20-40/min'
 ]
 },

 aivr: {
 id: 'aivr',
 name: 'Accelerated Idioventriculair Ritme',
 shortName: 'AIVR',
 category: 'ventricular',
 difficulty: 'medium',
 urgency: 'low',
 description: 'Versneld ventriculair escape ritme (40-100/min)',
 characteristics: {
 rate: { min: 40, max: 100, typical: 70 },
 rhythm: 'Regelmatig',
 pWave: 'AV-dissociatie of retrograad',
 qrsComplex: { duration: '>120ms' }
 },
 ecgFeatures: [
 'Breed QRS-complex',
 'Frequentie 40-100/min',
 'Regelmatig',
 '"Slow VT" maar benigne'
 ],
 clinicalSignificance: 'Vaak reperfusie-aritmie na MI, meestal benigne',
 commonCauses: ['Reperfusie na STEMI', 'Digoxine toxiciteit', 'Cardiomyopathie'],
 treatment: 'Meestal geen behandeling, monitoring',
 waveformParams: {
 qrsWidth: 0.14,
 moderate: true
 },
 quizHints: [
 'Breed complex, 40-100/min',
 'Vaak na reperfusie',
 'Benigne, geen behandeling'
 ]
 },

 // ==================== AV-BLOKKEN ====================
 avblock_1st: {
 id: 'avblock_1st',
 name: 'Eerstegraads AV-blok',
 shortName: 'AV-I',
 category: 'blocks',
 difficulty: 'easy',
 urgency: 'none',
 description: 'Vertraagde geleiding door AV-knoop (PR > 200ms)',
 characteristics: {
 rate: { min: 50, max: 100, typical: 70 },
 rhythm: 'Regelmatig',
 pWave: 'Normaal',
 prInterval: { min: 201, max: 400, unit: 'ms', abnormal: true },
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'PR-interval > 200ms (> 1 groot hokje)',
 'Elke P-golf gevolgd door QRS',
 'Constante PR-interval',
 '1:1 geleiding behouden'
 ],
 clinicalSignificance: 'Meestal benigne, kan progressief zijn',
 commonCauses: [
 'Verhoogde vagale tonus',
 'Medicatie (bètablokkers, digoxine)',
 'Myocarditis',
 'Ischemie',
 'Veroudering'
 ],
 treatment: 'Meestal geen, monitoring, evalueer medicatie',
 waveformParams: {
 prInterval: 0.28,
 pHeight: 0.15,
 rHeight: 1.0
 },
 quizHints: [
 'PR > 200ms maar constant',
 '1:1 geleiding intact',
 'Verlenging is consistent'
 ]
 },

 avblock_2nd_type1: {
 id: 'avblock_2nd_type1',
 name: 'Tweedegraads AV-blok Type I (Wenckebach)',
 shortName: 'AV-II-I',
 category: 'blocks',
 difficulty: 'medium',
 urgency: 'low',
 description: 'Progressieve PR-verlenging tot een P-golf niet geleidt',
 characteristics: {
 rate: { min: 40, max: 80, typical: 60 },
 rhythm: 'Groepsgewijs onregelmatig',
 pWave: 'Meer P-golven dan QRS-complexen',
 prInterval: 'Progressief verlengend',
 qrsComplex: { min: 60, max: 100, unit: 'ms' }
 },
 ecgFeatures: [
 'Progressieve PR-verlenging',
 'Uitgevallen QRS (dropped beat)',
 'Kortste PR direct na pauze',
 'Groepsgewijs patroon'
 ],
 clinicalSignificance: 'Meestal benigne, zelden progressie naar hogergradig blok',
 commonCauses: [
 'Medicatie (digoxine, bètablokkers)',
 'Inferieur MI',
 'Myocarditis',
 'Verhoogde vagale tonus'
 ],
 treatment: 'Meestal observatie, stop uitlokkende medicatie',
 waveformParams: {
 wenckebach: true,
 initialPR: 0.18,
 prIncrement: 0.04,
 cycleLength: 4
 },
 quizHints: [
 'PR wordt steeds langer',
 'Dan dropped beat',
 'Patroon herhaalt zich'
 ]
 },

 avblock_2nd_type2: {
 id: 'avblock_2nd_type2',
 name: 'Tweedegraads AV-blok Type II (Mobitz II)',
 shortName: 'AV-II-II',
 category: 'blocks',
 difficulty: 'hard',
 urgency: 'high',
 description: 'Intermitterende niet-geleiding zonder PR-verlenging',
 characteristics: {
 rate: { min: 30, max: 70, typical: 50 },
 rhythm: 'Regelmatig met dropped beats',
 pWave: 'Meer P-golven dan QRS-complexen',
 prInterval: 'Constant voor geleide slagen',
 qrsComplex: 'Vaak breed (bundeltakblok)'
 },
 ecgFeatures: [
 'Constant PR-interval voor geleide slagen',
 'Plotselinge dropped beats',
 'Vaak geassocieerd met breed QRS',
 'Kan 2:1, 3:1 of onregelmatig zijn'
 ],
 clinicalSignificance: 'ERNSTIG - Hoog risico op compleet blok',
 commonCauses: [
 'Anterieur MI',
 'Fibrose geleidingssysteem',
 'Cardiomyopathie',
 'Na hartchirurgie'
 ],
 treatment: 'Pacemakerindicatie, transcutane pacing als bridge',
 waveformParams: {
 mobitzII: true,
 constantPR: 0.16,
 qrsWidth: 0.14,
 conductionRatio: '3:2'
 },
 quizHints: [
 'PR constant, dan ineens dropped beat',
 'Geen progressieve verlenging',
 'Vaak breed QRS = infranodaal'
 ]
 },

 avblock_3rd: {
 id: 'avblock_3rd',
 name: 'Derdegraads AV-blok (Compleet Hartblok)',
 shortName: 'CHB',
 category: 'blocks',
 difficulty: 'medium',
 urgency: 'critical',
 description: 'Totale dissociatie tussen atria en ventrikels',
 characteristics: {
 rate: { min: 20, max: 60, typical: 40 },
 rhythm: 'Regelmatig P, regelmatig QRS, maar onafhankelijk',
 pWave: 'Aanwezig, marcheren door QRS',
 prInterval: 'Variabel (geen relatie)',
 qrsComplex: 'Smal of breed afhankelijk van escape'
 },
 ecgFeatures: [
 'Volledig onafhankelijke P en QRS',
 'P-frequentie > QRS-frequentie',
 'Escape ritme (junctioneel of ventriculair)',
 'P-golven "marcheren door" QRS'
 ],
 clinicalSignificance: 'LEVENSBEDREIGENDE ARITMIE - URGENT',
 commonCauses: [
 'Inferieur MI',
 'Anterieur MI (ernstiger)',
 'Medicatie toxiciteit',
 'Lyme ziekte',
 'Congenitaal',
 'Na hartchirurgie'
 ],
 treatment: 'Pacemaker, overbrugging met atropine/transcutane pacing',
 medications: {
 bridge: ['Atropine 0,5mg IV herhaald elke 3-5 min (max 3mg)', 'Transcutane pacing', 'Isoproterenol'],
 definitive: ['Transveneuze pacing', 'Permanente pacemaker']
 },
 waveformParams: {
 completeDissociation: true,
 pRate: 80,
 escapeRate: 35,
 escapeWidth: 0.14
 },
 quizHints: [
 'P en QRS volledig los van elkaar',
 'Regelmatige P-golven, regelmatige QRS',
 'Maar zonder relatie = AV-dissociatie'
 ]
 },

 // ==================== BUNDELTAK BLOKKEN ====================
 rbbb: {
 id: 'rbbb',
 name: 'Rechterbundeltakblok',
 shortName: 'RBBB',
 category: 'blocks',
 difficulty: 'medium',
 urgency: 'low',
 description: 'Vertraagde geleiding door rechter bundeltak',
 characteristics: {
 rate: { min: 60, max: 100, typical: 75 },
 rhythm: 'Regelmatig',
 pWave: 'Normaal',
 prInterval: { min: 120, max: 200, unit: 'ms' },
 qrsComplex: { duration: '>120ms' }
 },
 ecgFeatures: [
 'QRS = 120ms',
 'rSR\' patroon V1-V2 ("M-patroon", "konijnenoren")',
 'Brede S-golf in I, aVL, V5-V6',
 'ST-depressie en T-inversie V1-V3 (secundair)'
 ],
 clinicalSignificance: 'Kan normaal zijn, of wijzen op rechtszijdige pathologie',
 commonCauses: [
 'Normaal variant',
 'Longembolie',
 'Pulmonale hypertensie',
 'Cor pulmonale',
 'ASD'
 ],
 treatment: 'Geen specifieke behandeling, onderliggende oorzaak',
 waveformParams: {
 rsrPattern: true,
 qrsWidth: 0.14,
 v1Morphology: 'rsR',
 wideSinV6: true
 },
 quizHints: [
 'Breed QRS met "M" in V1',
 'William Morrow: WiLLiaM = LBBB, MaRRoW = RBBB',
 'Brede S in I en V6'
 ]
 },

 lbbb: {
 id: 'lbbb',
 name: 'Linkerbundeltakblok',
 shortName: 'LBBB',
 category: 'blocks',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'Vertraagde geleiding door linker bundeltak',
 characteristics: {
 rate: { min: 60, max: 100, typical: 75 },
 rhythm: 'Regelmatig',
 pWave: 'Normaal',
 prInterval: { min: 120, max: 200, unit: 'ms' },
 qrsComplex: { duration: '>120ms' }
 },
 ecgFeatures: [
 'QRS = 120ms',
 'Breed, genoteerd R in I, aVL, V5-V6',
 'rS of QS in V1-V3',
 'Geen septale Q in I, V5-V6',
 'Afwezige R-progressie V1-V3',
 'Concordante of discordante ST-T veranderingen'
 ],
 clinicalSignificance: 'Vaak geassocieerd met structurele hartziekte, maskeert MI',
 commonCauses: [
 'Hypertensie',
 'Coronairlijden',
 'Cardiomyopathie',
 'Aortastenose',
 'Na MI'
 ],
 treatment: 'Behandel onderliggende oorzaak; bij nieuw/vermoedelijk nieuw LBBB met ischemische klachten: behandel als hoog-risico ACS en beoordeel aanvullend (o.a. Sgarbossa/modified Sgarbossa, seriële ECG/troponine)',
 clinicalPearl: 'Nieuw LBBB alléén bewijst geen STEMI; combineer met kliniek en aanvullende ischemiecriteria.',
 waveformParams: {
 broadR: true,
 qrsWidth: 0.16,
 v1Morphology: 'QS',
 v6Morphology: 'broadR'
 },
 quizHints: [
 'Breed QRS met brede R in V6, I',
 'QS in V1',
 'Nieuw LBBB + ischemische klachten = hoog-risico ACS'
 ]
 },

 lafb: {
 id: 'lafb',
 name: 'Linker Anterior Fasciculair Blok',
 shortName: 'LAFB',
 category: 'blocks',
 difficulty: 'hard',
 urgency: 'none',
 description: 'Blok van voorste tak van linker bundeltak',
 characteristics: {
 rate: { min: 60, max: 100, typical: 75 },
 rhythm: 'Regelmatig',
 pWave: 'Normaal',
 qrsComplex: { duration: '100-120ms' }
 },
 ecgFeatures: [
 'Linker asdeviatie (-45° tot -90°)',
 'qR in I, aVL',
 'rS in II, III, aVF',
 'QRS < 120ms',
 'Kleine q in I, aVL (septale activatie)'
 ],
 clinicalSignificance: 'Meestal benigne, kan wijzen op onderliggende hartziekte',
 commonCauses: ['Hypertensie', 'Coronairlijden', 'Cardiomyopathie', 'Fibrose'],
 treatment: 'Geen specifieke behandeling',
 waveformParams: {
 leftAxisDeviation: true,
 axis: -60
 },
 quizHints: [
 'Extreme linker as (-45° tot -90°)',
 'QRS normaal of licht verbreed',
 'qR in I, rS in III'
 ]
 },

 lpfb: {
 id: 'lpfb',
 name: 'Linker Posterior Fasciculair Blok',
 shortName: 'LPFB',
 category: 'blocks',
 difficulty: 'hard',
 urgency: 'low',
 description: 'Blok van achterste tak van linker bundeltak',
 characteristics: {
 rate: { min: 60, max: 100, typical: 75 },
 rhythm: 'Regelmatig',
 pWave: 'Normaal',
 qrsComplex: { duration: '100-120ms' }
 },
 ecgFeatures: [
 'Rechter asdeviatie (+90° tot +180°)',
 'rS in I, aVL',
 'qR in II, III, aVF',
 'QRS < 120ms',
 'Exclusie andere oorzaken RAD'
 ],
 clinicalSignificance: 'Zeldzaam, vaker geassocieerd met significante hartziekte dan LAFB',
 commonCauses: ['Coronairlijden', 'Cardiomyopathie', 'Congenitaal'],
 treatment: 'Geen specifieke behandeling, evalueer voor hartziekte',
 waveformParams: {
 rightAxisDeviation: true,
 axis: 110
 },
 quizHints: [
 'Rechter as (+90° tot +180°)',
 'Zeldzamer dan LAFB',
 'Sluit andere oorzaken RAD uit'
 ]
 },

 bifascicular: {
 id: 'bifascicular',
 name: 'Bifasciculair Blok',
 shortName: 'BFB',
 category: 'blocks',
 difficulty: 'hard',
 urgency: 'medium',
 description: 'Combinatie van RBBB + LAFB of RBBB + LPFB',
 characteristics: {
 rate: { min: 60, max: 100, typical: 70 },
 rhythm: 'Regelmatig',
 qrsComplex: { duration: '>120ms' }
 },
 ecgFeatures: [
 'RBBB morfologie + linker of rechter asdeviatie',
 'Meest voorkomend: RBBB + LAFB',
 'Bij toevoegen 1e graads blok: trifasciculair'
 ],
 clinicalSignificance: 'Verhoogd risico op progressie naar compleet hartblok',
 commonCauses: ['Coronairlijden', 'Cardiomyopathie', 'Degeneratief'],
 treatment: 'Monitoring, mogelijk pacemaker bij symptomen',
 waveformParams: {
 rbbb: true,
 lafb: true
 },
 quizHints: [
 'RBBB + extreme linker as = RBBB + LAFB',
 'RBBB + extreme rechter as = RBBB + LPFB',
 'Let op progressie'
 ]
 },

 // ==================== ISCHEMIE & INFARCTEN ====================
 stemi_anterior: {
 id: 'stemi_anterior',
 name: 'Anterieur STEMI',
 shortName: 'Ant STEMI',
 category: 'ischemia',
 difficulty: 'medium',
 urgency: 'critical',
 description: 'ST-elevatie infarct van voorwand door LAD occlusie',
 characteristics: {
 territory: 'Anterior (V1-V4)',
 artery: 'LAD',
 reciprocal: 'Inferior afleidingen (II, III, aVF)'
 },
 ecgFeatures: [
 'ST-elevatie V1-V4 (soms V5-V6)',
 'Reciproke ST-depressie in II, III, aVF',
 'Hyperacute T-golven vroeg',
 'Kan evolueren naar Q-golven',
 'Uitgebreid: ook ST-elevatie in I, aVL'
 ],
 clinicalSignificance: 'GROOT INFARCT - hoge mortaliteit zonder reperfusie',
 riskArea: 'Grote hoeveelheid myocard, risico op hartfalen',
 treatment: 'Directe reperfusiestrategie: primaire PCI zo snel mogelijk binnen regionale streeftijden; overweeg fibrinolyse als tijdige PCI niet haalbaar is',
 timing: {
 hyperacute: 'Hoge spitse T-golven',
 acute: 'ST-elevatie, begin Q-vorming',
 subacute: 'T-inversie, Q-golven',
 old: 'Persisterende Q-golven'
 },
 waveformParams: {
 stElevation: 0.3,
 elevationLeads: ['V2', 'V3', 'V4'],
 reciprocalDepression: ['III', 'aVF'],
 hyperacuteT: true
 },
 quizHints: [
 'ST-elevatie V1-V4 = anterieur (LAD)',
 'Reciprook: inferior depressie',
 'DIRECT cath lab!'
 ]
 },

 stemi_inferior: {
 id: 'stemi_inferior',
 name: 'Inferieur STEMI',
 shortName: 'Inf STEMI',
 category: 'ischemia',
 difficulty: 'medium',
 urgency: 'critical',
 description: 'ST-elevatie infarct van onderwand door RCA of LCx occlusie',
 characteristics: {
 territory: 'Inferior (II, III, aVF)',
 artery: 'RCA (80%) of LCx (20%)',
 reciprocal: 'Anterior afleidingen (I, aVL)'
 },
 ecgFeatures: [
 'ST-elevatie II, III, aVF',
 'ST III > ST II suggereert RCA',
 'Reciproke ST-depressie I, aVL',
 'Check V4R voor rechterventrikel betrokkenheid',
 'ST-depressie V1-V3 kan wijzen op posterieure extensie'
 ],
 clinicalSignificance: 'Risico op bradycardie/blok bij RCA, RV infarct',
 complications: ['AV-blok', 'RV infarct', 'Bradycardie'],
 treatment: 'Primaire PCI, voorzichtig met nitraten bij RV betrokkenheid',
 waveformParams: {
 stElevation: 0.25,
 elevationLeads: ['II', 'III', 'aVF'],
 reciprocalDepression: ['I', 'aVL']
 },
 quizHints: [
 'ST-elevatie II, III, aVF = inferior',
 'Check V4R voor RV infarct',
 'Let op bradycardie/blok'
 ]
 },

 stemi_lateral: {
 id: 'stemi_lateral',
 name: 'Lateraal STEMI',
 shortName: 'Lat STEMI',
 category: 'ischemia',
 difficulty: 'medium',
 urgency: 'critical',
 description: 'ST-elevatie infarct van laterale wand',
 characteristics: {
 territory: 'Lateral (I, aVL, V5-V6)',
 artery: 'LCx of diagonale tak LAD',
 reciprocal: 'III, aVF'
 },
 ecgFeatures: [
 'ST-elevatie I, aVL',
 'ST-elevatie V5, V6 (laag lateraal)',
 'Reciproke ST-depressie III, aVF',
 'Kan geïsoleerd of met anterior/inferior'
 ],
 clinicalSignificance: 'Kan wijzen op LCx occlusie',
 treatment: 'Primaire PCI',
 waveformParams: {
 stElevation: 0.2,
 elevationLeads: ['I', 'aVL', 'V6'],
 reciprocalDepression: ['III']
 },
 quizHints: [
 'ST-elevatie I, aVL ± V5-V6',
 'Hoog lateraal vs laag lateraal',
 'LCx of diagonaal'
 ]
 },

 stemi_posterior: {
 id: 'stemi_posterior',
 name: 'Posterieur STEMI',
 shortName: 'Post STEMI',
 category: 'ischemia',
 difficulty: 'hard',
 urgency: 'critical',
 description: 'ST-elevatie infarct van achterwand (spiegelbeeld in V1-V3)',
 characteristics: {
 territory: 'Posterior',
 artery: 'LCx of RCA',
 reciprocal: 'V1-V3 (eigenlijk directe tekenen gespiegeld)'
 },
 ecgFeatures: [
 'ST-depressie V1-V3 (spiegelbeeld van elevatie)',
 'Hoge R-golf V1 (spiegelbeeld van Q)',
 'Positieve T-golf V1-V2 (spiegelbeeld inversie)',
 'ST-elevatie in V7-V9 (posterior afleidingen)',
 'Vaak samen met inferieur STEMI'
 ],
 clinicalSignificance: 'Vaak gemist! Zoek naar bij inferior STEMI',
 treatment: 'Primaire PCI',
 clinicalPearl: 'ST-depressie V1-V3 met hoge R = posterior STEMI!',
 waveformParams: {
 stDepression: 0.2,
 depressionLeads: ['V1', 'V2', 'V3'],
 tallR: true
 },
 quizHints: [
 'ST-depressie V1-V3 = denk posterior',
 'Hoge R V1 = "Q-golf equivalent"',
 'Maak V7-V9 voor bevestiging'
 ]
 },

 nstemi: {
 id: 'nstemi',
 name: 'NSTEMI / Instabiele Angina',
 shortName: 'NSTEMI',
 category: 'ischemia',
 difficulty: 'medium',
 urgency: 'high',
 description: 'Acuut coronair syndroom zonder ST-elevatie',
 characteristics: {
 rate: { min: 60, max: 120, typical: 90 },
 rhythm: 'Variabel',
 ecgChanges: 'ST-depressie en/of T-golf veranderingen'
 },
 ecgFeatures: [
 'ST-depressie (horizontaal of downsloping)',
 'T-golf inversie (symmetrisch, diep)',
 'Geen ST-elevatie (behalve aVR)',
 'Dynamische veranderingen',
 'ST-elevatie aVR kan wijzen op LM/3-vats'
 ],
 clinicalSignificance: 'ACS - urgent maar niet direct cath lab (binnen 24-72u)',
 treatment: 'Antitrombotische therapie, risicostratificatie, coronair angiografie',
 medications: {
 immediate: ['Aspirine', 'Heparine', 'P2Y12 remmer'],
 supportive: ['Bètablokker', 'Nitraat', 'Morfine indien pijn']
 },
 waveformParams: {
 stDepression: 0.15,
 tInversion: true
 },
 quizHints: [
 'ST-depressie, geen elevatie',
 'T-inversie (symmetrisch)',
 'Troponine bepaalt NSTEMI vs UA'
 ]
 },

 wellens: {
 id: 'wellens',
 name: "Wellens' Syndroom",
 shortName: 'Wellens',
 category: 'ischemia',
 difficulty: 'hard',
 urgency: 'high',
 description: 'T-golf patroon voorspellend voor kritieke LAD stenose',
 characteristics: {
 territory: 'Anterior',
 artery: 'Proximale LAD'
 },
 ecgFeatures: [
 'Type A (25%): Bifasische T-golf V2-V3 (positief-negatief)',
 'Type B (75%): Diepe symmetrische T-inversie V2-V3',
 'Minimale of geen ST-elevatie',
 'Geen significant Q-verlies',
 'Normale of minimaal verhoogde enzymen'
 ],
 clinicalSignificance: 'KRITIEKE LAD STENOSE - hoog risico op anterior MI',
 clinicalPearl: 'GEEN inspanningstest! Direct coronairangiografie',
 treatment: 'Coronairangiografie, waarschijnlijk revascularisatie',
 waveformParams: {
 wellensTypeB: true,
 deepTInversion: 0.5,
 leads: ['V2', 'V3']
 },
 quizHints: [
 'Diepe symmetrische T-inversie V2-V3',
 'Pijnvrij moment',
 'Kritieke LAD = direct angio'
 ]
 },

 deWinter: {
 id: 'deWinter',
 name: 'De Winter T-golven',
 shortName: 'De Winter',
 category: 'ischemia',
 difficulty: 'hard',
 urgency: 'critical',
 description: 'STEMI-equivalent met upsloping ST-depressie en hoge T-golven',
 characteristics: {
 territory: 'Anterior',
 artery: 'Proximale LAD'
 },
 ecgFeatures: [
 'Upsloping ST-depressie > 1mm J-punt V1-V6',
 'Hoge, symmetrische, spitse T-golven V1-V6',
 'Geen ST-elevatie precordiaal',
 'ST-elevatie 1-2mm in aVR',
 'Kan persisteren tijdens occlusie'
 ],
 clinicalSignificance: 'STEMI-EQUIVALENT - direct naar cath lab!',
 clinicalPearl: 'Kan zonder klassiek STEMI-patroon persisteren; behandel als acute coronairocclusie (STEMI-equivalent).',
 treatment: 'Behandelen als STEMI - primaire PCI',
 waveformParams: {
 upSlopingSTdep: true,
 tallSymmetricT: true,
 aVRelevation: true
 },
 quizHints: [
 'Upsloping ST-depressie V1-V6',
 'Hoge spitse T-golven',
 'STEMI-equivalent!'
 ]
 },

 // ==================== PACEMAKER RITMES ====================
 paced_ventricular: {
 id: 'paced_ventricular',
 name: 'Ventriculair Gepaced Ritme',
 shortName: 'VVI',
 category: 'pacemaker',
 difficulty: 'medium',
 urgency: 'none',
 description: 'Ventriculaire pacing met breed QRS na pacemaker spike',
 characteristics: {
 rate: { min: 60, max: 80, typical: 70 },
 rhythm: 'Regelmatig',
 pWave: 'Kan aanwezig zijn (niet gerelateerd)',
 qrsComplex: 'Breed met LBBB morfologie'
 },
 ecgFeatures: [
 'Pacemaker spike voor QRS',
 'Breed QRS (LBBB-achtig)',
 'Regelmatig interval',
 'Geen relatie met P-golven (VVI)',
 'ST-T afwijkingen secundair aan pacing'
 ],
 clinicalSignificance: 'Normale pacemaker functie',
 treatment: 'Pacemaker controle, batterij check',
 waveformParams: {
 pacingSpike: true,
 qrsWidth: 0.16,
 lbbbMorphology: true
 },
 quizHints: [
 'Spike -> breed QRS',
 'LBBB morfologie (RV apex pacing)',
 'Regelmatig ritme'
 ]
 },

 paced_dual: {
 id: 'paced_dual',
 name: 'Dual Chamber Pacing (DDD)',
 shortName: 'DDD',
 category: 'pacemaker',
 difficulty: 'hard',
 urgency: 'none',
 description: 'Atriale en ventriculaire pacing met sensing in beide kamers',
 characteristics: {
 rate: { min: 60, max: 130, typical: 70 },
 rhythm: 'Regelmatig',
 pWave: 'Gepaced of eigen P',
 qrsComplex: 'Gepaced of eigen QRS'
 },
 ecgFeatures: [
 'Atriale spike -> P-golf',
 'Ventriculaire spike -> QRS',
 'AV-interval geprogrammeerd',
 'Kan 4 patronen tonen: AP-VP, AP-VS, AS-VP, AS-VS'
 ],
 clinicalSignificance: 'Meest fysiologische pacing mode',
 treatment: 'Reguliere pacemaker controle',
 waveformParams: {
 atrialSpike: true,
 ventricularSpike: true,
 avDelay: 0.16
 },
 quizHints: [
 'Twee spikes mogelijk (A en V)',
 'AV-synchronie behouden',
 'Meest voorkomende pacemaker'
 ]
 },

 pacemaker_malfunction: {
 id: 'pacemaker_malfunction',
 name: 'Pacemaker Dysfunctie',
 shortName: 'PM Dysfunctie',
 category: 'pacemaker',
 difficulty: 'hard',
 urgency: 'high',
 description: 'Failure to pace, capture, of sense',
 characteristics: {
 rhythm: 'Onregelmatig of afwezig pacing'
 },
 ecgFeatures: [
 'Failure to pace: geen spikes wanneer verwacht',
 'Failure to capture: spike zonder QRS',
 'Failure to sense (undersensing): spike op eigen slag',
 'Oversensing: geen pacing door onterecht sensed signaal'
 ],
 clinicalSignificance: 'Kan levensbedreigend zijn afhankelijk van onderliggend ritme',
 commonCauses: [
 'Batterij uitputting',
 'Lead dislocatie',
 'Lead fractuur',
 'Verhoogde drempel',
 'EMI interferentie'
 ],
 treatment: 'Magnet applicatie, transcutane pacing, urgente PM check',
 waveformParams: {
 malfunction: true
 },
 quizHints: [
 'Spike zonder QRS = failure to capture',
 'Geen spike = failure to pace',
 'Spike op eigen QRS = undersensing'
 ]
 },

 // ==================== ELEKTROLYTSTOORNISSEN ====================
 hyperkalemia: {
 id: 'hyperkalemia',
 name: 'Hyperkaliëmie',
 shortName: 'Hyper-K',
 category: 'other',
 difficulty: 'medium',
 urgency: 'high',
 description: 'ECG veranderingen door verhoogd kalium',
 characteristics: {
 potassiumLevel: '> 5.5 mmol/L'
 },
 ecgFeatures: [
 'Vroeg (5.5-6.5): Spitse, tenting T-golven',
 'Matig (6.5-7.5): PR-verlenging, afvlakking P',
 'Ernstig (7.5-8.5): Breed QRS, verlies P',
 'Kritiek (>8.5): sinusgolf patroon -> VF/asystolie'
 ],
 progression: [
 { level: '5.5-6.0', finding: 'Spitse T-golven' },
 { level: '6.0-7.0', finding: 'PR verlenging' },
 { level: '7.0-8.0', finding: 'P afvlakking, QRS verbreding' },
 { level: '8.0+', finding: 'Sinusgolf, VF risico' }
 ],
 clinicalSignificance: 'LEVENSBEDREIGENDE elektrolytstoornis',
 treatment: 'Calcium IV (cardioprotectie), Insulin/glucose, Salbutamol, Dialyse',
 medications: {
 immediate: ['Calciumgluconaat 10ml 10% IV', 'Calcium stabiliseert membraan'],
 shift: ['Insuline 10E + Glucose 50ml 50%', 'Salbutamol 10-20mg neb'],
 remove: ['Resonium', 'Dialyse']
 },
 waveformParams: {
 tentedT: true,
 wideQRS: true,
 flatP: true
 },
 quizHints: [
 'Spitse T-golven = eerste teken',
 'Progressie: T -> P -> QRS -> sinusgolf',
 'Calcium IV = eerste actie'
 ]
 },

 hypokalemia: {
 id: 'hypokalemia',
 name: 'Hypokaliëmie',
 shortName: 'Hypo-K',
 category: 'other',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'ECG veranderingen door verlaagd kalium',
 characteristics: {
 potassiumLevel: '< 3.5 mmol/L'
 },
 ecgFeatures: [
 'Afvlakking T-golven',
 'U-golven (na T-golf)',
 'ST-depressie',
 'Verlengd QT (QU) interval',
 'Verhoogd aritmie risico (PAC, PVC, VT)'
 ],
 clinicalSignificance: 'Verhoogd risico op aritmieën, vooral bij digoxine gebruik',
 commonCauses: ['Diuretica', 'Braken/diarree', 'Insuline therapie'],
 treatment: 'Kalium suppletie PO of IV',
 waveformParams: {
 flatT: true,
 prominentU: true,
 stDepression: true
 },
 quizHints: [
 'U-golf = kenmerkend',
 'T afvlakking, ST depressie',
 'QT lijkt verlengd (eigenlijk QU)'
 ]
 },

 hypercalcemia: {
 id: 'hypercalcemia',
 name: 'Hypercalciëmie',
 shortName: 'Hyper-Ca',
 category: 'other',
 difficulty: 'hard',
 urgency: 'medium',
 description: 'ECG veranderingen door verhoogd calcium',
 characteristics: {
 calciumLevel: '> 2.6 mmol/L'
 },
 ecgFeatures: [
 'Verkort QT-interval',
 'Verkorte ST-segment (bijna afwezig)',
 'Osborn golven bij ernstige gevallen'
 ],
 clinicalSignificance: 'Kan wijzen op maligniteit, hyperparathyreoïdie',
 treatment: 'Hydratie, bisfosfonaten, behandel oorzaak',
 waveformParams: {
 shortQT: true,
 shortST: true
 },
 quizHints: [
 'Kort QT-interval',
 'ST-segment bijna afwezig',
 '"Short QT = high calcium"'
 ]
 },

 hypocalcemia: {
 id: 'hypocalcemia',
 name: 'Hypocalciëmie',
 shortName: 'Hypo-Ca',
 category: 'other',
 difficulty: 'hard',
 urgency: 'medium',
 description: 'ECG veranderingen door verlaagd calcium',
 characteristics: {
 calciumLevel: '< 2.1 mmol/L'
 },
 ecgFeatures: [
 'Verlengd QT-interval',
 'Verlengd ST-segment',
 'T-golf kan normaal zijn'
 ],
 clinicalSignificance: 'Risico op aritmieën bij ernstige hypocalciëmie',
 treatment: 'Calcium suppletie IV bij symptomen',
 waveformParams: {
 longQT: true,
 longST: true
 },
 quizHints: [
 'Lang QT door lang ST-segment',
 'T-golf zelf vaak normaal',
 '"Long QT = low calcium"'
 ]
 },

 // ==================== OVERIGE ====================
 asystole: {
 id: 'asystole',
 name: 'Asystolie',
 shortName: 'Asystole',
 category: 'ventricular',
 difficulty: 'easy',
 urgency: 'critical',
 description: 'Afwezigheid van ventriculaire elektrische activiteit',
 characteristics: {
 rate: 0,
 rhythm: 'Geen'
 },
 ecgFeatures: [
 'Vlakke lijn of minimale artefacten',
 'Geen QRS-complexen',
 'Soms nog P-golven zichtbaar (P-golf asystolie)',
 'Bevestig in meerdere afleidingen'
 ],
 clinicalSignificance: 'HARTSTILSTAND',
 treatment: 'CPR, adrenaline, reversibele oorzaken behandelen (4H/4T)',
 waveformParams: {
 flatline: true,
 possiblePwaves: true
 },
 quizHints: [
 'Vlakke lijn',
 'Check kabels/afleidingen',
 'Geen schokbaar ritme'
 ]
 },

 pea: {
 id: 'pea',
 name: 'Polsloze Elektrische Activiteit',
 shortName: 'PEA',
 category: 'other',
 difficulty: 'medium',
 urgency: 'critical',
 description: 'Georganiseerd ECG ritme zonder tastbare pols',
 characteristics: {
 rate: 'Variabel',
 rhythm: 'Kan georganiseerd zijn',
 pulse: 'AFWEZIG'
 },
 ecgFeatures: [
 'Elke georganiseerd ritme mogelijk',
 'Vaak sinus of traag ritme',
 'Kan QRS-complexen tonen',
 'GEEN palpabele pols'
 ],
 clinicalSignificance: 'HARTSTILSTAND - zoek reversibele oorzaken',
 reversibleCauses: {
 '4H': ['Hypoxie', 'Hypovolemie', 'Hypo/hyperkaliëmie', 'Hypothermie'],
 '4T': ['Tensie pneumothorax', 'Tamponade', 'Toxines', 'Trombose (coronair/pulmonaal)']
 },
 treatment: 'CPR, adrenaline, behandel oorzaak',
 waveformParams: {
 organizedRhythm: true,
 noPulse: true
 },
 quizHints: [
 'Ritme op monitor, geen pols',
 'Behandel als hartstilstand',
 'Zoek 4H en 4T'
 ]
 },

 wpw: {
 id: 'wpw',
 name: 'Wolff-Parkinson-White Syndroom',
 shortName: 'WPW',
 category: 'other',
 difficulty: 'hard',
 urgency: 'medium',
 description: 'Pre-excitatie door accessoire bundel',
 characteristics: {
 rate: { min: 60, max: 100, typical: 75 },
 rhythm: 'Regelmatig (sinusritme)'
 },
 ecgFeatures: [
 'Kort PR-interval (< 120ms)',
 'Delta golf (slurring upstroke QRS)',
 'Breed QRS (> 100ms)',
 'Secundaire ST-T veranderingen'
 ],
 clinicalSignificance: 'Risico op AVRT en snel AF met brede complexen',
 treatment: 'Ablatie; bij pre-excitatie met AF vermijd AV-knoopblokkers (o.a. adenosine, verapamil/diltiazem, digoxine, bètablokkers) en volg specialistisch spoedprotocol',
 warning: 'Bij WPW + AF geen AV-knoopblokkers (adenosine, verapamil/diltiazem, digoxine, bètablokkers) wegens risico op zeer snelle geleiding/VF.',
 waveformParams: {
 shortPR: true,
 deltaWave: true,
 wideQRS: true
 },
 quizHints: [
 'Kort PR + delta golf + breed QRS',
 'Let op bij AF!',
 'Bij pre-excitatie + AF: vermijd AV-knoopblokkers'
 ]
 },

 brugada: {
 id: 'brugada',
 name: 'Brugada Syndroom',
 shortName: 'Brugada',
 category: 'other',
 difficulty: 'hard',
 urgency: 'high',
 description: 'Genetische ionkanaal aandoening met VF risico',
 characteristics: {
 rate: { min: 60, max: 100, typical: 70 },
 rhythm: 'Sinusritme (maar risico op VF)'
 },
 ecgFeatures: [
 'Type 1: Coved ST-elevatie = 2mm V1-V2 met negatieve T',
 'Type 2: Saddleback ST-elevatie',
 'RBBB of RBBB-achtig patroon',
 'Kan dynamisch zijn of uitgelokt door koorts'
 ],
 clinicalSignificance: 'Hoog risico op plotse hartdood',
 treatment: 'ICD bij hoog-risico patiënten',
 waveformParams: {
 covedST: true,
 rbbbPattern: true
 },
 quizHints: [
 'Coved ST-elevatie V1-V2',
 'Kan uitgelokt door koorts',
 'Jonge mannen, Aziatische afkomst'
 ]
 },

 long_qt: {
 id: 'long_qt',
 name: 'Lang QT Syndroom',
 shortName: 'LQTS',
 category: 'other',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'Verlengd QT-interval met risico op TdP',
 characteristics: {
 qtc: '> 460ms vrouwen, > 440ms mannen'
 },
 ecgFeatures: [
 'QTc verlengd (Bazett formule)',
 'Abnormale T-golf morfologie',
 'Kan T-wave alternans tonen',
 'Risico op TdP'
 ],
 clinicalSignificance: 'Risico op Torsades de Pointes en plotse dood',
 commonCauses: [
 'Congenitaal (LQTS1, 2, 3)',
 'Medicatie (antiarrhythmica, antibiotica, antipsychotica)',
 'Elektrolytstoornissen (K, Mg, Ca)'
 ],
 treatment: 'Stop uitlokkende medicatie, correctie elektrolyten, bètablokker, ICD',
 waveformParams: {
 longQT: true,
 abnormalT: true
 },
 quizHints: [
 'QTc > 450-460ms',
 'Bereken QTc = QT / vRR',
 'Check medicatie en elektrolyten'
 ]
 },

 hypothermia: {
 id: 'hypothermia',
 name: 'Hypothermie ECG',
 shortName: 'Hypothermie',
 category: 'other',
 difficulty: 'hard',
 urgency: 'high',
 description: 'ECG veranderingen bij onderkoeling',
 characteristics: {
 temperature: '< 35°C'
 },
 ecgFeatures: [
 'Osborn golven (J-golven) - positieve deflectie na QRS',
 'Bradycardie',
 'Verlengd PR, QRS, QT',
 'Atriumfibrilleren',
 'Bewegingsartefacten (rillen)'
 ],
 clinicalSignificance: 'Zoek naar onderkoeling, verdringingsrisico',
 treatment: 'Langzame opwarming, let op aritmieën bij opwarmen',
 waveformParams: {
 osbornWave: true,
 bradycardia: true,
 prolongedIntervals: true
 },
 quizHints: [
 'Osborn/J-golf = kenmerkend',
 'Bradycardie, lange intervallen',
 'Spier artefacten door rillen'
 ]
 },

 digoxin_toxicity: {
 id: 'digoxin_toxicity',
 name: 'Digoxine Effect/Toxiciteit',
 shortName: 'Dig Effect',
 category: 'other',
 difficulty: 'hard',
 urgency: 'medium',
 description: 'ECG veranderingen door digoxine',
 characteristics: {
 therapeutic: 'Digoxine effect',
 toxic: 'Digoxine toxiciteit'
 },
 ecgFeatures: [
 'Therapeutisch: ST "scooping" (omgekeerde Nike swoosh)',
 'Therapeutisch: QT verkorting',
 'Toxisch: Elke aritmie mogelijk',
 'Toxisch: Bidirectionele VT pathognomonisch',
 'Toxisch: AF met regelmatig ventrikel respons',
 'Toxisch: Versneld junctioneel ritme'
 ],
 clinicalSignificance: 'Digoxine toxiciteit kan fataal zijn',
 treatment: 'Stop digoxine, correctie K/Mg, Digibind bij ernstige toxiciteit',
 waveformParams: {
 scoopedST: true,
 shortQT: true
 },
 quizHints: [
 'Salvador Dalí snor ST-segment',
 'Bidirectionele VT = toxiciteit',
 'AF + regelmatig = junctioneel (toxisch)'
 ]
 },

 pe_ecg: {
 id: 'pe_ecg',
 name: 'Longembolie ECG',
 shortName: 'PE ECG',
 category: 'other',
 difficulty: 'hard',
 urgency: 'high',
 description: 'ECG kenmerken bij longembolie',
 characteristics: {
 sensitivity: 'Laag - ECG kan normaal zijn'
 },
 ecgFeatures: [
 'Sinustachycardie (meest voorkomend)',
 'S1Q3T3 patroon (klassiek maar zeldzaam)',
 'RBBB (nieuw)',
 'T-inversie V1-V4 (anterieur)',
 'Rechter asdeviatie',
 'Atriumfibrilleren'
 ],
 clinicalSignificance: 'ECG onvoldoende sensitief - kliniek + D-dimeer + CT-angio',
 treatment: 'Anticoagulatie, trombolyse bij massale PE',
 waveformParams: {
 s1q3t3: true,
 tachycardia: true,
 tInversionV1V4: true
 },
 quizHints: [
 'Sinustachycardie meest voorkomend',
 'S1Q3T3 = klassiek maar zeldzaam',
 'ECG vaak normaal bij PE'
 ]
 },

 pericarditis: {
 id: 'pericarditis',
 name: 'Pericarditis',
 shortName: 'Pericarditis',
 category: 'other',
 difficulty: 'medium',
 urgency: 'medium',
 description: 'Ontsteking van het hartzakje',
 characteristics: {
 evolution: 'Verandert over dagen'
 },
 ecgFeatures: [
 'Stadium 1: Diffuse ST-elevatie (concaaf/saddle-shaped)',
 'Stadium 1: PR-depressie (behalve aVR)',
 'Stadium 1: ST-elevatie in aVR afwezig',
 'Stadium 2: Normalisatie ST',
 'Stadium 3: Diffuse T-inversie',
 'Stadium 4: Normalisatie'
 ],
 differentiatingFromSTEMI: [
 'Diffuus (niet territoriaal)',
 'Concave ST-elevatie',
 'PR-depressie',
 'Geen reciproke depressie (behalve aVR)'
 ],
 treatment: 'NSAIDs, colchicine',
 waveformParams: {
 diffuseSTElevation: true,
 prDepression: true,
 concaveST: true
 },
 quizHints: [
 'Diffuse ST? + PR?',
 'Concave ("smiley") ST-elevatie',
 'Geen reciproke veranderingen'
 ]
 },

 junctional_rhythm: {
 id: 'junctional_rhythm',
 name: 'Junctioneel Ritme',
 shortName: 'JR',
 category: 'bradycardia',
 difficulty: 'medium',
 urgency: 'low',
 description: 'Escape ritme vanuit AV-junctie',
 characteristics: {
 rate: { min: 40, max: 60, typical: 50 },
 rhythm: 'Regelmatig',
 pWave: 'Afwezig, retrograad, of na QRS',
 qrsComplex: 'Smal'
 },
 ecgFeatures: [
 'Smalle QRS-complexen',
 'P-golf absent, retrograad (negatief in II), of na QRS',
 'Regelmatig ritme 40-60/min',
 'Geen relatie P met QRS indien AV-dissociatie'
 ],
 clinicalSignificance: 'Escape ritme - zoek naar oorzaak sinusknoop/AV falen',
 commonCauses: ['Sick sinus', 'Digoxine', 'Bètablokkers', 'Post-cardiochirurgie'],
 treatment: 'Behandel oorzaak, pacing indien symptomatisch',
 waveformParams: {
 narrowQRS: true,
 retrogradeP: true,
 absentP: true
 },
 quizHints: [
 'Smalle QRS zonder normale P',
 'Escape ritme (40-60/min)',
 'P kan afwezig, retrograad, of na QRS'
 ]
 },

 accelerated_junctional: {
 id: 'accelerated_junctional',
 name: 'Versneld Junctioneel Ritme',
 shortName: 'AJR',
 category: 'tachycardia',
 difficulty: 'medium',
 urgency: 'low',
 description: 'Junctioneel ritme met verhoogde frequentie',
 characteristics: {
 rate: { min: 60, max: 100, typical: 80 },
 rhythm: 'Regelmatig',
 pWave: 'Afwezig of retrograad'
 },
 ecgFeatures: [
 'Smal QRS',
 'Frequentie 60-100/min',
 'P-golven afwezig of retrograad'
 ],
 clinicalSignificance: 'Kan wijzen op digoxine toxiciteit of ischemie',
 commonCauses: ['Digoxine toxiciteit', 'Inferior MI', 'Post-cardiochirurgie'],
 treatment: 'Behandel oorzaak',
 waveformParams: {
 narrowQRS: true,
 moderateRate: true
 },
 quizHints: [
 'Junctioneel maar 60-100/min',
 'Denk aan digoxine toxiciteit',
 'Vaak na inferior MI'
 ]
 }
 },

 // ========== HELPER FUNCTIES ==========
 getAllRhythms() {
 return Object.values(this.rhythms);
 },

 getRhythmById(id) {
 return this.rhythms[id] || null;
 },

 getRhythmsByCategory(category) {
 if (category === 'all') return this.getAllRhythms();
 return this.getAllRhythms().filter(r => r.category === category);
 },

 getRhythmsByDifficulty(difficulty) {
 if (difficulty === 'all') return this.getAllRhythms();
 return this.getAllRhythms().filter(r => r.difficulty === difficulty);
 },

 getRhythmsByUrgency(urgency) {
 return this.getAllRhythms().filter(r => r.urgency === urgency);
 },

 getCriticalRhythms() {
 return this.getAllRhythms().filter(r => r.urgency === 'critical' || r.urgency === 'high'
 );
 },

 getRandomRhythm(options = {}) {
 let pool = this.getAllRhythms();
 
 if (options.category && options.category !== 'all') {
 pool = pool.filter(r => r.category === options.category);
 }
 if (options.difficulty && options.difficulty !== 'all') {
 pool = pool.filter(r => r.difficulty === options.difficulty);
 }
 if (options.exclude) {
 pool = pool.filter(r => !options.exclude.includes(r.id));
 }
 
 if (pool.length === 0) return null;
 return pool[Math.floor(Math.random() * pool.length)];
 },

 searchRhythms(query) {
 if (!query) return this.getAllRhythms();
 query = query.toLowerCase();
 return this.getAllRhythms().filter(r => r.name.toLowerCase().includes(query) ||
 r.shortName.toLowerCase().includes(query) ||
 r.description.toLowerCase().includes(query) ||
 (r.ecgFeatures && r.ecgFeatures.some(f => f.toLowerCase().includes(query)))
 );
 },

 getDistractors(correctRhythm, count = 3, options = {}) {
 const correct = this.getRhythmById(correctRhythm);
 if (!correct) return [];

 const exclude = new Set(Array.isArray(options.exclude) ? options.exclude : []);
 exclude.add(correctRhythm);

 const allRhythms = this.getAllRhythms();
 const byId = new Map(allRhythms.map(r => [r.id, r]));
 const picked = [];
 const pickedIds = new Set();
 const push = (rhythm) => {
 if (!rhythm || exclude.has(rhythm.id) || pickedIds.has(rhythm.id)) return;
 pickedIds.add(rhythm.id);
 picked.push(rhythm);
 };

 // 1) Eerst klinische lookalikes voor sterkere differentiaaldiagnose.
 if (Array.isArray(correct.lookalikes)) {
 correct.lookalikes.forEach(item => push(byId.get(item.id)));
 }

 // 2) Daarna dezelfde categorie.
 Utils.shuffle(allRhythms.filter(r => r.category === correct.category)).forEach(push);

 // 3) Daarnazelfde moeilijkheid.
 Utils.shuffle(allRhythms.filter(r => r.difficulty === correct.difficulty)).forEach(push);

 // 4) Tenslotte overige ritmes als opvulling.
 Utils.shuffle(allRhythms).forEach(push);

 return picked.slice(0, count);
 },

 getCategoryStats() {
 const stats = {};
 for (const [catId, cat] of Object.entries(this.categories)) {
 stats[catId] = {
 ...cat,
 count: this.getRhythmsByCategory(catId).length
 };
 }
 return stats;
 }
 };

 // ==================== MEDICAL SOURCES & AUDIT ====================
 const MedicalSourceRegistry = Object.freeze({
 erc_als_2025: {
 title: 'RCUK/ALS 2025 (ERC-compatibel): Adult Advanced Life Support',
 url: 'https://www.resus.org.uk/professional-library/2025-resuscitation-guidelines/adult-advanced-life-support-guidelines',
 publisher: 'Resuscitation Council UK',
 publishedDate: '2025-12-09',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'RCUK ALS 2025: Adult ALS algoritmen (shockable/non-shockable arrest), Adult Tachyarrhythmia with pulse en Adult Bradyarrhythmia.'
 },
 erc_als_pubmed_2025: {
 title: 'European Resuscitation Council Guidelines 2025: Adult advanced life support',
 url: 'https://pubmed.ncbi.nlm.nih.gov/41117572/',
 publisher: 'Resuscitation',
 publishedDate: '2025-12-09',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ERC ALS 2025 manuscript: kernaanpak van schokbare/niet-schokbare ritmes, luchtweg, medicatie en post-ROSC-zorg.'
 },
 esc_af_2024: {
 title: 'ESC Guidelines 2024: Atrial Fibrillation',
 url: 'https://academic.oup.com/eurheartj/article/45/36/3314/7738779',
 publisher: 'European Society of Cardiology / European Heart Journal',
 publishedDate: '2024-08-30',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ESC AF 2024, hoofdstuk 6.1: management van hartfrequentie (rate control), inclusief medicatiekeuze en contra-indicaties.'
 },
 esc_acs_2023: {
 title: 'ESC Guidelines 2023: Acute Coronary Syndromes',
 url: 'https://academic.oup.com/eurheartj/article/44/38/3720/7243210',
 publisher: 'European Society of Cardiology / European Heart Journal',
 publishedDate: '2023-08-25',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ESC ACS 2023, secties 4.1.2 en 5.3: STEMI-diagnostiek en reperfusiestrategie (PCI binnen 120 min of fibrinolyse).'
 },
 esc_svt_2019: {
 title: 'ESC Guidelines 2019: Supraventricular Tachycardia',
 url: 'https://academic.oup.com/eurheartj/article/41/5/655/5556821',
 publisher: 'European Society of Cardiology / European Heart Journal',
 publishedDate: '2019-09-03',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ESC SVT 2019: acute behandeling van smal/breedcomplex tachycardie en adenosine alleen bij regelmatige ritmes.'
 },
 esc_va_2022: {
 title: 'ESC Guidelines 2022: Ventricular Arrhythmias and Sudden Cardiac Death',
 url: 'https://academic.oup.com/eurheartj/article/43/40/3997/6675633',
 publisher: 'European Society of Cardiology / European Heart Journal',
 publishedDate: '2022-08-26',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ESC VA 2022, Figure 9: acute aanpak van regelmatige brede-complex tachycardie (behandel als VT bij twijfel).'
 },
 esc_pacing_2021: {
 title: 'ESC Guidelines 2021: Cardiac Pacing and CRT',
 url: 'https://academic.oup.com/eurheartj/article/42/35/3427/6358547',
 publisher: 'European Society of Cardiology / European Heart Journal',
 publishedDate: '2021-08-29',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ESC Pacing 2021: evaluatie bradycardie, AV-blokken en indicaties voor tijdelijke/permanente pacing.'
 },
 esc_pe_2019: {
 title: 'ESC Guidelines 2019: Acute Pulmonary Embolism',
 url: 'https://academic.oup.com/eurheartj/article/41/4/543/5556136',
 publisher: 'European Society of Cardiology / European Heart Journal',
 publishedDate: '2019-08-31',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ESC PE 2019: ECG-bevindingen bij acute longembolie en risicogestuurde acute behandeling.'
 },
 acc_lbbb_2017: {
 title: 'ACC review: LBBB in patients with suspected MI',
 url: 'https://www.acc.org/latest-in-cardiology/articles/2017/02/28/14/10/lbbb-in-patients-with-suspected-mi',
 publisher: 'American College of Cardiology',
 publishedDate: '2017-02-28',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Expert review',
 keySection: 'ACC LBBB review: nieuw LBBB is niet op zichzelf diagnostisch voor acute STEMI; combineer met aanvullende ischemiecriteria.'
 },
 de_winter_2019: {
 title: 'The De Winter ECG pattern: systematic review (PubMed)',
 url: 'https://pubmed.ncbi.nlm.nih.gov/28362646/',
 publisher: 'Journal of Electrocardiology',
 publishedDate: '2017-08-01',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Review',
 keySection: 'Systematische review de Winter: coronairocclusiepatroon met hoge PPV, klinisch te behandelen als STEMI-equivalent.'
 },
 esc_pericardial_2015: {
 title: 'ESC Guidelines 2015: Pericardial Diseases',
 url: 'https://academic.oup.com/eurheartj/article/36/42/2921/2293378',
 publisher: 'European Society of Cardiology / European Heart Journal',
 publishedDate: '2015-08-29',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Guideline',
 keySection: 'ESC Pericardial 2015: diagnostiek en behandeling van acute pericarditis met ECG-interpretatie.'
 },
 aha_tachy_2025: {
 title: 'AHA 2025 Adult Tachyarrhythmia With a Pulse Algorithm',
 url: 'https://www.heart.org/-/media/CPR-Files/CPR-Guidelines-Files/2025-Algorithms/Algorithm-ACLS-Tachycardia-250514.pdf',
 publisher: 'American Heart Association',
 publishedDate: '2025-05-14',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Algorithm',
 keySection: 'AHA 2025 tachy algorithm: adenosine alleen bij regelmatige monomorfe ritmes en fabrikantadviesenergie voor cardioversie.'
 },
 aha_brady_2025: {
 title: 'AHA 2025 Adult Bradycardia With a Pulse Algorithm (Accessible PDF)',
 url: 'https://cpr.heart.org/-/media/CPR-Files/CPR-Guidelines-Files/2025-Accessible/Algorithm-ACLS-Bradycardia-LngDscrp-250725-Ed.pdf',
 publisher: 'American Heart Association',
 publishedDate: '2025-07-25',
 accessedDate: '2026-02-16',
 evidenceLevel: 'Algorithm',
 keySection: 'AHA 2025 brady algorithm: atropine 1 mg q3-5 min (max 3 mg), daarna pacing/infusies.'
 }
 });

 const MedicalContentAudit = {
 categorySourceMap: {
 normal: 'esc_pacing_2021',
 bradycardia: 'esc_pacing_2021',
 tachycardia: 'esc_svt_2019',
 atrial: 'esc_af_2024',
 ventricular: 'esc_va_2022',
 blocks: 'esc_pacing_2021',
 ischemia: 'esc_acs_2023',
 pacemaker: 'esc_pacing_2021',
 other: 'erc_als_2025'
 },
 rhythmSourceOverrides: {
 lbbb: 'acc_lbbb_2017',
 deWinter: 'de_winter_2019',
 vfib: 'erc_als_2025',
 pea: 'erc_als_2025',
 asystole: 'erc_als_2025',
 wpw: 'esc_svt_2019',
 pe_ecg: 'esc_pe_2019',
 pericarditis: 'esc_pericardial_2015'
 },
 rhythmWhyOverrides: {
 atrial_fibrillation: 'Onregelmatig-onregelmatig ritme zonder consistente P-golven past bij AF; beoordeel rate-control en trombo-embolierisico in context.',
 atrial_flutter: 'Zaagtandachtige flutter-golven met vaak regelmatige geleidingsverhouding (zoals 2:1) passen bij atriumflutter.',
 svt: 'Regelmatige smalcomplex tachycardie met abrupt begin/einde en vaak onzichtbare of retrograde P-golven past bij SVT.',
 vtach_monomorphic: 'Regelmatige brede complexe tachycardie met AV-dissociatie/capture-fusion kenmerken is VT tot het tegendeel bewezen is.',
 vtach_polymorphic: 'Polymorfe brede tachycardie met wisselende QRS-morfologie past bij polymorfe VT (bij QT-verlenging: torsades-context overwegen).',
 vfib: 'Chaotische elektrische activiteit zonder georganiseerde QRS-complexen en zonder effectieve output past bij VF (schokbaar ritme).',
 asystole: 'Afwezigheid van georganiseerde ventriculaire activiteit in meerdere afleidingen past bij asystolie (niet-schokbaar ritme).',
 pea: 'Georganiseerde elektrische activiteit zonder palpabele pols past bij PEA; focus op CPR, adrenaline en reversibele oorzaken.',
 stemi_anterior: 'ST-elevatie in aangrenzende anterieure afleidingen (V1-V4) met passend klinisch beeld past bij acuut anterieur infarct.',
 deWinter: 'Upsloping ST-depressie in precordialen met prominente, symmetrische T-golven is een coronairocclusiepatroon (STEMI-equivalent).',
 lbbb: 'Breed QRS met typische LBBB-morfologie wijst op linker bundeltakblok; ischemiediagnostiek vereist aanvullende criteria en klinische context.',
 hyperkalemia: 'Spitse T-golven, verbreding van QRS en afvlakking/verdwijnen van P-golven passen bij klinisch relevante hyperkaliëmie.',
 wpw: 'Kort PR-interval met delta-golf en verbreed begin van het QRS past bij pre-excitatie (WPW).'
 },
 rhythmDifferentiationOverrides: {
 vfib: {
 signaturePattern: 'Volledig chaotisch patroon zonder herkenbare P-QRS-T-structuur en zonder effectieve output.',
 looksLike: ['Fijne asystolie', 'Ernstig motion artifact'],
 keyDistinguishers: ['Geen consistente QRS-complexen', 'Amplitude en frequentie variëren continu', 'Patiënt is pulsloos: behandel als schokbaar arrest'],
 firstSafeStep: 'Start direct hoogwaardige CPR en defibrilleer zo snel mogelijk volgens schokbaar-arrestprotocol.'
 },
 asystole: {
 signaturePattern: 'Nagenoeg vlakke lijn zonder georganiseerde ventriculaire activiteit in meerdere afleidingen.',
 looksLike: ['Fijne ventrikelfibrillatie', 'Lead/electrode los contact'],
 keyDistinguishers: ['Geen identificeerbare QRS-complexen', 'Bevestig in meerdere afleidingen', 'Sluit technische oorzaak eerst uit'],
 firstSafeStep: 'Start direct CPR, geef adrenaline volgens protocol en behandel reversibele oorzaken (4H/4T).'
 },
 pea: {
 signaturePattern: 'Georganiseerd ECG-ritme zonder palpabele pols of effectieve circulatie.',
 looksLike: ['Ernstige hypotensie met zwakke pols', 'Pseudo-PEA bij meetfouten'],
 keyDistinguishers: ['Elektrische activiteit aanwezig maar klinisch geen puls', 'Ritme kan smal of breed zijn', 'Hemodynamiek bepaalt urgentie'],
 firstSafeStep: 'Behandel als niet-schokbaar arrest: CPR, adrenaline en parallel 4H/4T uitwerken.'
 },
 vtach_monomorphic: {
 signaturePattern: 'Regelmatige brede-complex tachycardie met uniforme QRS-morfologie.',
 looksLike: ['SVT met aberrantie', 'Sinustachycardie met bestaand bundeltakblok'],
 keyDistinguishers: ['Breed QRS in alle slagen', 'Vaak AV-dissociatie/capture- of fusion-beats', 'Bij twijfel behandelen als VT'],
 firstSafeStep: 'Beoordeel direct stabiliteit; instabiel = gesynchroniseerde cardioversie, stabiel = VT-pad en senior support.'
 },
 vtach_polymorphic: {
 signaturePattern: 'Breed-complex tachycardie met wisselende morfologie en as (torsades-context overwegen).',
 looksLike: ['Ventrikelfibrillatie', 'Artifact bij hoge ruis'],
 keyDistinguishers: ['QRS-vorm verandert beat-to-beat', 'Vaak context van QT-verlenging', 'Snelle progressie naar instabiliteit mogelijk'],
 firstSafeStep: 'Bij instabiliteit direct elektriciteitstherapie; corrigeer tegelijk QT-triggers en elektrolyten.'
 },
 deWinter: {
 signaturePattern: 'Upsloping ST-depressie precordiaal met prominente symmetrische T-golven en vaak lichte ST-elevatie in aVR.',
 looksLike: ['NSTEMI met diffuse ST-depressie', 'Vroege repolarisatie'],
 keyDistinguishers: ['Patroon is persisterend en territoriaal (voorwand)', 'Geen klassieke ST-elevatie maar wel occlusierisico', 'Kliniek van acute ischemie ondersteunt urgentie'],
 firstSafeStep: 'Behandel als STEMI-equivalent en activeer urgente coronairstrategie zonder vertraging.'
 },
 lbbb: {
 signaturePattern: 'Breed QRS met typische LBBB-morfologie waarbij ischemietekens gemaskeerd kunnen zijn.',
 looksLike: ['Ritmestrook met ventriculaire pacing', 'Aspecifieke intraventriculaire geleidingsvertraging'],
 keyDistinguishers: ['Brede/notched R in laterale afleidingen', 'Diepe S in V1-V3', 'ACS-diagnostiek vereist aanvullende criteria en kliniek'],
 firstSafeStep: 'Bij ischemische klachten: behandel als hoog-risico ACS en gebruik aanvullende criteria (o.a. Sgarbossa-context).'
 },
 wpw: {
 signaturePattern: 'Kort PR-interval met delta-golf en verbreed initieel QRS (pre-excitatie).',
 looksLike: ['Bundeltakblok', 'Ventriculaire ectopie met pre-excitatie-achtige opstart'],
 keyDistinguishers: ['Delta-golf aan begin van QRS', 'PR-interval verkort', 'Bij AF + WPW geen AV-knoopblokkers'],
 firstSafeStep: 'Beoordeel eerst of er instabiliteit of AF met pre-excitatie is; kies dan ritmespecifiek spoedpad.'
 },
 stemi_anterior: {
 signaturePattern: 'ST-elevatie in aangrenzende anterieure afleidingen (V1-V4) met reciprociteit mogelijk inferieur.',
 looksLike: ['Vroege repolarisatie', 'Pericarditis'],
 keyDistinguishers: ['Territoriaal patroon in aangrenzende leads', 'Dynamische ischemische klachten', 'Reciproke veranderingen versterken diagnose'],
 firstSafeStep: 'Activeer direct STEMI/reperfusiepad volgens regionale afspraken en lokaal protocol.'
 },
 stemi_inferior: {
 signaturePattern: 'ST-elevatie in II, III en aVF vaak met reciproke ST-depressie in I/aVL.',
 looksLike: ['Pericarditis', 'Benigne variant met inferieure ST-verhoging'],
 keyDistinguishers: ['Territoriale inferieure lead-clustering', 'Reciproke veranderingen ondersteunen ischemie', 'Denk aan rechterventrikelbetrokkenheid bij hypotensie'],
 firstSafeStep: 'Start acuut ACS-beleid en regel urgente reperfusiestrategie.'
 },
 stemi_lateral: {
 signaturePattern: 'ST-elevatie lateraal (I, aVL, V5-V6) met passend klinisch ischemiebeeld.',
 looksLike: ['Vroege repolarisatie', 'Niet-specifieke ST-T afwijkingen'],
 keyDistinguishers: ['Laterale lead-clustering', 'Klinische context van acute pijn', 'Reciproke afwijkingen in inferieure leads kunnen aanwezig zijn'],
 firstSafeStep: 'Behandel als STEMI en versnel coronair/reperfusiepad.'
 },
 stemi_posterior: {
 signaturePattern: 'Horizontale ST-depressie en hoge R in V1-V3 als spiegelbeeld van posterieure ST-elevatie.',
 looksLike: ['RBBB met secundaire ST-T veranderingen', 'Subendocardiale ischemie zonder occlusie'],
 keyDistinguishers: ['Spiegelbeeldpatroon anterieur', 'Posterieure afleidingen kunnen elevatie tonen', 'Meestal context van acute ischemie'],
 firstSafeStep: 'Interpreteer als STEMI-equivalent en behandel met urgente reperfusielogistiek.'
 }
 },
 rhythmGuidelineRefs: {
 atrial_fibrillation: 'ESC AF 2024: acute rate control bij stabiele AF en indicaties voor urgente cardioversie bij instabiliteit.',
 atrial_flutter: 'ESC AF 2024: flutter-benadering met rate/rhythm control en contextafhankelijke cardioversie.',
 svt: 'ESC SVT 2019: regelmatige smalcomplex tachycardie: vagale manoeuvres gevolgd door adenosine.',
 vtach_monomorphic: 'ESC VA 2022: brede-complex tachycardie als VT behandelen bij onzekerheid; instabiel -> gesynchroniseerde cardioversie.',
 vtach_polymorphic: 'ESC VA 2022: polymorfe VT vraagt urgente ritmespecifieke aanpak; bij instabiliteit onmiddellijke elektriciteitstherapie.',
 vfib: 'ERC/ALS 2025: schokbaar ritme, onmiddellijke defibrillatie en CPR-cycli volgens protocol.',
 asystole: 'ERC/ALS 2025: asystolie is niet-schokbaar; focus op CPR, adrenaline en reversibele oorzaken.',
 pea: 'ERC/ALS 2025: PEA is niet-schokbaar; behandel 4H/4T parallel aan hoogwaardige CPR.',
 stemi_anterior: 'ESC ACS 2023: STEMI-diagnostiek en snelle reperfusiestrategie binnen regionale streeftijden.',
 deWinter: 'de Winter review: STEMI-equivalent met urgente reperfusiebehoefte ondanks afwezigheid van klassieke ST-elevatie.',
 lbbb: 'ACC/ESC nuance: LBBB alleen is niet diagnostisch voor acute STEMI; gebruik aanvullende criteria en klinische context.',
 hyperkalemia: 'ERC/ALS 2025 + acute care principes: calcium eerst bij ECG-veranderingen, daarna kaliumverlagende therapie.',
 wpw: 'ESC SVT 2019: vermijd AV-knoopblokkers bij pre-excitatie met AF; specialistische benadering.'
 },
 caseQuestionGuidelineRefs: {
 case_chest_pain_q1: 'ESC ACS 2023: ECG-criteria en territoriale interpretatie bij STEMI.',
 case_chest_pain_q2: 'ESC ACS 2023: onmiddellijke reperfusielogistiek (PCI-first strategie).',
 case_syncope_q1: 'ESC Pacing 2021: herkenning compleet AV-blok met AV-dissociatie.',
 case_syncope_q2: 'ESC Pacing 2021: instabiele bradycardie/hooggradig blok -> tijdelijke pacingstrategie.',
 case_palpitations_q1: 'ESC SVT 2019: differentiaaldiagnose regelmatige smalcomplex tachycardie.',
 case_palpitations_q2: 'ESC SVT 2019: stapsgewijze acute behandeling met vagale manoeuvres en adenosine.',
 case_resuscitation_q1: 'ERC/ALS 2025: herkenning schokbaar arrest-ritme (VF/pVT).',
 case_resuscitation_q2: 'ERC/ALS 2025: eerste interventie bij schokbaar ritme is directe defibrillatie + CPR.',
 case_potassium_q1: 'ERC/ALS 2025: ECG-kenmerken van ernstige hyperkaliëmie.',
 case_potassium_q2: 'ERC/ALS 2025: calcium als eerste membraanstabilisatie bij hyperkaliëmie met ECG-afwijkingen.',
 case_af_rvr_q1: 'ESC AF 2024: ritmeherkenning AF op basis van onregelmatig-onregelmatig patroon.',
 case_af_rvr_q2: 'ESC AF 2024: eerste keus rate-control bij stabiele AF (beta-blokker/non-DHP CCB contextafhankelijk).',
 case_post_arrest_stemi_q1: 'ESC ACS 2023: STEMI-interpretatie en reperfusiebeleid in post-arrestcontext.',
 case_post_arrest_stemi_q2: 'ESC ACS 2023: onmiddellijke reperfusiestrategie bij STEMI.',
 case_sepsis_tachyarrhythmia_q1: 'ESC AF 2024: AF-diagnostiek in acute setting.',
 case_sepsis_tachyarrhythmia_q2: 'ESC AF 2024: rate-control en hemodynamische context.',
 case_intox_qt_q1: 'ESC VA 2022: lang QT en risico op polymorfe VT/torsades.',
 case_intox_qt_q2: 'ESC VA 2022: acute aanpak van torsadesrisico en triggercorrectie.',
 case_hypokalemia_qt_q1: 'ERC/ALS 2025: ECG-patronen en risicocontext bij elektrolytstoornissen.',
 case_hypokalemia_qt_q2: 'ERC/ALS 2025: vroege correctie van reversibele metabole oorzaken.',
 case_pacemaker_failure_q1: 'ESC Pacing 2021: herkenning van capture/sensing-problemen.',
 case_pacemaker_failure_q2: 'ESC Pacing 2021: acute overbrugging en urgente device-evaluatie.',
 case_dewinter_acs_q1: 'de Winter review: STEMI-equivalent patroon met hoge occlusiewaarde.',
 case_dewinter_acs_q2: 'ESC ACS 2023: hoog-risico ischemiepatronen vereisen urgente coronairstrategie.',
 case_unstable_brady_q1: 'ESC Pacing 2021: diagnostische kenmerken Mobitz II.',
 case_unstable_brady_q2: 'ERC/ALS 2025: instabiele bradycardie met pacing-escalatie.',
 case_wide_complex_tachy_q1: 'ESC VA 2022: brede-complex tachycardie als VT benaderen bij twijfel.',
 case_wide_complex_tachy_q2: 'ESC VA 2022: acute VT-aanpak op basis van stabiliteit.'
 },

 requiredSourceFields: ['title', 'url', 'publisher', 'publishedDate', 'accessedDate', 'evidenceLevel', 'keySection'],

 sectionClaims: [
 {
 claimId: 'acls_shockable_defib_energy',
 section: 'acls',
 claimText: 'Primair (ERC/ESC): gebruik fabrikantadviesenergie voor defibrillatie/cardioversie; bij onbekende instelling kies de hoogste aanbevolen energie. AHA-alternatief: zelfde apparaatgerichte benadering met energie-escalatie volgens algoritme. Volg lokaal protocol.',
 primarySourceId: 'erc_als_2025',
 altSourceId: 'aha_tachy_2025',
 conflictNote: 'Energie is apparaat- en golfvormafhankelijk; vaste Joule-waarde is niet universeel.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'acls_brady_atropine_dose',
 section: 'acls',
 claimText: 'Primair (ERC/ESC): atropine 500 mcg IV elke 3-5 min tot max 3 mg bij symptomatische bradycardie. AHA-alternatief: atropine 1 mg IV elke 3-5 min tot max 3 mg. Volg lokaal protocol.',
 primarySourceId: 'erc_als_2025',
 altSourceId: 'aha_brady_2025',
 conflictNote: 'Dosering verschilt tussen richtlijnfamilies; pacing-escalatie bij uitblijven respons blijft in beide leidend.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'acls_wide_complex_tachy',
 section: 'acls',
 claimText: 'Primair (ERC/ESC): behandel regelmatige brede-complex tachycardie als VT bij twijfel; instabiel direct gesynchroniseerde cardioversie. AHA-alternatief: vergelijkbaar instabiliteitspad met ritmespecifieke anti-aritmica bij stabiliteit. Volg lokaal protocol.',
 primarySourceId: 'esc_va_2022',
 altSourceId: 'aha_tachy_2025',
 conflictNote: 'Adenosine alleen in geselecteerde regelmatige monomorfe context; niet bij onregelmatige brede tachycardie.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'drug_adenosine_context',
 section: 'drugs',
 claimText: 'Primair (ERC/ESC): adenosine voor regelmatige smalcomplex tachycardie; selectief diagnostisch/therapeutisch bij regelmatige monomorfe brede tachycardie. AHA-alternatief: zelfde beperking tot regelmatige monomorfe context. Volg lokaal protocol.',
 primarySourceId: 'esc_svt_2019',
 altSourceId: 'aha_tachy_2025',
 conflictNote: 'Vermijd bij pre-excitatie met AF en andere situaties waar AV-knoopblokkade gevaarlijk kan zijn.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'drug_af_rate_control',
 section: 'drugs',
 claimText: 'Primair (ERC/ESC): eerste keus rate-control bij stabiele AF is meestal beta-blokker of non-DHP calciumantagonist; digoxine vooral in geselecteerde context. AHA-alternatief: vergelijkbare contextgestuurde rate-control met focus op hemodynamische toestand. Volg lokaal protocol.',
 primarySourceId: 'esc_af_2024',
 altSourceId: 'aha_tachy_2025',
 conflictNote: 'Geneesmiddelkeuze hangt af van LV-functie, bloeddruk, comorbiditeit en klinische setting.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'drug_wpw_af_avoid_avnodal',
 section: 'drugs',
 claimText: 'Primair (ERC/ESC): bij pre-excitatie (WPW) met AF geen AV-knoopblokkers (incl. adenosine, verapamil/diltiazem, digoxine, beta-blokkers). AHA-alternatief: dezelfde veiligheidswaarschuwing in acute tachy-algoritmen. Volg lokaal protocol.',
 primarySourceId: 'esc_svt_2019',
 altSourceId: 'aha_tachy_2025',
 conflictNote: 'AV-knoopblokkade kan geleiding via accessoire baan versnellen met risico op VF.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'criteria_lbbb_acs_nuance',
 section: 'criteria',
 claimText: 'Primair (ERC/ESC): nieuw LBBB is op zichzelf niet diagnostisch voor STEMI; combineer ECG met klachten, seriele veranderingen en aanvullende criteria. AHA/ACC-alternatief: vergelijkbare nuance met gebruik van aanvullende ischemiecriteria (zoals Sgarbossa-context). Volg lokaal protocol.',
 primarySourceId: 'esc_acs_2023',
 altSourceId: 'acc_lbbb_2017',
 conflictNote: 'Vermijd absolutisme: LBBB kan ischemie maskeren maar is niet automatisch STEMI.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'criteria_dewinter_equivalent',
 section: 'criteria',
 claimText: 'Primair (ERC/ESC): de Winter patroon is STEMI-equivalent en vereist urgente coronairstrategie. AHA-alternatief: dezelfde hoog-risico interpretatie als acute coronairocclusiecontext. Volg lokaal protocol.',
 primarySourceId: 'de_winter_2019',
 altSourceId: 'esc_acs_2023',
 conflictNote: 'Geen klassieke ST-elevatie sluit acute occlusie niet uit.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'criteria_stemi_thresholds',
 section: 'criteria',
 claimText: 'Primair (ERC/ESC): STEMI-drempels gebruiken afleiding- en geslacht/leeftijdspecifieke ST-elevatiecriteria in combinatie met kliniek. Volg lokaal protocol.',
 primarySourceId: 'esc_acs_2023',
 conflictNote: 'Interpretatie vereist context en seriele ECG-beoordeling.',
 lastReviewed: '2026-02-16'
 },
 {
 claimId: 'drug_hyperkalemia_first_calcium',
 section: 'drugs',
 claimText: 'Primair (ERC/ESC): bij hyperkaliemie met ECG-veranderingen start met IV-calcium voor membraanstabilisatie, daarna kaliumverlagende therapie. Volg lokaal protocol.',
 primarySourceId: 'erc_als_2025',
 conflictNote: 'Calcium stabiliseert myocard direct; kaliumdaling volgt in vervolgstappen.',
 lastReviewed: '2026-02-16'
 }
 ],

 legacyCaseMetadata: {
 case_chest_pain: {
 moduleId: 'module_6',
 learningObjectives: [
 'Herken een anterieur STEMI-patroon met territoriale correlatie',
 'Start direct reperfusielogistiek zonder diagnostische vertraging'
 ],
 debrief: 'Bij STEMI is tijdkritische reperfusie leidend; biomarkeruitslagen mogen urgent beleid niet vertragen.'
 },
 case_syncope: {
 moduleId: 'module_4',
 learningObjectives: [
 'Herken compleet AV-blok met AV-dissociatie',
 'Kies tijdige pacing-escalatie bij symptomatische instabiliteit'
 ],
 debrief: 'Bij hooggradige geleidingsstoornissen met instabiliteit staat pacingoverbrugging centraal; alleen medicamenteus beleid is vaak onvoldoende.'
 },
 case_palpitations: {
 moduleId: 'module_3',
 learningObjectives: [
 'Herken regelmatige smalcomplex SVT en differentieer van andere tachycardieen',
 'Pas de stapsgewijze acute behandeling veilig toe'
 ],
 debrief: 'Bij stabiele regelmatige smalcomplex tachycardie volgt behandeling een vaste volgorde: vagale manoeuvres, daarna adenosine in de juiste context.'
 },
 case_resuscitation: {
 moduleId: 'module_5',
 learningObjectives: [
 'Herken een schokbaar arrest-ritme op monitor/ECG',
 'Voer de eerste ALS-cyclus zonder vertraging uit'
 ],
 debrief: 'Bij VF/pVT bepaalt snelheid van defibrillatie de uitkomst; organiseer interventies rond ononderbroken kwaliteits-CPR.'
 },
 case_potassium: {
 moduleId: 'module_7',
 learningObjectives: [
 'Herken ECG-veranderingen passend bij klinisch relevante hyperkaliemie',
 'Prioriteer membraanstabilisatie voor kaliumverlaging'
 ],
 debrief: 'Bij hyperkaliemie met ECG-afwijkingen gaat cardiale membraanstabilisatie met calcium voor op verdere kaliumeliminatie.'
 },
 case_af_rvr: {
 moduleId: 'module_3',
 learningObjectives: [
 'Herken AF met snelle ventrikelrespons in acute setting',
 'Kies contextafhankelijke rate-control als eerste stap bij stabiliteit'
 ],
 debrief: 'Bij stabiele AF met snelle respons is rate-control meestal eerste keuze; ritmecontrole en antistolling volgen op basis van klinische context.'
 }
 },

 isNonEmptyString(value) {
 return typeof value === 'string' && value.trim().length > 0;
 },

 normalizeText(value) {
 return String(value || '').replace(/\s+/g, ' ').trim();
 },

 hasConflictPresentation(text) {
 const normalized = this.normalizeText(text);
 const hasPrimary = normalized.includes('Primair (ERC/ESC):');
 const hasAlternative = normalized.includes('AHA-alternatief:') || normalized.includes('AHA/ACC-alternatief:') || normalized.includes('Alternatief:');
 const hasProtocolNote = normalized.includes('Volg lokaal protocol.');
 return hasPrimary && hasAlternative && hasProtocolNote;
 },

 getSectionClaims() {
 return Array.isArray(this.sectionClaims) ? this.sectionClaims : [];
 },

 getSource(sourceId) {
 if (sourceId && MedicalSourceRegistry[sourceId]) return MedicalSourceRegistry[sourceId];
 return MedicalSourceRegistry.erc_als_2025;
 },

 getGuidelineReferenceForRhythm(rhythm) {
 if (!rhythm) return '';
 if (rhythm.guidelineRef) return rhythm.guidelineRef;
 if (this.rhythmGuidelineRefs[rhythm.id]) return this.rhythmGuidelineRefs[rhythm.id];
 const src = this.getSource(rhythm.sourceId || this.getSourceIdForRhythm(rhythm));
 return src.keySection || '';
 },

 getGuidelineReferenceForQuestion(caseId, questionIndex, question) {
 const key = `${caseId}_q${questionIndex + 1}`;
 if (question?.guidelineRef) return question.guidelineRef;
 if (this.caseQuestionGuidelineRefs[key]) return this.caseQuestionGuidelineRefs[key];
 const src = this.getSource(question?.sourceId || 'erc_als_2025');
 return src.keySection || '';
 },

 getSourceIdForRhythm(rhythm) {
 if (!rhythm) return 'erc_als_2025';
 return this.rhythmSourceOverrides[rhythm.id] || this.categorySourceMap[rhythm.category] || 'erc_als_2025';
 },

 buildWhyCorrect(rhythm) {
 const features = Array.isArray(rhythm?.ecgFeatures) ? rhythm.ecgFeatures.filter(Boolean) : [];
 if (features.length >= 2) {
 return `Diagnose past bij ${rhythm.name} door combinatie van ${features[0].toLowerCase()} en ${features[1].toLowerCase()}.`;
 }
 if (features.length === 1) {
 return `Diagnose past bij ${rhythm.name} op basis van kernkenmerk: ${features[0].toLowerCase()}.`;
 }
 return `Diagnose past bij ${rhythm?.name || 'dit ritme'} door systematische beoordeling van ritmeregelmaat, QRS-breedte en P-QRS-relatie.`;
 },

 buildSourceNoteForRhythm(rhythm) {
 if (!rhythm) return 'Richtlijnmodus: ERC/ESC default; volg lokaal protocol.';
 if (rhythm.id === 'svt' || rhythm.id === 'vtach_monomorphic' || rhythm.id === 'vtach_polymorphic') {
 return 'Primair (ERC/ESC): adenosine alleen bij regelmatige ritmes; bij brede tachycardie behandel als VT bij twijfel. AHA-alternatief: adenosine uitsluitend in regelmatige monomorfe context. Volg lokaal protocol.';
 }
 if (rhythm.category === 'bradycardia' || String(rhythm.id || '').startsWith('avblock_')) {
 return 'Primair (ERC/ESC): atropine 500 mcg IV elke 3-5 min (max 3 mg) bij symptomatische bradycardie, daarna pacing/escalatie. AHA-alternatief: atropine 1 mg IV elke 3-5 min (max 3 mg). Volg lokaal protocol.';
 }
 if (rhythm.id === 'lbbb') {
 return 'Primair (ERC/ESC): nieuw LBBB is niet op zichzelf diagnostisch voor STEMI. AHA/ACC-alternatief: zelfde nuance met aanvullende ischemiecriteria. Volg lokaal protocol.';
 }
 if (rhythm.id === 'deWinter') {
 return 'Primair (ERC/ESC): de Winter-patroon behandelen als STEMI-equivalent met urgente reperfusiestrategie. AHA-alternatief: vergelijkbare hoog-risico interpretatie. Volg lokaal protocol.';
 }
 if (rhythm.id === 'atrial_fibrillation') {
 return 'Primair (ERC/ESC): rate-control bij stabiele AF meestal met beta-blokker/non-DHP calciumantagonist; digoxine contextafhankelijk. AHA-alternatief: vergelijkbare contextgestuurde aanpak. Volg lokaal protocol.';
 }
 if (rhythm.id === 'vfib' || rhythm.id === 'stemi_anterior' || rhythm.id === 'stemi_inferior' || rhythm.id === 'stemi_lateral' || rhythm.id === 'stemi_posterior') {
 return 'Primair (ERC/ESC): gebruik fabrikantadviesenergie voor schoktherapie en escaleer volgens apparaat/protocol. AHA-alternatief: zelfde apparaatgerichte energiebenadering. Volg lokaal protocol.';
 }
 return 'Richtlijnmodus: ERC/ESC default; volg lokaal protocol.';
 },

 normalizeUniqueStrings(values, min = 0, fallback = []) {
 const unique = [];
 (Array.isArray(values) ? values : []).forEach(item => {
 if (!this.isNonEmptyString(item)) return;
 const normalized = item.trim();
 if (unique.includes(normalized)) return;
 unique.push(normalized);
 });
 (Array.isArray(fallback) ? fallback : []).forEach(item => {
 if (unique.length >= min) return;
 if (!this.isNonEmptyString(item)) return;
 const normalized = item.trim();
 if (unique.includes(normalized)) return;
 unique.push(normalized);
 });
 return unique;
 },

 buildSignaturePattern(rhythm) {
 const features = Array.isArray(rhythm?.ecgFeatures) ? rhythm.ecgFeatures.filter(f => this.isNonEmptyString(f)) : [];
 if (features.length >= 2) {
 return `${features[0]}; ${features[1]}.`;
 }
 if (features.length === 1) {
 return features[0];
 }
 if (this.isNonEmptyString(rhythm?.whyCorrect)) {
 return rhythm.whyCorrect;
 }
 return `Patroon passend bij ${rhythm?.name || 'dit ritme'}; bevestig met systematische analyse over meerdere afleidingen.`;
 },

 buildLooksLike(rhythm) {
 const names = [];
 const pushName = (name) => {
 if (!this.isNonEmptyString(name)) return;
 const normalized = name.trim();
 if (!names.includes(normalized)) names.push(normalized);
 };

 (rhythm.lookalikes || []).forEach(item => {
 const name = ECGDatabase.getRhythmById(item?.id)?.name;
 pushName(name);
 });
 (rhythm.differentialIds || []).forEach(id => {
 const name = ECGDatabase.getRhythmById(id)?.name;
 pushName(name);
 });
 ECGDatabase.getRhythmsByCategory(rhythm.category)
 .filter(item => item.id !== rhythm.id)
 .slice(0, 3)
 .forEach(item => pushName(item.name));

 if (!names.length) {
 pushName('Nabijliggende ritmes in dezelfde categorie');
 }
 return names.slice(0, 3);
 },

 buildKeyDistinguishers(rhythm) {
 const distinguishers = [];
 const push = (value) => {
 if (!this.isNonEmptyString(value)) return;
 const normalized = value.trim();
 if (!distinguishers.includes(normalized)) {
 distinguishers.push(normalized);
 }
 };

 (Array.isArray(rhythm.keyDistinguishers) ? rhythm.keyDistinguishers : []).forEach(push);
 (Array.isArray(rhythm.ecgFeatures) ? rhythm.ecgFeatures : []).slice(0, 3).forEach(push);

 if (this.isNonEmptyString(rhythm?.characteristics?.rhythm)) {
 push(`Ritmeprofiel: ${rhythm.characteristics.rhythm}`);
 }
 if (this.isNonEmptyString(rhythm?.characteristics?.pWave)) {
 push(`P-golfcontext: ${rhythm.characteristics.pWave}`);
 }
 const qrs = rhythm?.characteristics?.qrsComplex;
 if (this.isNonEmptyString(qrs)) {
 push(`QRS-context: ${qrs}`);
 } else if (qrs && typeof qrs === 'object') {
 const qrsText = `${qrs.min || '?'}-${qrs.max || '?'} ${qrs.unit || 'ms'}`.trim();
 push(`QRS-context: ${qrsText}`);
 }

 const fallback = [
 'Beoordeel ritmeregelmaat over meerdere slagen.',
 'Meet QRS-breedte in meerdere afleidingen.',
 'Controleer de relatie tussen P-golven en QRS-complexen.'
 ];
 return this.normalizeUniqueStrings(distinguishers, 2, fallback).slice(0, 4);
 },

 buildFirstSafeStep(rhythm) {
 if (this.isNonEmptyString(rhythm?.firstAction)) return rhythm.firstAction;
 return 'Start met hemodynamische beoordeling en volg direct het passende lokale protocol.';
 },

 ensureRhythmMetadata() {
 ECGDatabase.getAllRhythms().forEach(rhythm => {
 if (this.rhythmWhyOverrides[rhythm.id]) {
 rhythm.whyCorrect = this.rhythmWhyOverrides[rhythm.id];
 } else if (!this.isNonEmptyString(rhythm.whyCorrect)) {
 rhythm.whyCorrect = this.buildWhyCorrect(rhythm);
 }

 if (!rhythm.sourceId || !MedicalSourceRegistry[rhythm.sourceId]) {
 rhythm.sourceId = this.getSourceIdForRhythm(rhythm);
 }

 const preferredNote = this.buildSourceNoteForRhythm(rhythm);
 if (!this.isNonEmptyString(rhythm.sourceNote)) {
 rhythm.sourceNote = preferredNote;
 } else if (preferredNote.includes('Primair (ERC/ESC):') && !this.hasConflictPresentation(rhythm.sourceNote)) {
 rhythm.sourceNote = preferredNote;
 }

 if (!this.isNonEmptyString(rhythm.guidelineRef)) {
 rhythm.guidelineRef = this.getGuidelineReferenceForRhythm(rhythm);
 }

 const differentiationOverride = this.rhythmDifferentiationOverrides[rhythm.id] || {};
 rhythm.signaturePattern = this.isNonEmptyString(differentiationOverride.signaturePattern)
 ? differentiationOverride.signaturePattern
 : (this.isNonEmptyString(rhythm.signaturePattern) ? rhythm.signaturePattern : this.buildSignaturePattern(rhythm));

 const looksLikeInput = Array.isArray(differentiationOverride.looksLike) && differentiationOverride.looksLike.length
 ? differentiationOverride.looksLike
 : (Array.isArray(rhythm.looksLike) && rhythm.looksLike.length ? rhythm.looksLike : this.buildLooksLike(rhythm));
 rhythm.looksLike = this.normalizeUniqueStrings(looksLikeInput, 1, this.buildLooksLike(rhythm)).slice(0, 3);

 const distinguisherInput = Array.isArray(differentiationOverride.keyDistinguishers) && differentiationOverride.keyDistinguishers.length
 ? differentiationOverride.keyDistinguishers
 : this.buildKeyDistinguishers(rhythm);
 rhythm.keyDistinguishers = this.normalizeUniqueStrings(distinguisherInput, 2, this.buildKeyDistinguishers(rhythm)).slice(0, 4);

 rhythm.firstSafeStep = this.isNonEmptyString(differentiationOverride.firstSafeStep)
 ? differentiationOverride.firstSafeStep
 : (this.isNonEmptyString(rhythm.firstSafeStep) ? rhythm.firstSafeStep : this.buildFirstSafeStep(rhythm));
 });
 },

 ensureCaseMetadata() {
 if (typeof ClinicalCases === 'undefined' || !ClinicalCases?.getAllCases) return;
 const fallbackObjectives = [
 'Pas een systematische ECG-analyse toe op deze casus',
 'Koppel ECG-bevindingen aan een eerste veilige klinische stap'
 ];

 ClinicalCases.getAllCases().forEach(caseData => {
 const legacy = this.legacyCaseMetadata[caseData.id];
 if (!this.isNonEmptyString(caseData.moduleId)) {
 caseData.moduleId = legacy?.moduleId || 'module_8';
 }

 if (!Array.isArray(caseData.learningObjectives)) {
 caseData.learningObjectives = legacy?.learningObjectives ? [...legacy.learningObjectives] : [...fallbackObjectives];
 }

 caseData.learningObjectives = caseData.learningObjectives
 .filter(obj => this.isNonEmptyString(obj));

 if (caseData.learningObjectives.length < 2) {
 const seed = legacy?.learningObjectives ? [...legacy.learningObjectives] : [...fallbackObjectives];
 seed.forEach(item => {
 if (caseData.learningObjectives.length >= 2) return;
 if (this.isNonEmptyString(item) && !caseData.learningObjectives.includes(item)) {
 caseData.learningObjectives.push(item);
 }
 });
 }

 if (!this.isNonEmptyString(caseData.debrief)) {
 caseData.debrief = legacy?.debrief || 'Koppel ECG-interpretatie altijd aan hemodynamiek en volg lokale protocollen.';
 }
 });
 },

 ensureCaseQuestionSources() {
 if (typeof ClinicalCases === 'undefined' || !ClinicalCases?.getAllCases) return;
 this.ensureCaseMetadata();

 const map = {
 case_chest_pain: ['esc_acs_2023', 'esc_acs_2023'],
 case_syncope: ['esc_pacing_2021', 'erc_als_2025'],
 case_palpitations: ['esc_svt_2019', 'esc_svt_2019'],
 case_resuscitation: ['erc_als_2025', 'erc_als_2025'],
 case_potassium: ['erc_als_2025', 'erc_als_2025'],
 case_af_rvr: ['esc_af_2024', 'esc_af_2024'],
 case_post_arrest_stemi: ['esc_acs_2023', 'esc_acs_2023'],
 case_sepsis_tachyarrhythmia: ['esc_af_2024', 'esc_af_2024'],
 case_intox_qt: ['esc_va_2022', 'esc_va_2022'],
 case_hypokalemia_qt: ['erc_als_2025', 'erc_als_2025'],
 case_pacemaker_failure: ['esc_pacing_2021', 'esc_pacing_2021'],
 case_dewinter_acs: ['de_winter_2019', 'esc_acs_2023'],
 case_unstable_brady: ['esc_pacing_2021', 'erc_als_2025'],
 case_wide_complex_tachy: ['esc_va_2022', 'esc_va_2022']
 };

 ClinicalCases.getAllCases().forEach(caseData => {
 caseData.questions.forEach((q, idx) => {
 if (!this.isNonEmptyString(q.type)) {
 q.type = idx === 0 ? 'recognition' : idx === 1 ? 'first_action' : 'differential';
 }
 if (idx === 0 && !['recognition', 'differential'].includes(q.type)) {
 q.type = 'recognition';
 }
 if (idx === 1 && q.type !== 'first_action') {
 q.type = 'first_action';
 }

 if (!q.sourceId || !MedicalSourceRegistry[q.sourceId]) {
 q.sourceId = map[caseData.id]?.[idx] || map[caseData.id]?.[0] || 'erc_als_2025';
 }

 if (!this.isNonEmptyString(q.explanation)) {
 q.explanation = 'Beoordeel ritme systematisch en volg lokale protocollen.';
 }

 if (!this.isNonEmptyString(q.guidelineRef)) {
 q.guidelineRef = this.getGuidelineReferenceForQuestion(caseData.id, idx, q);
 }
 });
 });
 },

 validateSourceRegistry() {
 const missingFieldIssues = [];
 const invalidUrls = [];
 const invalidDateIssues = [];

 Object.entries(MedicalSourceRegistry).forEach(([sourceId, source]) => {
 this.requiredSourceFields.forEach(field => {
 if (!this.isNonEmptyString(source?.[field])) {
 missingFieldIssues.push({ sourceId, field });
 }
 });

 if (typeof source?.url !== 'string' || !source.url.startsWith('https://')) {
 invalidUrls.push(sourceId);
 }

 ['publishedDate', 'accessedDate'].forEach(dateField => {
 const value = source?.[dateField];
 if (this.isNonEmptyString(value) && Number.isNaN(Date.parse(value))) {
 invalidDateIssues.push({ sourceId, field: dateField, value });
 }
 });
 });

 return {
 missingFieldIssues,
 invalidUrls,
 invalidDateIssues
 };
 },

 validateRhythmCompleteness() {
 this.ensureRhythmMetadata();
 const rhythms = ECGDatabase.getAllRhythms();
 const requiredFields = ['whyCorrect', 'sourceId', 'guidelineRef', 'firstAction', 'firstActionWhy', 'escalationCue', 'signaturePattern', 'firstSafeStep'];
 const missingFieldDetails = [];
 const depthIssues = [];

 rhythms.forEach(rhythm => {
 requiredFields.forEach(field => {
 if (!this.isNonEmptyString(rhythm?.[field])) {
 missingFieldDetails.push({ id: rhythm.id, field });
 }
 });

 const pitfallCount = Array.isArray(rhythm.pitfalls)
 ? rhythm.pitfalls.filter(item => this.isNonEmptyString(item)).length
 : 0;
 if (pitfallCount < 2) {
 depthIssues.push({ id: rhythm.id, issue: 'pitfalls_lt_2' });
 }

 const hasLookalike = Array.isArray(rhythm.lookalikes)
 && rhythm.lookalikes.some(item => this.isNonEmptyString(item?.id) && this.isNonEmptyString(item?.whyWrong));
 if (!hasLookalike) {
 depthIssues.push({ id: rhythm.id, issue: 'lookalike_missing' });
 }

 const looksLikeCount = Array.isArray(rhythm.looksLike)
 ? rhythm.looksLike.filter(item => this.isNonEmptyString(item)).length
 : 0;
 if (looksLikeCount < 1) {
 depthIssues.push({ id: rhythm.id, issue: 'looksLike_missing' });
 }

 const keyDistinguishersCount = Array.isArray(rhythm.keyDistinguishers)
 ? rhythm.keyDistinguishers.filter(item => this.isNonEmptyString(item)).length
 : 0;
 if (keyDistinguishersCount < 2) {
 depthIssues.push({ id: rhythm.id, issue: 'keyDistinguishers_lt_2' });
 }

 if ((rhythm.urgency === 'high' || rhythm.urgency === 'critical')) {
 const redFlagCount = Array.isArray(rhythm.redFlags)
 ? rhythm.redFlags.filter(item => this.isNonEmptyString(item)).length
 : 0;
 if (redFlagCount < 1) {
 depthIssues.push({ id: rhythm.id, issue: 'high_risk_redflag_missing' });
 }
 }
 });

 return {
 total: rhythms.length,
 missingFieldDetails,
 depthIssues
 };
 },

 validateCaseCompleteness() {
 this.ensureCaseMetadata();
 this.ensureCaseQuestionSources();
 const requiredQuestionFields = ['type', 'explanation', 'sourceId', 'guidelineRef'];
 const caseMetadataIssues = [];
 const missingQuestionFields = [];
 const typeRuleIssues = [];
 const cases = (typeof ClinicalCases !== 'undefined' && ClinicalCases?.getAllCases)
 ? ClinicalCases.getAllCases()
 : [];

 cases.forEach(caseData => {
 if (!this.isNonEmptyString(caseData.moduleId)) {
 caseMetadataIssues.push({ caseId: caseData.id, field: 'moduleId' });
 }
 const objectives = Array.isArray(caseData.learningObjectives)
 ? caseData.learningObjectives.filter(item => this.isNonEmptyString(item))
 : [];
 if (objectives.length < 2) {
 caseMetadataIssues.push({ caseId: caseData.id, field: 'learningObjectives' });
 }
 if (!this.isNonEmptyString(caseData.debrief)) {
 caseMetadataIssues.push({ caseId: caseData.id, field: 'debrief' });
 }

 (caseData.questions || []).forEach((question, idx) => {
 requiredQuestionFields.forEach(field => {
 if (field === 'sourceId') {
 if (!this.isNonEmptyString(question.sourceId) || !MedicalSourceRegistry[question.sourceId]) {
 missingQuestionFields.push({ questionId: `${caseData.id}_q${idx + 1}`, field });
 }
 } else if (!this.isNonEmptyString(question[field])) {
 missingQuestionFields.push({ questionId: `${caseData.id}_q${idx + 1}`, field });
 }
 });

 if (idx === 0 && !['recognition', 'differential'].includes(question.type)) {
 typeRuleIssues.push({ questionId: `${caseData.id}_q${idx + 1}`, expected: 'recognition|differential', actual: question.type || '' });
 }
 if (idx === 1 && question.type !== 'first_action') {
 typeRuleIssues.push({ questionId: `${caseData.id}_q${idx + 1}`, expected: 'first_action', actual: question.type || '' });
 }
 });
 });

 return {
 totalCases: cases.length,
 totalQuestions: cases.reduce((sum, c) => sum + ((c.questions || []).length), 0),
 caseMetadataIssues,
 missingQuestionFields,
 typeRuleIssues
 };
 },

 validateSectionClaims() {
 const issues = [];
 const conflictIssues = [];
 const claims = this.getSectionClaims();

 claims.forEach(claim => {
 if (!this.isNonEmptyString(claim.claimId)) {
 issues.push({ claimId: '(missing)', issue: 'claim_id_missing' });
 }
 if (!this.isNonEmptyString(claim.claimText)) {
 issues.push({ claimId: claim.claimId || '(missing)', issue: 'claim_text_missing' });
 }
 if (!this.isNonEmptyString(claim.primarySourceId) || !MedicalSourceRegistry[claim.primarySourceId]) {
 issues.push({ claimId: claim.claimId || '(missing)', issue: 'primary_source_missing_or_invalid' });
 }
 if (this.isNonEmptyString(claim.altSourceId) && !MedicalSourceRegistry[claim.altSourceId]) {
 issues.push({ claimId: claim.claimId || '(missing)', issue: 'alt_source_invalid' });
 }
 if (!this.isNonEmptyString(claim.lastReviewed) || Number.isNaN(Date.parse(claim.lastReviewed))) {
 issues.push({ claimId: claim.claimId || '(missing)', issue: 'last_reviewed_invalid' });
 }
 if (this.isNonEmptyString(claim.altSourceId) && !this.hasConflictPresentation(claim.claimText)) {
 conflictIssues.push({ claimId: claim.claimId, issue: 'conflict_presentation_missing' });
 }
 });

 return {
 total: claims.length,
 issues,
 conflictIssues
 };
 },

 validateConflictPresentation() {
 const issues = [];

 const lbbb = ECGDatabase.getRhythmById('lbbb');
 const lbbbText = this.normalizeText(`${lbbb?.treatment || ''} ${lbbb?.clinicalPearl || ''}`).toLowerCase();
 if (lbbb && !(lbbbText.includes('geen') || lbbbText.includes('niet'))) {
 issues.push('lbbb_requires_non_absolute_stemi_nuance');
 }

 const deWinter = ECGDatabase.getRhythmById('deWinter');
 const deWinterText = this.normalizeText(`${deWinter?.treatment || ''} ${deWinter?.clinicalPearl || ''}`).toLowerCase();
 if (deWinter && !(deWinterText.includes('equivalent') && (deWinterText.includes('occlus') || deWinterText.includes('stemi')))) {
 issues.push('dewinter_requires_occlusion_equivalent_wording');
 }

 const svt = ECGDatabase.getRhythmById('svt');
 const svtText = this.normalizeText(`${svt?.treatment || ''} ${svt?.warning || ''}`).toLowerCase();
 if (svt && !(svtText.includes('regelmatige') && svtText.includes('adenosine'))) {
 issues.push('adenosine_context_not_specific_enough');
 }

 const af = ECGDatabase.getRhythmById('atrial_fibrillation');
 const afText = this.normalizeText(af?.treatment || '').toLowerCase();
 if (af && afText.includes('digoxine') && !(afText.includes('geselect') || afText.includes('context') || afText.includes('hartfalen'))) {
 issues.push('af_rate_control_needs_digoxin_context');
 }

 const vfib = ECGDatabase.getRhythmById('vfib');
 const vfibText = this.normalizeText(vfib?.treatment || '').toLowerCase();
 if (vfib && !vfibText.includes('fabrikant')) {
 issues.push('defib_energy_requires_manufacturer_wording');
 }

 const wpw = ECGDatabase.getRhythmById('wpw');
 const wpwText = this.normalizeText(`${wpw?.treatment || ''} ${wpw?.warning || ''}`).toLowerCase();
 if (wpw && !(wpwText.includes('geen av-knoop') || wpwText.includes('vermijd av-knoop'))) {
 issues.push('wpw_af_requires_av_nodal_blocker_warning');
 }

 return { issues };
 },

 buildAuditMatrix() {
 const matrix = [];
 const rhythmValidation = this.validateRhythmCompleteness();
 const caseValidation = this.validateCaseCompleteness();
 const sectionValidation = this.validateSectionClaims();

 const missingRhythmIds = new Set(rhythmValidation.missingFieldDetails.map(item => item.id));
 const depthRhythmIds = new Set(rhythmValidation.depthIssues.map(item => item.id));
 const missingQuestionIds = new Set(caseValidation.missingQuestionFields.map(item => item.questionId));
 const typeIssueQuestionIds = new Set(caseValidation.typeRuleIssues.map(item => item.questionId));
 const claimIssueIds = new Set(sectionValidation.issues.map(item => item.claimId));
 const claimConflictIds = new Set(sectionValidation.conflictIssues.map(item => item.claimId));

 ECGDatabase.getAllRhythms().forEach(rhythm => {
 const hasMissing = missingRhythmIds.has(rhythm.id);
 const hasDepthIssue = depthRhythmIds.has(rhythm.id);
 matrix.push({
 unitType: 'rhythm',
 id: rhythm.id,
 status: hasMissing ? 'needs-source' : hasDepthIssue ? 'rewrite' : 'ok',
 sourceId: rhythm.sourceId || '',
 changeReason: hasMissing
 ? 'Verplichte bron- of uitlegvelden ontbreken'
 : hasDepthIssue
 ? 'Didactische verdieping (pitfalls/lookalikes/red flags) aanscherpen'
 : 'Volledig gekoppeld en gevalideerd'
 });
 });

 if (typeof ClinicalCases !== 'undefined' && ClinicalCases?.getAllCases) {
 ClinicalCases.getAllCases().forEach(caseData => {
 caseData.questions.forEach((q, idx) => {
 const qId = `${caseData.id}_q${idx + 1}`;
 const hasMissing = missingQuestionIds.has(qId);
 const hasTypeIssue = typeIssueQuestionIds.has(qId);
 matrix.push({
 unitType: 'caseQuestion',
 id: qId,
 status: hasMissing ? 'needs-source' : hasTypeIssue ? 'rewrite' : 'ok',
 sourceId: q.sourceId || '',
 changeReason: hasMissing
 ? 'Casevraag mist bron/uitleg/metadata'
 : hasTypeIssue
 ? 'Vraagtype klopt niet met leerdoelvolgorde'
 : 'Casevraag volledig met bron en rationale'
 });
 });
 });
 }

 this.getSectionClaims().forEach(claim => {
 const unitType = claim.section === 'acls'
 ? 'aclsClaim'
 : claim.section === 'drugs'
 ? 'drugClaim'
 : 'criteriaClaim';
 const hasIssue = claimIssueIds.has(claim.claimId);
 const hasConflictIssue = claimConflictIds.has(claim.claimId);
 matrix.push({
 unitType,
 id: claim.claimId,
 status: hasIssue ? 'needs-source' : hasConflictIssue ? 'conflict-note-required' : 'ok',
 sourceId: claim.primarySourceId || '',
 changeReason: hasIssue
 ? 'Claimregistratie onvolledig of bron ontbreekt'
 : hasConflictIssue
 ? 'Conflictformat ontbreekt (primair/alternatief/protocolnoot)'
 : 'Sectieclaim gelinkt en conflictpresentatie akkoord'
 });
 });

 return matrix;
 },

 validateCoverage() {
 this.ensureRhythmMetadata();
 this.ensureCaseMetadata();
 this.ensureCaseQuestionSources();

 const rhythms = ECGDatabase.getAllRhythms();
 const cases = (typeof ClinicalCases !== 'undefined' && ClinicalCases?.getAllCases)
 ? ClinicalCases.getAllCases()
 : [];

 const sourceValidation = this.validateSourceRegistry();
 const rhythmValidation = this.validateRhythmCompleteness();
 const caseValidation = this.validateCaseCompleteness();
 const sectionValidation = this.validateSectionClaims();
 const conflictValidation = this.validateConflictPresentation();

 const missingRhythmIds = new Set(rhythmValidation.missingFieldDetails.map(item => item.id));

 return {
 rhythmTotal: rhythms.length,
 missingRhythm: missingRhythmIds.size,
 rhythmDepthIssues: rhythmValidation.depthIssues.length,
 caseTotal: cases.length,
 caseQuestionTotal: caseValidation.totalQuestions,
 missingQuestions: caseValidation.missingQuestionFields.length,
 caseMetaMissing: caseValidation.caseMetadataIssues.length,
 caseTypeViolations: caseValidation.typeRuleIssues.length,
 invalidUrls: sourceValidation.invalidUrls,
 sourceFieldIssues: sourceValidation.missingFieldIssues.length + sourceValidation.invalidDateIssues.length,
 sectionClaimTotal: sectionValidation.total,
 sectionClaimIssues: sectionValidation.issues.length,
 conflictPresentationIssues: sectionValidation.conflictIssues.length + conflictValidation.issues.length,
 conflictCoverageIssues: conflictValidation.issues,
 criticalIssues:
 missingRhythmIds.size +
 caseValidation.missingQuestionFields.length +
 sourceValidation.invalidUrls.length +
 sectionValidation.issues.length +
 sectionValidation.conflictIssues.length +
 conflictValidation.issues.length
 };
 } };

 // Add structured learning metadata for richer feedback cards.
 (() => {
 const overrides = {
 atrial_fibrillation: {
 pitfalls: ['Onregelmatigheid onderschatten bij snelle rate', 'Flutter met variabele geleiding verwarren met AF'],
 redFlags: ['Hemodynamische instabiliteit', 'Pre-excitatie (WPW) met snelle onregelmatige brede complexen'],
 lookalikes: [{ id: 'atrial_flutter', whyWrong: 'Flutter heeft vaak zaagtandactiviteit en meestal een georganiseerder patroon.' }]
 },
 atrial_flutter: {
 pitfalls: ['2:1 geleiding missen waardoor ritme op sinus/SVT lijkt', 'Fluttergolven niet actief zoeken in inferieure afleidingen'],
 redFlags: ['Snelle ventriculaire geleiding met hypotensie'],
 lookalikes: [{ id: 'atrial_fibrillation', whyWrong: 'AF is onregelmatig-onregelmatig; flutter toont vaker een regelmatiger geleidingspatroon.' }]
 },
 vtach_monomorphic: {
 pitfalls: ['SVT met aberrantie te snel aannemen', 'Capture/fusion beats niet herkennen'],
 redFlags: ['Instabiliteit, ischemie of tekenen van shock'],
 lookalikes: [{ id: 'svt', whyWrong: 'SVT is meestal smalcomplex; bij brede regelmatige tachycardie geldt VT tot het tegendeel bewezen is.' }]
 },
 vtach_polymorphic: {
 pitfalls: ['Polymorfe VT verwarren met artefact of VF', 'QT-context niet meenemen (torsades-risico)'],
 redFlags: ['Instabiliteit of bewustzijnsverlies: directe elektriciteitstherapie']
 },
 vfib: {
 pitfalls: ['Asystolie verwarren met fijne VF', 'Defibrillatie onnodig uitstellen voor extra diagnostiek'],
 redFlags: ['Direct schokbaar ritme: defibrillatie + CPR zonder vertraging']
 },
 asystole: {
 pitfalls: ['Pseudonasystolie door losse elektroden/lead-fout', 'Fijne VF niet uitsluiten in meerdere afleidingen'],
 redFlags: ['Niet-schokbaar ritme: focus op CPR, adrenaline en reversibele oorzaken']
 },
 deWinter: {
 pitfalls: ['Geen klassieke ST-elevatie dus onderschatting van ernst', 'Alleen op troponine wachten zonder urgente coronairstrategie'],
 redFlags: ['STEMI-equivalent: behandel als acute coronairocclusie']
 },
 lbbb: {
 pitfalls: ['Nieuw LBBB als op zichzelf diagnostisch voor STEMI beschouwen', 'Aanvullende ischemiecriteria niet toepassen'],
 redFlags: ['Bij ischemische klachten: hoog-risico ACS met aanvullende criteria (o.a. Sgarbossa)']
 }
 };

 const actionOverrides = {
 vfib: {
 firstAction: 'Start direct hoogwaardige CPR en defibrilleer zo snel mogelijk volgens fabrikantadviesenergie.',
 firstActionWhy: 'VF is een schokbaar arrest-ritme; vertraging in defibrillatie verlaagt overlevingskans.',
 escalationCue: 'Bij persisterend VF/pVT direct ALS-team en arrestprotocol volledig opschalen.'
 },
 asystole: {
 firstAction: 'Start CPR, geef adrenaline volgens protocol en zoek direct reversibele oorzaken (4H/4T).',
 firstActionWhy: 'Asystolie is niet-schokbaar; focus ligt op perfusie en oorzaakbehandeling.',
 escalationCue: 'Bij aanhoudende asystolie ondanks optimale CPR: direct expertteam en oorzaakgerichte interventies.'
 },
 svt: {
 firstAction: 'Begin met vagale manoeuvres bij stabiele regelmatige smalcomplex tachycardie.',
 firstActionWhy: 'Niet-invasieve terminatie is eerste stap; adenosine volgt bij falen en geschikte context.',
 escalationCue: 'Hemodynamische instabiliteit of diagnose-onzekerheid: cardioversiepad en senior consult.'
 },
 atrial_fibrillation: {
 firstAction: 'Beoordeel hemodynamische stabiliteit en start rate-control bij stabiele AF volgens lokaal protocol.',
 firstActionWhy: 'Bij stabiele AF staat ventriculaire rate-control vaak voorop; bij instabiliteit urgent cardioversiepad.',
 escalationCue: 'Instabiele AF of pre-excitatie-verdacht patroon: direct opschalen en specialist betrekken.'
 }
 };

 const leadProfileByCategory = {
 normal: { keyLeads: ['II', 'V1'], expectedPattern: 'sinus_reference' },
 bradycardia: { keyLeads: ['II', 'V1'], expectedPattern: 'slow_rhythm' },
 tachycardia: { keyLeads: ['II', 'V1', 'V5'], expectedPattern: 'tachy_pattern' },
 atrial: { keyLeads: ['II', 'V1', 'V5'], expectedPattern: 'atrial_activity_focus' },
 ventricular: { keyLeads: ['V1', 'V2', 'V5'], expectedPattern: 'wide_complex_focus' },
 blocks: { keyLeads: ['II', 'V1', 'V6'], expectedPattern: 'conduction_delay_pattern' },
 ischemia: { keyLeads: ['II', 'V2', 'V5'], expectedPattern: 'st_t_territorial_pattern' },
 pacemaker: { keyLeads: ['II', 'V1', 'V5'], expectedPattern: 'pacing_spike_capture' },
 other: { keyLeads: ['II', 'V1'], expectedPattern: 'context_dependent_pattern' }
 };

 const leadProfileOverrides = {
 stemi_anterior: { keyLeads: ['V1', 'V2', 'V3', 'V4'], expectedPattern: 'anterior_st_elevation' },
 stemi_inferior: { keyLeads: ['II', 'III', 'aVF'], expectedPattern: 'inferior_st_elevation' },
 stemi_lateral: { keyLeads: ['I', 'aVL', 'V5', 'V6'], expectedPattern: 'lateral_st_elevation' },
 stemi_posterior: { keyLeads: ['V1', 'V2', 'V3'], expectedPattern: 'posterior_mirror_pattern' },
 nstemi: { keyLeads: ['V4', 'V5', 'V6', 'aVR'], expectedPattern: 'st_depression_t_inversion' },
 wellens: { keyLeads: ['V2', 'V3'], expectedPattern: 'deep_or_biphasic_t_inversion' },
 deWinter: { keyLeads: ['V2', 'V3', 'V4', 'aVR'], expectedPattern: 'upsloping_st_depression_tall_t' },
 wpw: { keyLeads: ['II', 'V1', 'V5'], expectedPattern: 'short_pr_delta_wave' },
 brugada: { keyLeads: ['V1', 'V2'], expectedPattern: 'coved_st_v1_v2' },
 long_qt: { keyLeads: ['II', 'V5'], expectedPattern: 'qt_prolongation' },
 hyperkalemia: { keyLeads: ['V2', 'V3', 'II'], expectedPattern: 'tall_t_qrs_widening' },
 hypokalemia: { keyLeads: ['V2', 'V3', 'II'], expectedPattern: 'st_depression_u_wave' },
 vfib: { keyLeads: ['II', 'V1', 'V5'], expectedPattern: 'chaotic_no_qrs' },
 asystole: { keyLeads: ['II', 'V1', 'V5'], expectedPattern: 'flatline_confirm_multi_lead' }
 };

 const categoryTemplates = {
 normal: {
 pitfalls: ['Normaal ritme aannemen zonder intervalmeting', 'Artefact of ectopie niet uitsluiten op meerdere slagen'],
 firstAction: 'Gebruik systematische ECG-analyse met interval- en asbeoordeling.',
 firstActionWhy: 'Een vaste analysemethode verlaagt interpretatiefouten.',
 escalationCue: 'Escalatie bij klachten die niet passen bij een ogenschijnlijk benign patroon.'
 },
 bradycardia: {
 pitfalls: ['Symptomen niet koppelen aan bradycardie', 'Onderliggende geleidingsstoornis missen'],
 redFlags: ['Hypotensie, syncope of ischemie bij trage frequentie'],
 firstAction: 'Beoordeel instabiliteit direct en start bradycardie-algoritme conform protocol.',
 firstActionWhy: 'Symptomatische bradycardie kan snel perfusieproblemen geven.',
 escalationCue: 'Escaleer naar pacingpad bij persisterende instabiliteit of hooggradig blok.'
 },
 tachycardia: {
 pitfalls: ['QRS-breedte niet eerst classificeren', 'Regelmaat niet objectief beoordelen'],
 redFlags: ['Instabiliteit, thoracale pijn of hartfalen bij snelle ritmes'],
 firstAction: 'Eerst stabiliteit, daarna ritmetype (smal/breed en regelmatig/onregelmatig) bepalen.',
 firstActionWhy: 'Behandelpad en veiligheid hangen direct af van deze eerste classificatie.',
 escalationCue: 'Instabiel: direct gesynchroniseerde cardioversie en senior ondersteuning.'
 },
 atrial: {
 pitfalls: ['Atriale activiteit niet actief zoeken in inferieure afleidingen', 'Rate-control toepassen zonder instabiliteitstoets'],
 redFlags: ['Hypotensie, ischemie of pre-excitatiepatroon bij snelle onregelmatige ritmes'],
 firstAction: 'Beoordeel hemodynamiek en bepaal of rate-control of urgente cardioversie nodig is.',
 firstActionWhy: 'Atriale ritmes variëren sterk in urgentie afhankelijk van klinische context.',
 escalationCue: 'Escaleer bij instabiliteit of verdenking pre-excitatie.'
 },
 ventricular: {
 pitfalls: ['SVT met aberrantie te snel aannemen', 'Breedcomplex ritme niet als potentieel VT benaderen'],
 redFlags: ['Bewustzijnsdaling, hypotensie of pulsverlies'],
 firstAction: 'Benader brede complexe ritmes bij twijfel als ventriculair en beoordeel direct stabiliteit.',
 firstActionWhy: 'Een te laat VT-pad verhoogt risico op circulatoire collapse.',
 escalationCue: 'Instabiliteit of arrest: direct elektriciteitstherapie volgens ALS.'
 },
 blocks: {
 pitfalls: ['P-QRS-relatie niet over complete strip volgen', 'Mobitz II onderschatten als laag-risico patroon'],
 redFlags: ['Symptomen van hypoperfusie of hooggradige AV-geleidingsstoornis'],
 firstAction: 'Bepaal bloktype en hemodynamische impact; start zo nodig pacingoverbrugging.',
 firstActionWhy: 'Hooggradige blokken kunnen plots verslechteren.',
 escalationCue: 'Escaleer direct bij Mobitz II/3e graads blok met symptomen.'
 },
 ischemia: {
 pitfalls: ['Reciproke veranderingen niet beoordelen', 'STEMI-equivalenten missen zonder klassieke elevatie'],
 redFlags: ['Aanhoudende thoracale pijn, autonome symptomen, hemodynamische instabiliteit'],
 firstAction: 'Interpreteer territoriaal en activeer urgente ACS-logistiek bij hoog-risico patroon.',
 firstActionWhy: 'Vroege reperfusie bepaalt uitkomst bij acute coronairocclusie.',
 escalationCue: 'Escaleer naar cathlab/acute coronairstrategie volgens regionale afspraken.'
 },
 pacemaker: {
 pitfalls: ['Pacing spikes niet herkennen', 'Capture/sensing-fouten verwarren met intrinsiek ritme'],
 redFlags: ['Symptomatische bradycardie of hypotensie bij vermoedelijke device-falen'],
 firstAction: 'Controleer pacing spikes, capture en sensing; overbrug hemodynamisch indien nodig.',
 firstActionWhy: 'Devicefalen kan direct perfusieproblemen geven.',
 escalationCue: 'Escaleer naar acute device-evaluatie en tijdelijke pacing indien instabiel.'
 },
 other: {
 pitfalls: ['Reversibele oorzaken niet actief uitvragen', 'ECG-bevindingen los van kliniek interpreteren'],
 redFlags: ['Verslechtering, shock of ritmeprogressie tijdens observatie'],
 firstAction: 'Koppel ECG-afwijking direct aan kliniek, lab en reversibele oorzaken.',
 firstActionWhy: 'Veel niet-standaard patronen vereisen oorzaakgerichte behandeling.',
 escalationCue: 'Escaleer bij diagnostische twijfel of klinische achteruitgang.'
 }
 };

 const fallbackCategoryOrder = {
 bradycardia: ['blocks', 'normal'],
 blocks: ['bradycardia', 'normal'],
 atrial: ['tachycardia'],
 tachycardia: ['atrial', 'ventricular'],
 ventricular: ['tachycardia'],
 ischemia: ['other'],
 pacemaker: ['blocks', 'bradycardia'],
 other: ['tachycardia', 'ischemia']
 };

 const ensureMinimum = (items, minCount, fallbackItems) => {
 const unique = [];
 (Array.isArray(items) ? items : []).forEach(item => {
 if (typeof item !== 'string') return;
 const normalized = item.trim();
 if (!normalized || unique.includes(normalized)) return;
 unique.push(normalized);
 });
 (Array.isArray(fallbackItems) ? fallbackItems : []).forEach(item => {
 if (unique.length >= minCount) return;
 if (typeof item !== 'string') return;
 const normalized = item.trim();
 if (!normalized || unique.includes(normalized)) return;
 unique.push(normalized);
 });
 return unique;
 };

 const buildLookalikes = (rhythm) => {
 const candidates = ECGDatabase.getRhythmsByCategory(rhythm.category)
 .filter(item => item.id !== rhythm.id)
 .slice(0, 2);

 if (!candidates.length) {
 const fallbackCats = fallbackCategoryOrder[rhythm.category] || ['other'];
 fallbackCats.forEach(cat => {
 if (candidates.length >= 2) return;
 ECGDatabase.getRhythmsByCategory(cat)
 .filter(item => item.id !== rhythm.id)
 .slice(0, 2)
 .forEach(item => {
 if (candidates.length >= 2) return;
 if (!candidates.find(c => c.id === item.id)) {
 candidates.push(item);
 }
 });
 });
 }

 return candidates.map(item => ({
 id: item.id,
 whyWrong: `${item.name} kan erop lijken, maar vergelijk systematisch regelmaat, QRS-morfologie en P-QRS-relatie.`
 }));
 };

 MedicalContentAudit.ensureRhythmMetadata();
 ECGDatabase.getAllRhythms().forEach(rhythm => {
 const template = categoryTemplates[rhythm.category] || categoryTemplates.other;

 if (!Array.isArray(rhythm.pitfalls)) rhythm.pitfalls = [];
 if (!Array.isArray(rhythm.redFlags)) rhythm.redFlags = [];
 if (!Array.isArray(rhythm.lookalikes)) rhythm.lookalikes = [];

 if (overrides[rhythm.id]) {
 const ov = overrides[rhythm.id];
 rhythm.pitfalls = Array.isArray(ov.pitfalls) ? [...ov.pitfalls] : rhythm.pitfalls;
 rhythm.redFlags = Array.isArray(ov.redFlags) ? [...ov.redFlags] : rhythm.redFlags;
 rhythm.lookalikes = Array.isArray(ov.lookalikes) ? [...ov.lookalikes] : rhythm.lookalikes;
 }

 rhythm.pitfalls = ensureMinimum(rhythm.pitfalls, 2, template.pitfalls || []);

 if ((rhythm.urgency === 'critical' || rhythm.urgency === 'high') && rhythm.redFlags.length === 0) {
 const fallbackFlag = Array.isArray(template.redFlags) && template.redFlags.length
 ? template.redFlags[0]
 : 'Urgent patroon: volg direct lokaal spoedprotocol.';
 rhythm.redFlags = [fallbackFlag];
 }

 if (rhythm.lookalikes.length === 0) {
 rhythm.lookalikes = buildLookalikes(rhythm);
 } else {
 rhythm.lookalikes = rhythm.lookalikes
 .filter(item => item && item.id)
 .map(item => ({
 id: item.id,
 whyWrong: (typeof item.whyWrong === 'string' && item.whyWrong.trim().length)
 ? item.whyWrong
 : 'Vergelijk ritmeregelmaat, QRS-morfologie en P-QRS-relatie voor juiste differentiaal.'
 }));
 }

 if (!Array.isArray(rhythm.differentialIds) || rhythm.differentialIds.length === 0) {
 rhythm.differentialIds = rhythm.lookalikes.map(item => item.id).filter(Boolean);
 }

 if (!MedicalContentAudit.isNonEmptyString(rhythm.firstAction)) {
 rhythm.firstAction = template.firstAction;
 }
 if (!MedicalContentAudit.isNonEmptyString(rhythm.firstActionWhy)) {
 rhythm.firstActionWhy = template.firstActionWhy;
 }
 if (!MedicalContentAudit.isNonEmptyString(rhythm.escalationCue)) {
 rhythm.escalationCue = template.escalationCue;
 }

 if (actionOverrides[rhythm.id]) {
 rhythm.firstAction = actionOverrides[rhythm.id].firstAction || rhythm.firstAction;
 rhythm.firstActionWhy = actionOverrides[rhythm.id].firstActionWhy || rhythm.firstActionWhy;
 rhythm.escalationCue = actionOverrides[rhythm.id].escalationCue || rhythm.escalationCue;
 }

 const categoryLeadProfile = leadProfileByCategory[rhythm.category] || leadProfileByCategory.other;
 const overrideLeadProfile = leadProfileOverrides[rhythm.id] || {};
 const mergedLeadProfile = {
 keyLeads: Array.isArray(rhythm.leadProfile?.keyLeads) && rhythm.leadProfile.keyLeads.length
 ? rhythm.leadProfile.keyLeads
 : (overrideLeadProfile.keyLeads || categoryLeadProfile.keyLeads),
 expectedPattern: rhythm.leadProfile?.expectedPattern
 || overrideLeadProfile.expectedPattern
 || categoryLeadProfile.expectedPattern
 };
 rhythm.leadProfile = mergedLeadProfile;
 });
 })();
 // ==================== UTILITIES ====================
 const Utils = {
 // DOM helpers
 $(selector) {
 return document.querySelector(selector);
 },
 
 $$(selector) {
 return document.querySelectorAll(selector);
 },

 // Element creation
 createElement(tag, className, innerHTML) {
 const el = document.createElement(tag);
 if (className) el.className = className;
 if (innerHTML) el.innerHTML = innerHTML;
 return el;
 },

 // Time formatting
 formatTime(seconds) {
 const mins = Math.floor(seconds / 60);
 const secs = seconds % 60;
 return `${mins}:${secs.toString().padStart(2, '0')}`;
 },

 // Shuffle array
 shuffle(array) {
 const arr = [...array];
 for (let i = arr.length - 1; i > 0; i--) {
 const j = Math.floor(Math.random() * (i + 1));
 [arr[i], arr[j]] = [arr[j], arr[i]];
 }
 return arr;
 },

 // Random integer
 randomInt(min, max) {
 return Math.floor(Math.random() * (max - min + 1)) + min;
 },

 // Debounce
 debounce(func, wait) {
 let timeout;
 return function executedFunction(...args) {
 const later = () => {
 clearTimeout(timeout);
 func(...args);
 };
 clearTimeout(timeout);
 timeout = setTimeout(later, wait);
 };
 },

 // Calculate accuracy
 calcAccuracy(correct, total) {
 if (total === 0) return 0;
 return Math.round((correct / total) * 100);
 },

 // Get badge class for difficulty
 getDifficultyBadge(difficulty) {
 const badges = {
 easy: 'badge-easy',
 medium: 'badge-medium',
 hard: 'badge-hard'
 };
 return badges[difficulty] || 'badge-info';
 },

 // Get urgency label
 getUrgencyLabel(urgency) {
 const labels = {
 none: { text: 'Geen urgentie', class: 'text-muted' },
 low: { text: 'Laag', class: 'text-success' },
 medium: { text: 'Medium', class: 'text-warning' },
 high: { text: 'Hoog', class: 'text-danger' },
 critical: { text: 'KRITIEK', class: 'text-danger' }
 };
 return labels[urgency] || labels.none;
 },

 // Get category icon
 getCategoryIcon(category) {
 const cat = ECGDatabase.categories[category];
 return cat ? cat.icon : '';
 },

 // Animate element
 animateElement(element, animation) {
 element.style.animation = 'none';
 element.offsetHeight; // Trigger reflow
 element.style.animation = animation;
 },

 // Play sound (placeholder - would need audio files)
 playSound(type) {
 if (!AppState.settings.soundEnabled) return;
 // Sound implementation would go here
 },

 // Format date
 formatDate(date) {
 return new Date(date).toLocaleDateString('nl-NL', {
 day: 'numeric',
 month: 'short',
 hour: '2-digit',
 minute: '2-digit'
 });
 },

 // XP calculation
 calculateXP(correct, difficulty, timeBonus = 0) {
 const baseXP = { easy: 10, medium: 20, hard: 35 };
 let xp = baseXP[difficulty] || 15;
 if (correct) {
 xp += timeBonus;
 } else {
 xp = Math.floor(xp * 0.25); // Kleine XP voor poging
 }
 return xp;
 },

 // Level calculation
 calculateLevel(xp) {
 // XP needed: Level 1 = 0, Level 2 = 100, Level 3 = 250, etc.
 const xpNeeded = (level) => (level - 1) * 100 + (level - 1) * 25 * (level - 1);
 let level = 1;
 while (xpNeeded(level + 1) <= xp) level++;
 return {
 level,
 currentXP: xp - xpNeeded(level),
 nextLevelXP: xpNeeded(level + 1) - xpNeeded(level)
 };
 }
 };

 // ==================== NAVIGATION ====================
 const Navigation = {
 sections: {
            dashboard: { title: 'Dashboard', icon: '&#x1F4CA;' },
            monitor: { title: 'Monitor Simulator', icon: '&#x1F4FA;' },
            coach: { title: 'Leercoach', icon: '&#x1F9ED;' },
            learningPath: { title: 'Leerpad', icon: '&#x1F5FA;' },
            library: { title: 'ECG Bibliotheek', icon: '&#x1F4DA;' },
            systematic: { title: 'Systematische Analyse', icon: '&#x1F4DD;' },
            quiz: { title: 'Quiz Modus', icon: '&#x2753;' },
            cases: { title: 'Klinische Cases', icon: '&#x1F3E5;' },
            acls: { title: 'ACLS Algoritmes', icon: '&#x1F6A8;' },
            drugs: { title: 'Medicatie & ECG', icon: '&#x1F48A;' },
            criteria: { title: 'Criteria & Waarden', icon: '&#x1F4CF;' },
            progress: { title: 'Voortgang', icon: '&#x1F4C8;' },
            achievements: { title: 'Prestaties', icon: '&#x1F3C6;' },
            settings: { title: 'Instellingen', icon: '&#x2699;' }
        },

 init() {
 // Setup nav item clicks
 Utils.$$('.nav-item').forEach(item => {
 item.addEventListener('click', () => {
 const section = item.dataset.section;
 if (section) this.navigateTo(section);
 });
 });

 // Load initial section
 this.navigateTo('dashboard');
 },

 navigateTo(sectionId) {
 if (!this.sections[sectionId]) {
 console.warn(`Section ${sectionId} not found`);
 return;
 }

 const previousSection = AppState.currentSection;
 if (previousSection === 'monitor' && sectionId !== 'monitor') {
 ECGRenderer.stop('monitorCanvas');
 ECGRenderer.destroy('monitorCanvas');
 AppState.monitor.isRunning = false;
 }
 if (previousSection === 'library' && sectionId !== 'library' && typeof ECGApp?.cleanupLibraryPreviewObserver === 'function') {
 ECGApp.cleanupLibraryPreviewObserver();
 }

 // Update state
 AppState.currentSection = sectionId;
 if (AppState.ui) AppState.ui.lastVisitedSection = sectionId;

 // Update nav items
 Utils.$$('.nav-item').forEach(item => {
 item.classList.toggle('active', item.dataset.section === sectionId);
 });

 // Update title
 Utils.$('#pageTitle').textContent = this.sections[sectionId].title;
 if (typeof ECGApp.updateBreadcrumb === 'function') {
 ECGApp.updateBreadcrumb();
 }

 // Render section content
 this.renderSection(sectionId);
 },

 renderSection(sectionId) {
 const content = Utils.$('#contentArea');
 const section = this.sections[sectionId];
 if (section && typeof section.render === 'function') {
 section.render(content);
 return;
 }
 
 switch(sectionId) {
 case 'dashboard':
 Sections.renderDashboard(content);
 break;
 case 'monitor':
 Sections.renderMonitor(content);
 break;
 case 'coach':
 Sections.renderCoach(content);
 break;
 case 'learningPath':
 Sections.renderLearningPath(content);
 break;
 case 'library':
 Sections.renderLibrary(content);
 break;
 case 'systematic':
 Sections.renderSystematic(content);
 break;
 case 'quiz':
 Sections.renderQuiz(content);
 break;
 case 'cases':
 Sections.renderCases(content);
 break;
 case 'acls':
 Sections.renderACLS(content);
 break;
 case 'drugs':
 Sections.renderDrugs(content);
 break;
 case 'criteria':
 Sections.renderCriteria(content);
 break;
 case 'progress':
 Sections.renderProgress(content);
 break;
 case 'achievements':
 Sections.renderAchievements(content);
 break;
 case 'settings':
 Sections.renderSettings(content);
 break;
 default:
 content.innerHTML = '<p>Sectie wordt geladen...</p>';
 }
 }
 };

 // ==================== DEEL 3 GAAT HIER VERDER ====================

 // ==================== ECG WAVEFORM RENDERER ====================
 const ECGRenderer = {
 // Canvas settings
 settings: {
 backgroundColor: '#000000',
 gridColor: '#1f4f1f',
 gridColorMinor: '#0f2a0f',
 waveColor: '#39ff14',
 speed: 25, // mm/s
 amplitude: 10, // mm/mV
 pixelsPerMM: 4
 },

 // Active canvases
 activeCanvases: new Map(),
 LEAD_ORDER: ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'],
 LEAD_GROUPS: {
 limb: ['I', 'II', 'III', 'aVR', 'aVL', 'aVF'],
 precordial: ['V1', 'V2', 'V3', 'V4', 'V5', 'V6']
 },

getLeadTransform(lead, rhythmData, wp = {}) {
const profile = this.getLeadMorphologyProfile(rhythmData?.id || '', lead, wp);
return {
gain: profile.gain,
qrsGain: profile.qrsGain,
tGain: profile.tGain,
pGain: profile.pGain,
invert: !!profile.invert,
stShift: profile.stShift || 0,
notch: profile.notch || 0,
rProgressionBias: profile.rProgressionBias || 0
};
},

getArtifactProfile(level = 'none', speed = 25, gain = 1, zoom = 1) {
const safeSpeed = Math.max(12.5, Math.min(50, Number(speed) || 25));
const safeGain = Math.max(0.5, Math.min(2, Number(gain) || 1));
const safeZoom = Math.max(1, Math.min(2, Number(zoom) || 1));
const speedScale = Math.max(0.75, Math.min(1.35, 25 / safeSpeed));
const gainScale = Math.max(0.75, Math.min(1.4, 1 / safeGain));
const zoomScale = Math.max(0.85, Math.min(1.3, safeZoom));
const scale = speedScale * gainScale * zoomScale;
const presets = {
none: { muscleNoise: 0, baselineWander: 0, powerlineNoise: 0, powerlineHz: 0 },
low: { muscleNoise: 0.045, baselineWander: 0.02, powerlineNoise: 0.014, powerlineHz: 50 },
medium: { muscleNoise: 0.095, baselineWander: 0.042, powerlineNoise: 0.03, powerlineHz: 50 }
};
const preset = presets[level] || presets.none;
const profile = {
muscleNoise: preset.muscleNoise * scale,
baselineWander: preset.baselineWander * scale,
powerlineNoise: preset.powerlineNoise * scale,
powerlineHz: preset.powerlineHz
};
return {
...profile,
signalNoise: profile.muscleNoise
};
},

getLeadMorphologyProfile(rhythmId, lead, wp = {}) {
const base = {
I: { gain: 0.9, pGain: 0.92, qrsGain: 0.95, tGain: 0.95, stShift: 0, invert: false, notch: 0.04, rProgressionBias: 0.0 },
II: { gain: 1.05, pGain: 1.05, qrsGain: 1.06, tGain: 1.03, stShift: 0, invert: false, notch: 0.05, rProgressionBias: 0.02 },
III: { gain: 0.82, pGain: 0.8, qrsGain: 0.84, tGain: 0.82, stShift: -0.01, invert: false, notch: 0.03, rProgressionBias: -0.04 },
aVR: { gain: 0.72, pGain: 0.72, qrsGain: 0.78, tGain: 0.75, stShift: -0.02, invert: true, notch: 0.04, rProgressionBias: -0.02 },
aVL: { gain: 0.7, pGain: 0.72, qrsGain: 0.74, tGain: 0.78, stShift: 0.01, invert: false, notch: 0.04, rProgressionBias: 0.01 },
aVF: { gain: 0.92, pGain: 0.9, qrsGain: 0.95, tGain: 0.93, stShift: 0, invert: false, notch: 0.05, rProgressionBias: 0.0 },
V1: { gain: 0.85, pGain: 0.8, qrsGain: 1.2, tGain: 0.78, stShift: -0.02, invert: true, notch: 0.14, rProgressionBias: -0.14 },
V2: { gain: 0.92, pGain: 0.88, qrsGain: 1.16, tGain: 0.84, stShift: -0.01, invert: true, notch: 0.12, rProgressionBias: -0.10 },
V3: { gain: 1.0, pGain: 0.98, qrsGain: 1.08, tGain: 0.94, stShift: 0, invert: false, notch: 0.09, rProgressionBias: -0.04 },
V4: { gain: 1.08, pGain: 1.04, qrsGain: 1.1, tGain: 1.02, stShift: 0.01, invert: false, notch: 0.07, rProgressionBias: 0.04 },
V5: { gain: 1.14, pGain: 1.05, qrsGain: 1.14, tGain: 1.08, stShift: 0.02, invert: false, notch: 0.06, rProgressionBias: 0.10 },
V6: { gain: 1.08, pGain: 1.0, qrsGain: 1.09, tGain: 1.06, stShift: 0.02, invert: false, notch: 0.05, rProgressionBias: 0.12 }
};
const normalizedLead = (lead && base[lead]) ? lead : 'II';
const profile = { ...base[normalizedLead] };
const hasLead = (arr = []) => Array.isArray(arr) && arr.includes(normalizedLead);
const rhythm = String(rhythmId || '');

if (rhythm === 'rbbb') {
if (['V1', 'V2'].includes(normalizedLead)) {
profile.invert = false;
profile.qrsGain *= 1.18;
profile.notch = Math.max(profile.notch, 0.24);
}
if (['I', 'V6'].includes(normalizedLead)) {
profile.qrsGain *= 0.9;
profile.stShift -= 0.01;
}
}
if (rhythm === 'lbbb') {
if (['I', 'aVL', 'V5', 'V6'].includes(normalizedLead)) {
profile.qrsGain *= 1.18;
profile.notch = Math.max(profile.notch, 0.2);
}
if (['V1', 'V2'].includes(normalizedLead)) {
profile.invert = true;
profile.qrsGain *= 0.9;
}
}
if (rhythm === 'brugada' && ['V1', 'V2'].includes(normalizedLead)) {
profile.invert = false;
profile.stShift += 0.035;
profile.notch = Math.max(profile.notch, 0.16);
}
if (wp.wideQRS && ['V1', 'V2', 'V5', 'V6'].includes(normalizedLead)) {
profile.qrsGain *= 1.05;
}
if (wp.elevationLeads && hasLead(wp.elevationLeads)) {
profile.stShift += Math.max(0.02, Number(wp.stElevation || 0.12) * 0.2);
}
if (wp.depressionLeads && hasLead(wp.depressionLeads)) {
profile.stShift -= Math.max(0.015, Number(wp.stDepression || 0.1) * 0.18);
}
if (wp.reciprocalDepression && hasLead(wp.reciprocalDepression)) {
profile.stShift -= 0.025;
}
if (wp.tentedT || rhythm === 'hyperkalemia') {
if (['V2', 'V3', 'V4', 'V5'].includes(normalizedLead)) profile.tGain *= 1.15;
}
if (rhythm === 'hypokalemia') {
profile.tGain *= 0.82;
if (['V2', 'V3', 'V4'].includes(normalizedLead)) profile.stShift -= 0.012;
}
return profile;
},

getBeatFiducials(rhythmId, heartRate = 72) {
const rhythm = ECGDatabase.getRhythmById(rhythmId);
const wp = rhythm?.waveformParams || {};
const organizedBlacklist = new Set(['vfib', 'asystole', 'pea']);
if (!rhythm || organizedBlacklist.has(rhythm.id)) {
return {
valid: false,
reason: 'non_organized',
qrsStartPhase: 0.18,
segments: []
};
}
const bpm = Math.max(20, Number(heartRate) || 72);
const beatSeconds = Math.max(0.3, 60 / bpm);
const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
const toPhase = (seconds) => clamp(seconds / beatSeconds, 0.01, 0.95);
const hasNoP = !!(wp.absentP || wp.flatP || wp.fibrillation || wp.flutterWaves);
let prSec = wp.prInterval || 0.16;
if (wp.shortPR) prSec = Math.min(prSec, 0.11);
if (wp.longPR || wp.prolongedIntervals) prSec = Math.max(prSec, 0.22);
const qrsSec = clamp((wp.qrsWidth || 0.09) + (wp.wideQRS ? 0.025 : 0), 0.05, 0.22);
let qtSec = wp.longQT ? 0.46 : wp.shortQT ? 0.3 : 0.36;
if (wp.longST) qtSec += 0.04;
if (wp.shortST) qtSec = Math.max(0.28, qtSec - 0.04);
const qrsStartPhase = clamp(Math.max(0.16, toPhase(prSec)), 0.08, 0.68);
const qrsDurationPhase = clamp(toPhase(qrsSec), 0.05, 0.32);
const qtDurationPhase = clamp(toPhase(qtSec), qrsDurationPhase + 0.03, 0.62);
const prDurationPhase = clamp(toPhase(prSec), 0.04, 0.32);
const qrsStartSec = qrsStartPhase * beatSeconds;
const segments = [];
const irregular = rhythm.id === 'atrial_fibrillation' || wp.fibrillation;
const ventricularLike = rhythm.id.includes('vtach') || wp.wideQRS;
if (!hasNoP && !irregular && !ventricularLike) {
segments.push({
id: 'PR',
label: 'PR',
startPhase: clamp(qrsStartPhase - prDurationPhase, 0.02, 0.85),
durationSec: clamp(prSec, 0.08, 0.32),
color: 'rgba(6, 182, 212, 0.92)'
});
}
segments.push({
id: 'QRS',
label: 'QRS',
startPhase: qrsStartPhase,
durationSec: clamp(qrsSec, 0.05, 0.22),
color: 'rgba(245, 158, 11, 0.95)'
});
if (!ventricularLike) {
segments.push({
id: 'QT',
label: 'QT',
startPhase: qrsStartPhase,
durationSec: clamp(qtSec, 0.24, 0.6),
color: 'rgba(239, 68, 68, 0.95)'
});
}
return {
valid: segments.length > 0,
reason: segments.length > 0 ? 'ok' : 'no_segments',
qrsStartPhase,
qrsStartSec,
beatSeconds,
segments
};
},

 buildLeadCanvasId(rootId, lead) {
 const safeLead = String(lead || 'II').replace(/[^a-z0-9]/gi, '').toLowerCase();
 return `${rootId}_${safeLead}`;
 },

 // Initialize canvas
 initCanvas(canvasId, options = {}) {
 // Prevent orphaned animation loops when re-initializing the same canvas id.
 if (this.activeCanvases.has(canvasId)) {
 this.stop(canvasId);
 this.activeCanvases.delete(canvasId);
 }

 const canvas = document.getElementById(canvasId);
 if (!canvas) return null;

 const ctx = canvas.getContext('2d');
 const rect = canvas.getBoundingClientRect();
 
 // Set actual size
 canvas.width = rect.width * window.devicePixelRatio;
 canvas.height = rect.height * window.devicePixelRatio;
 ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

 const config = {
 canvas,
 ctx,
 width: rect.width,
 height: rect.height,
 x: 0,
 rhythm: options.rhythm || 'sinus_normal',
 heartRate: options.heartRate || 72,
 speed: options.speed || this.settings.speed,
amplitude: options.amplitude || 1,
verticalScale: options.verticalScale || 1,
signalNoise: options.signalNoise || options.muscleNoise || 0,
muscleNoise: options.muscleNoise || options.signalNoise || 0,
baselineWander: options.baselineWander || 0,
powerlineNoise: options.powerlineNoise || 0,
powerlineHz: options.powerlineHz || 50,
lineWidth: options.lineWidth || 2,
shadowBlur: options.shadowBlur || 4,
 isRunning: false,
 animationId: null,
 lastTime: 0,
 buffer: [],
 ...options
 };

 this.activeCanvases.set(canvasId, config);
 return config;
 },

 // Draw ECG grid
drawGrid(ctx, width, height, theme = null) {
const ppm = this.settings.pixelsPerMM;
const palette = {
backgroundColor: theme?.backgroundColor || this.settings.backgroundColor,
gridColor: theme?.gridColor || this.settings.gridColor,
gridColorMinor: theme?.gridColorMinor || this.settings.gridColorMinor
};

// Clear
ctx.fillStyle = palette.backgroundColor;
ctx.fillRect(0, 0, width, height);

// Minor grid (1mm)
ctx.strokeStyle = palette.gridColorMinor;
ctx.lineWidth = 0.5;
ctx.beginPath();
 for (let x = 0; x < width; x += ppm) {
 ctx.moveTo(x, 0);
 ctx.lineTo(x, height);
 }
 for (let y = 0; y < height; y += ppm) {
 ctx.moveTo(0, y);
 ctx.lineTo(width, y);
 }
 ctx.stroke();

// Major grid (5mm)
ctx.strokeStyle = palette.gridColor;
ctx.lineWidth = 1;
ctx.beginPath();
 for (let x = 0; x < width; x += ppm * 5) {
 ctx.moveTo(x, 0);
 ctx.lineTo(x, height);
 }
 for (let y = 0; y < height; y += ppm * 5) {
 ctx.moveTo(0, y);
 ctx.lineTo(width, y);
 }
 ctx.stroke();
 },

 // Generate waveform point for a specific rhythm
 generateWaveformPoint(rhythm, phase, params = {}) {
 const rhythmData = ECGDatabase.getRhythmById(rhythm);
 if (!rhythmData) return 0;

 const wp = rhythmData.waveformParams || {};
 const amplitude = params.amplitude || 1;
 const heartRate = params.heartRate || 72;
 const time = Number(params.time) || 0;
 const beatIndex = Math.floor((time * heartRate) / 60);
 const context = { ...params, time, beatIndex };
 
 // Normalize phase to 0-1
 phase = phase % 1;
 if (phase < 0) phase += 1;

 let value = 0;

 // Different waveform generation based on rhythm type
 switch(rhythm) {
 case 'vfib':
 // Chaotic VF pattern
 value = (Math.random() - 0.5) * 0.8 * amplitude;
 value += Math.sin(phase * Math.PI * 20) * 0.2;
 value += Math.sin(phase * Math.PI * 7.3) * 0.15;
 break;

 case 'asystole':
 // Flat line with minimal noise
 value = (Math.random() - 0.5) * 0.02;
 break;

 case 'pea':
 // Organized electrical activity with lower amplitude variability.
 value = this.generateNormalQRS(
 phase,
 { ...wp, pHeight: wp.pHeight || 0.08, rHeight: wp.rHeight || 0.7, tHeight: wp.tHeight || 0.18 },
 amplitude * 0.9,
 heartRate,
 rhythmData,
 context
 );
 value += Math.sin((time + phase) * Math.PI * 2) * 0.015 * amplitude;
 break;

 case 'atrial_fibrillation':
 // AF - irregular with fibrillation baseline
 value = this.generateNormalQRS(phase, wp, amplitude, heartRate, rhythmData, context);
 // Add fibrillation waves
 value += Math.sin(phase * Math.PI * 15) * 0.03;
 value += Math.sin(phase * Math.PI * 23) * 0.02;
 break;

 case 'atrial_flutter':
 // Flutter waves (sawtooth)
 value = this.generateFlutterWaveform(phase, wp, amplitude);
 break;

 case 'vtach_monomorphic':
 // Wide complex VT
 value = this.generateVTWaveform(phase, wp, amplitude);
 break;

 case 'vtach_polymorphic':
 // Torsades - twisting pattern
 value = this.generateTorsadesWaveform(phase, wp, amplitude, params.time || 0);
 break;

 case 'avblock_3rd':
 // Complete heart block - dissociated P and QRS
 value = this.generateCHBWaveform(phase, wp, amplitude, params);
 break;

 case 'paced_ventricular':
 case 'paced_dual':
 // Paced rhythm with spike
 value = this.generatePacedWaveform(phase, wp, amplitude, rhythm);
 break;

 default:
 // Standard waveform (sinus-like)
 value = this.generateNormalQRS(phase, wp, amplitude, heartRate, rhythmData, context);
 }

 const lead = params.lead || 'II';
 return this.applyLeadMorphology(value, phase, lead, rhythmData, wp);
 },

applyLeadMorphology(value, phase, lead, rhythmData, wp = {}) {
const normalizedLead = lead || 'II';
const qrsStart = 0.16;
const qrsEnd = 0.46;
const isPWindow = phase >= 0.06 && phase <= 0.18;
const isQrsWindow = phase >= qrsStart && phase <= qrsEnd;
const isSTWindow = phase >= 0.46 && phase <= 0.62;
const isTWindow = phase >= 0.55 && phase <= 0.88;
const transform = this.getLeadTransform(normalizedLead, rhythmData, wp);
const widePattern = !!(wp.wideQRS || wp.lbbbMorphology || wp.rbbbPattern || wp.rsrPattern);

let adjusted = value * transform.gain;
if (isPWindow) adjusted *= transform.pGain;
if (isQrsWindow) adjusted *= transform.qrsGain;
if (isTWindow) adjusted *= transform.tGain;

if (transform.invert) adjusted *= -1;
if (isQrsWindow && transform.rProgressionBias) {
adjusted *= (1 + transform.rProgressionBias);
}
if (isSTWindow && transform.stShift) {
adjusted += transform.stShift;
}
if (isQrsWindow && transform.notch > 0) {
const localQrs = (phase - qrsStart) / Math.max(0.001, qrsEnd - qrsStart);
if (localQrs > 0.42 && localQrs < 0.84) {
adjusted += transform.notch * Math.sin(((localQrs - 0.42) / 0.42) * Math.PI);
}
}

if (isQrsWindow && widePattern && ['V1', 'V2'].includes(normalizedLead)) {
adjusted *= 1.05;
}
if (isQrsWindow && ['V5', 'V6', 'I', 'aVL'].includes(normalizedLead)) {
 adjusted = Math.max(0, adjusted) + (Math.min(0, adjusted) * 0.35);
 }
if (rhythmData?.id === 'lbbb' && isQrsWindow && ['I', 'aVL', 'V5', 'V6'].includes(normalizedLead)) {
adjusted = Math.max(adjusted, value * 0.9);
}
if (rhythmData?.id === 'rbbb' && isQrsWindow && ['V1', 'V2'].includes(normalizedLead)) {
adjusted = Math.abs(adjusted) * 0.95;
}

 const hasLead = (arr = []) => Array.isArray(arr) && arr.includes(normalizedLead);
 const stElevation = Number(wp.stElevation || 0);
 const stDepression = Number(wp.stDepression || 0);
 if (isSTWindow) {
 if (stElevation && hasLead(wp.elevationLeads)) {
 adjusted += stElevation * 0.4;
 }
 if (stDepression && hasLead(wp.depressionLeads)) {
 adjusted -= stDepression * 0.38;
 }
 if (hasLead(wp.reciprocalDepression)) {
 adjusted -= Math.max(0.08, (stElevation || 0.12) * 0.32);
 }
 if (wp.aVRelevation && normalizedLead === 'aVR') {
 adjusted += 0.12;
 }
 if (wp.upSlopingSTdep && ['V1', 'V2', 'V3', 'V4', 'V5', 'V6'].includes(normalizedLead)) {
 adjusted -= 0.1 + (Math.max(0, phase - 0.46) * 0.1);
 }
 }

 if (isTWindow) {
 if (wp.tallSymmetricT && ['V2', 'V3', 'V4', 'V5'].includes(normalizedLead)) {
 adjusted *= 1.2;
 }
 if (wp.hyperacuteT && ['V2', 'V3', 'V4'].includes(normalizedLead)) {
 adjusted *= 1.12;
 }
 if (wp.deepTInversion && ['V2', 'V3'].includes(normalizedLead)) {
 adjusted = -Math.abs(adjusted) * 1.1;
 }
 if (wp.tInversion && ['I', 'aVL', 'V4', 'V5', 'V6'].includes(normalizedLead)) {
 adjusted = -Math.abs(adjusted) * 0.95;
 }
 }

 return adjusted;
 },

 // Generate normal sinus-like QRS
 generateNormalQRS(phase, wp, amplitude, heartRate = 72, rhythmData = null, context = {}) {
 const bpm = Math.max(20, Number(heartRate) || 72);
 const beatSeconds = Math.max(0.3, 60 / bpm);
 const toPhase = (seconds) => seconds / beatSeconds;
 const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
 const beatIndex = Number.isFinite(context?.beatIndex)
 ? context.beatIndex
 : Math.floor(((Number(context?.time) || 0) * bpm) / 60);

 const hasNoP = !!(wp.absentP || wp.flatP || wp.fibrillation || wp.flutterWaves);
 const hasRetrogradeP = !!wp.retrogradeP;
 const pHeight = hasNoP ? 0 : (wp.pHeight || 0.15) * amplitude;
 const pWidthSec = wp.pWidth || 0.08;

 const qDepth = (wp.qDepth || 0.05) * amplitude;
 let rHeight = (wp.rHeight || wp.qrsHeight || 1.0) * amplitude;
 let sDepth = (wp.sDepth || 0.15) * amplitude;
 if (wp.s1q3t3) {
 sDepth = Math.max(sDepth, 0.28 * amplitude);
 }

 let qrsWidthSec = wp.qrsWidth || 0.08;
 if (wp.wideQRS || wp.broadR || wp.lbbbMorphology || wp.rbbbPattern || wp.rsrPattern || wp.wideSinV6) {
 qrsWidthSec = Math.max(qrsWidthSec, 0.12);
 }
 if (wp.narrowQRS) {
 qrsWidthSec = Math.min(qrsWidthSec, 0.08);
 }
 qrsWidthSec = clamp(qrsWidthSec, 0.05, 0.22);

 let prIntervalSec = wp.prInterval || 0.16;
 if (wp.shortPR) prIntervalSec = Math.min(prIntervalSec, 0.11);
 if (wp.longPR || wp.prolongedIntervals) prIntervalSec = Math.max(prIntervalSec, 0.22);
 if (wp.tachycardia) prIntervalSec = Math.min(prIntervalSec, 0.13);
 if (wp.bradycardia) prIntervalSec = Math.max(prIntervalSec, 0.18);

 let droppedBeat = false;
 if (wp.wenckebach) {
 const cycleLength = Math.max(3, parseInt(wp.cycleLength, 10) || 4);
 const beatInCycle = ((beatIndex % cycleLength) + cycleLength) % cycleLength;
 droppedBeat = beatInCycle === cycleLength - 1;
 const basePr = wp.initialPR || prIntervalSec;
 const increment = wp.prIncrement || 0.03;
 prIntervalSec = clamp(basePr + increment * beatInCycle, 0.12, 0.45);
 }
 if (wp.mobitzII) {
 let num = 3;
 let den = 2;
 if (typeof wp.conductionRatio === 'string' && wp.conductionRatio.includes(':')) {
 const parts = wp.conductionRatio.split(':').map(v => parseInt(v, 10));
 if (!Number.isNaN(parts[0]) && !Number.isNaN(parts[1]) && parts[0] > 1 && parts[1] >= 1 && parts[1] < parts[0]) {
 num = parts[0];
 den = parts[1];
 }
 }
 const beatInCycle = ((beatIndex % num) + num) % num;
 droppedBeat = beatInCycle >= den;
 prIntervalSec = wp.constantPR || prIntervalSec;
 qrsWidthSec = Math.max(qrsWidthSec, 0.12);
 }

 let tHeight = (wp.tHeight || 0.25) * amplitude;
 let tWidthSec = wp.tWidth || 0.16;
 let tPolarity = 1;

 if (wp.tInversion || wp.tInversionV1V4 || wp.abnormalT || wp.wellensTypeB || wp.deepTInversion || rhythmData?.id === 'wellens') {
 tPolarity = -1;
 }
 if (wp.s1q3t3) {
 tPolarity = -1;
 }
 if (wp.tallSymmetricT || wp.hyperacuteT || wp.tentedT) {
 tHeight = Math.max(tHeight, 0.45 * amplitude);
 }
 if (wp.deepTInversion) {
 tHeight = Math.max(tHeight, 0.5 * amplitude);
 }
 if (wp.flatT) {
 tHeight = Math.min(tHeight, 0.08 * amplitude);
 }
 if (wp.longQT || wp.longST) {
 tWidthSec = Math.max(tWidthSec, 0.22);
 }
 if (wp.shortQT || wp.shortST) {
 tWidthSec = Math.min(tWidthSec, 0.12);
 }

 let stLevel = 0;
 if (typeof wp.stElevation === 'number') stLevel += wp.stElevation * 0.55 * amplitude;
 if (typeof wp.stDepression === 'number') stLevel -= wp.stDepression * 0.55 * amplitude;
 if (wp.concaveST || wp.diffuseSTElevation) stLevel += 0.06 * amplitude;
 if (wp.scoopedST) stLevel -= 0.1 * amplitude;
 if (wp.upSlopingSTdep) stLevel -= 0.14 * amplitude;
 if (wp.prDepression && phase < 0.2) stLevel -= 0.02 * amplitude;

 // Build dynamic phase windows from ECG interval settings.
 const pStart = 0.02;
 const pEnd = clamp(pStart + clamp(toPhase(pWidthSec), 0.04, 0.18), pStart + 0.04, 0.25);
 const qrsStart = clamp(Math.max(pEnd + 0.02, toPhase(prIntervalSec)), pEnd + 0.02, 0.50);
 const qrsEnd = clamp(qrsStart + clamp(toPhase(qrsWidthSec), 0.05, 0.30), qrsStart + 0.05, 0.78);
 const stEnd = clamp(qrsEnd + clamp(toPhase(wp.longST ? 0.18 : wp.shortST ? 0.08 : 0.12), 0.06, 0.25), qrsEnd + 0.05, 0.90);
 const tEnd = clamp(stEnd + clamp(toPhase(tWidthSec), 0.08, 0.30), stEnd + 0.08, 0.98);

 let value = 0;

 if (!hasNoP && phase >= pStart && phase < pEnd) {
 const pPhase = (phase - pStart) / (pEnd - pStart);
 value = pHeight * Math.sin(pPhase * Math.PI);
 } else if (phase >= pEnd && phase < qrsStart) {
 value = wp.prDepression ? -0.04 * amplitude : 0;
 } else if (droppedBeat && phase >= qrsStart) {
 // Non-conducted beat: P wave without following QRS/T.
 value = 0;
 } else if (phase >= qrsStart && phase < qrsEnd) {
 const qrsPhase = (phase - qrsStart) / (qrsEnd - qrsStart);
 if (qrsPhase < 0.22) {
 value = -qDepth * Math.sin((qrsPhase / 0.22) * Math.PI);
 } else if (qrsPhase < 0.68) {
 value = rHeight * Math.sin(((qrsPhase - 0.22) / 0.46) * Math.PI);
 } else {
 value = -sDepth * Math.sin(((qrsPhase - 0.68) / 0.32) * Math.PI);
 }

 // RSR'/RBBB style terminal R' notch
 if ((wp.rsrPattern || wp.rbbbPattern) && qrsPhase > 0.72 && qrsPhase < 0.92) {
 value += 0.35 * amplitude * Math.sin(((qrsPhase - 0.72) / 0.20) * Math.PI);
 }
 } else if (phase >= qrsEnd && phase < stEnd) {
 const stPhase = (phase - qrsEnd) / (stEnd - qrsEnd);
 value = stLevel;
 if (wp.upSlopingSTdep) {
 value = stLevel * (1 - stPhase);
 }
 if (wp.scoopedST) {
 value -= 0.07 * amplitude * Math.sin(stPhase * Math.PI);
 }
 } else if (phase >= stEnd && phase < tEnd) {
 const tPhase = (phase - stEnd) / (tEnd - stEnd);
 if (wp.tentedT) {
 value = tPolarity * tHeight * Math.pow(Math.sin(tPhase * Math.PI), 3);
 } else {
 value = tPolarity * tHeight * Math.sin(tPhase * Math.PI);
 }
 } else {
 value = 0;
 }

 // Retrograde P-wave after QRS in junctional rhythms.
 if (hasRetrogradeP && !droppedBeat) {
 const rpStart = qrsEnd + 0.03;
 const rpEnd = Math.min(0.96, rpStart + 0.10);
 if (phase >= rpStart && phase < rpEnd) {
 const rpPhase = (phase - rpStart) / (rpEnd - rpStart);
 value += -0.1 * amplitude * Math.sin(rpPhase * Math.PI);
 }
 }

 // Delta wave (WPW): slurred upstroke before QRS.
 const deltaStart = Math.max(0, qrsStart - 0.035);
 if (wp.deltaWave && phase >= deltaStart && phase < qrsStart) {
 const dPhase = (phase - deltaStart) / (qrsStart - deltaStart);
 value += 0.18 * amplitude * dPhase;
 }

 // Pacer spike.
 if (wp.pacingSpike) {
 const spikeStart = Math.max(0, qrsStart - 0.008);
 if (phase >= spikeStart && phase < qrsStart - 0.004) {
 value = Math.max(value, 0.7 * amplitude);
 }
 }

 // J/Osborn wave after QRS.
 if (wp.osbornWave) {
 const jStart = qrsEnd + 0.01;
 const jEnd = jStart + 0.05;
 if (phase >= jStart && phase < jEnd) {
 const jPhase = (phase - jStart) / (jEnd - jStart);
 value += 0.12 * amplitude * Math.sin(jPhase * Math.PI);
 }
 }

 // Prominent U-wave in late repolarization.
 if (wp.prominentU) {
 const uStart = tEnd + 0.02;
 const uEnd = Math.min(1, uStart + 0.08);
 if (phase >= uStart && phase < uEnd) {
 const uPhase = (phase - uStart) / (uEnd - uStart);
 value += 0.08 * amplitude * Math.sin(uPhase * Math.PI);
 }
 }

 return value;
 },

 // Generate VT waveform
 generateVTWaveform(phase, wp, amplitude) {
 const qrsWidth = wp.qrsWidth || 0.16;
 const rHeight = (wp.qrsHeight || 1.4) * amplitude;

 let value = 0;

 // Wide QRS complex takes most of the cycle
 if (phase < 0.45) {
 // Broad R wave
 const rPhase = phase / 0.45;
 value = rHeight * Math.sin(rPhase * Math.PI);
 // Add some notching
 value += Math.sin(rPhase * Math.PI * 3) * 0.1 * amplitude;
 }
 else if (phase < 0.55) {
 // Deep S
 const sPhase = (phase - 0.45) / 0.10;
 value = -0.3 * amplitude * Math.sin(sPhase * Math.PI);
 }
 else if (phase < 0.85) {
 // Inverted T
 const tPhase = (phase - 0.55) / 0.30;
 value = -0.25 * amplitude * Math.sin(tPhase * Math.PI);
 }

 return value;
 },

 // Generate flutter waveform
 generateFlutterWaveform(phase, wp, amplitude) {
 let value = 0;
 const avConduction = wp.avConduction || 2;

 // Flutter waves (sawtooth pattern)
 const flutterPhase = (phase * avConduction) % 1;
 const flutterWave = (1 - flutterPhase * 2);
 value = flutterWave * 0.15 * amplitude;

 // QRS complex (every avConduction flutter waves)
 const qrsPhase = phase;
 if (qrsPhase > 0.15 && qrsPhase < 0.35) {
 const localPhase = (qrsPhase - 0.15) / 0.20;
 if (localPhase < 0.3) {
 value += amplitude * Math.sin(localPhase / 0.3 * Math.PI);
 } else if (localPhase < 0.5) {
 value -= 0.2 * amplitude * Math.sin((localPhase - 0.3) / 0.2 * Math.PI);
 }
 }

 return value;
 },

 // Generate Torsades waveform
 generateTorsadesWaveform(phase, wp, amplitude, time) {
 // Twisting amplitude modulation
 const twistFreq = 0.5; // Hz
 const twistAmp = Math.sin(time * twistFreq * Math.PI * 2);
 
 let value = 0;
 const baseAmp = amplitude * (0.5 + 0.5 * Math.abs(twistAmp));
 
 // Wide complex
 if (phase < 0.5) {
 const rPhase = phase / 0.5;
 value = baseAmp * Math.sin(rPhase * Math.PI) * (twistAmp > 0 ? 1 : -1);
 } else {
 const tPhase = (phase - 0.5) / 0.5;
 value = -baseAmp * 0.3 * Math.sin(tPhase * Math.PI) * (twistAmp > 0 ? 1 : -1);
 }

 return value;
 },

 // Generate complete heart block waveform
 generateCHBWaveform(phase, wp, amplitude, params) {
 let value = 0;
 
 // P waves at atrial rate
 const pRate = wp.pRate || 80;
 const escapeRate = wp.escapeRate || 35;
 const ratio = pRate / escapeRate;

 // P wave
 const pPhase = (phase * ratio) % 1;
 if (pPhase < 0.15) {
 value += 0.15 * amplitude * Math.sin(pPhase / 0.15 * Math.PI);
 }

 // Escape QRS (wide)
 if (phase > 0.20 && phase < 0.50) {
 const qrsPhase = (phase - 0.20) / 0.30;
 if (qrsPhase < 0.4) {
 value += amplitude * Math.sin(qrsPhase / 0.4 * Math.PI);
 } else if (qrsPhase < 0.6) {
 value -= 0.3 * amplitude * Math.sin((qrsPhase - 0.4) / 0.2 * Math.PI);
 }
 }

 // T wave
 if (phase > 0.55 && phase < 0.80) {
 const tPhase = (phase - 0.55) / 0.25;
 value -= 0.2 * amplitude * Math.sin(tPhase * Math.PI);
 }

 return value;
 },

 // Generate paced waveform
 generatePacedWaveform(phase, wp, amplitude, rhythm) {
 let value = 0;

 // Atrial spike (for DDD)
 if (rhythm === 'paced_dual' && phase < 0.02) {
 value = 0.4 * amplitude;
 }
 // Atrial contraction
 else if (rhythm === 'paced_dual' && phase >= 0.02 && phase < 0.12) {
 const pPhase = (phase - 0.02) / 0.10;
 value = 0.12 * amplitude * Math.sin(pPhase * Math.PI);
 }
 // Ventricular spike
 else if (phase >= 0.18 && phase < 0.20) {
 value = 0.5 * amplitude;
 }
 // Wide paced QRS (LBBB morphology)
 else if (phase >= 0.20 && phase < 0.42) {
 const qrsPhase = (phase - 0.20) / 0.22;
 if (qrsPhase < 0.5) {
 value = amplitude * Math.sin(qrsPhase / 0.5 * Math.PI);
 } else {
 value = -0.15 * amplitude * Math.sin((qrsPhase - 0.5) / 0.5 * Math.PI);
 }
 }
 // T wave (discordant)
 else if (phase >= 0.50 && phase < 0.75) {
 const tPhase = (phase - 0.50) / 0.25;
 value = -0.25 * amplitude * Math.sin(tPhase * Math.PI);
 }

 return value;
 },

// Start animation
start(canvasId, options = {}) {
const config = this.activeCanvases.get(canvasId);
if (!config || config.isRunning) return;

const shouldReset = options.reset === true;
config.isRunning = true;
config.lastTime = performance.now();
if (shouldReset) {
config.x = 0;
config.buffer = [];
this.drawGrid(config.ctx, config.width, config.height, config.theme);
} else {
if (!Number.isFinite(config.x)) config.x = 0;
if (!Array.isArray(config.buffer)) config.buffer = [];
if (config.buffer.length === 0 && config.x === 0) {
this.drawGrid(config.ctx, config.width, config.height, config.theme);
}
}

 const animate = (currentTime) => {
 if (!config.isRunning) return;

 const deltaTime = (currentTime - config.lastTime) / 1000;
 config.lastTime = currentTime;

 this.updateWaveform(config, deltaTime);
 config.animationId = requestAnimationFrame(animate);
 };

 config.animationId = requestAnimationFrame(animate);
 },

 // Stop animation
 stop(canvasId) {
 const config = this.activeCanvases.get(canvasId);
 if (!config) return;

 config.isRunning = false;
 if (config.animationId) {
 cancelAnimationFrame(config.animationId);
 config.animationId = null;
 }
 },

 // Update waveform
 updateWaveform(config, deltaTime) {
 const { ctx, width, height, speed, amplitude, heartRate, rhythm } = config;
 const ppm = this.settings.pixelsPerMM;
 const rhythmData = ECGDatabase.getRhythmById(rhythm);
 const wp = rhythmData?.waveformParams || {};
 
 // Calculate pixels to draw
 const pixelsPerSecond = speed * ppm;
 const pixelsToDraw = pixelsPerSecond * deltaTime;

 // Calculate phase increment per pixel
 const beatsPerSecond = heartRate / 60;
 const pixelsPerBeat = pixelsPerSecond / beatsPerSecond;
 const phasePerPixel = 1 / pixelsPerBeat;

 // Generate new points
 const baseline = height / 2;
 // ECG calibration: 10 mm/mV at gain 1x. `verticalScale` is now only a multiplier.
 const scale = this.settings.pixelsPerMM * this.settings.amplitude * (config.verticalScale || 1);

 for (let i = 0; i < pixelsToDraw; i++) {
 // Hard reset at the right edge to avoid overlapping traces across cycles.
 if (config.x >= width) {
 config.x = 0;
 config.buffer = [];
 }

 const x = config.x;
 const phase = (x * phasePerPixel) % 1;
 
 // Add R-R variability where configured.
 let adjustedPhase = phase;
 const rrVar = Number(wp.rrVariability || wp.variability || (wp.variableRR ? 0.25 : 0));
 if (rrVar > 0) {
 adjustedPhase += Math.sin(x * 0.01) * Math.min(0.35, rrVar * 0.3);
 }

 const value = this.generateWaveformPoint(rhythm, adjustedPhase, {
 amplitude,
 time: x / pixelsPerSecond,
 heartRate,
 lead: config.lead || 'II'
 });

const wanderOffset = config.baselineWander
? Math.sin((x / Math.max(1, width)) * Math.PI * 2 * 1.25) * config.baselineWander * scale
: 0;
const muscleNoise = Number(config.muscleNoise ?? config.signalNoise ?? 0);
const noiseOffset = muscleNoise
? (Math.random() - 0.5) * muscleNoise * scale
: 0;
const powerlineNoise = Number(config.powerlineNoise || 0);
const powerlineHz = Number(config.powerlineHz || 50);
const powerlineOffset = powerlineNoise
? Math.sin((x / Math.max(1, pixelsPerSecond)) * Math.PI * 2 * powerlineHz) * powerlineNoise * scale
: 0;

config.buffer.push({
x,
y: baseline + wanderOffset - value * scale + noiseOffset + powerlineOffset
});

 config.x++;
 }

 // Redraw
this.drawGrid(ctx, width, height, config.theme);

 // Draw waveform
const waveColor = config.theme?.waveColor || this.settings.waveColor;
ctx.strokeStyle = waveColor;
 ctx.lineWidth = config.lineWidth || 2;
 ctx.lineCap = 'round';
 ctx.lineJoin = 'round';
ctx.shadowColor = waveColor;
 ctx.shadowBlur = config.shadowBlur || 4;

 // Only keep recent points
 const maxPoints = width;
 if (config.buffer.length > maxPoints) {
 config.buffer = config.buffer.slice(-maxPoints);
 }

 // Draw current sweep segment
 ctx.beginPath();
 for (let i = 0; i < config.buffer.length; i++) {
 const point = config.buffer[i];
 if (i === 0) {
 ctx.moveTo(point.x, point.y);
 } else {
 ctx.lineTo(point.x, point.y);
 }
 }
 ctx.stroke();
 ctx.shadowBlur = 0;

 // Draw sweep line
 const sweepX = config.x % width;
ctx.strokeStyle = config.theme?.sweepColor || 'rgba(34, 197, 94, 0.5)';
 ctx.lineWidth = 2;
 ctx.beginPath();
 ctx.moveTo(sweepX, 0);
 ctx.lineTo(sweepX, height);
 ctx.stroke();

// Clear ahead of sweep
ctx.fillStyle = config.theme?.backgroundColor || this.settings.backgroundColor;
ctx.fillRect(sweepX + 2, 0, 50, height);

this.drawCalibrationPulse(ctx, width, height, {
amplitude: config.amplitude,
verticalScale: config.verticalScale,
showCalibrationPulse: config.showCalibrationPulse,
theme: config.theme
});


},

drawIntervalsOverlay(ctx, width, height, heartRate, speed, options = {}) {
const bpm = Math.max(20, Number(heartRate) || 72);
const beatSeconds = Math.max(0.3, 60 / bpm);
const pxPerSecond = Math.max(1, speed * this.settings.pixelsPerMM);
const pixelsPerBeat = Math.max(1, pxPerSecond * beatSeconds);
const rhythmId = options.rhythmId || options.rhythm || 'sinus_normal';
const fiducials = this.getBeatFiducials(rhythmId, heartRate);
const rhythm = ECGDatabase.getRhythmById(rhythmId);
const lead = options.lead || 'II';
const leadTransform = this.getLeadTransform(lead, rhythm, rhythm?.waveformParams || {}) || {};
const leadPhaseShift = Number.isFinite(Number(leadTransform.phaseShift))
? Number(leadTransform.phaseShift)
: 0;
if (!fiducials.valid || !Array.isArray(fiducials.segments) || fiducials.segments.length === 0) {
if (options.showInvalidMessage) {
ctx.fillStyle = options.theme?.overlayTextColor || 'rgba(190, 24, 93, 0.9)';
ctx.font = '11px sans-serif';
ctx.fillText('Intervaloverlay niet valide voor dit ritme', 12, 14);
}
return;
}

const qrsStartPhase = Number(fiducials.qrsStartPhase || 0.16);
const qrsLeadPhase = ((qrsStartPhase - leadPhaseShift) % 1 + 1) % 1;
const firstQrsX = qrsLeadPhase * pixelsPerBeat;
const anchors = [];
const startBeat = Math.floor((-firstQrsX) / pixelsPerBeat) - 2;
const endBeat = Math.ceil((width - firstQrsX) / pixelsPerBeat) + 2;
for (let beat = startBeat; beat <= endBeat; beat++) {
const anchor = firstQrsX + (beat * pixelsPerBeat);
if (anchor > -pixelsPerBeat && anchor < width + pixelsPerBeat) {
anchors.push(anchor);
}
}
if (!anchors.length) return;

const targetX = Number.isFinite(Number(options.labelAnchorX))
? Number(options.labelAnchorX)
: width * 0.72;
let labelAnchor = anchors[0];
anchors.forEach(anchor => {
if (Math.abs(anchor - targetX) < Math.abs(labelAnchor - targetX)) {
labelAnchor = anchor;
}
});
const renderAnchors = options.fullWidthGuides === false ? [labelAnchor] : anchors;

const overlayRows = { PR: 0, QRS: 1, QT: 2 };
const topBase = 16;
const rowHeight = 13;
const subtleColorById = {
PR: 'rgba(6, 182, 212, 0.35)',
QRS: 'rgba(245, 158, 11, 0.38)',
QT: 'rgba(239, 68, 68, 0.35)'
};
const strongColorById = {
PR: 'rgba(6, 182, 212, 0.95)',
QRS: 'rgba(245, 158, 11, 0.95)',
QT: 'rgba(239, 68, 68, 0.95)'
};

renderAnchors.forEach(anchorX => {
const isLabelAnchor = Math.abs(anchorX - labelAnchor) < Math.max(2, pixelsPerBeat * 0.12);
fiducials.segments.forEach((segment, idx) => {
const startX = anchorX + ((segment.startPhase - qrsStartPhase) * pixelsPerBeat);
const endX = startX + (segment.durationSec * pxPerSecond);
if (endX < -40 || startX > width + 40) return;
const left = Math.max(0, startX);
const right = Math.min(width, endX);
if (right <= left) return;

const row = Number.isFinite(overlayRows[segment.id]) ? overlayRows[segment.id] : Math.min(3, idx);
const rowY = topBase + row * rowHeight;
ctx.strokeStyle = isLabelAnchor
? (strongColorById[segment.id] || segment.color)
: (subtleColorById[segment.id] || 'rgba(59, 130, 246, 0.35)');
ctx.lineWidth = isLabelAnchor
? (segment.id === 'QRS' ? 1.6 : 1.2)
: 0.9;
ctx.beginPath();
ctx.moveTo(left, rowY);
ctx.lineTo(right, rowY);
if (isLabelAnchor) {
ctx.moveTo(left, rowY - 4);
ctx.lineTo(left, rowY + 4);
ctx.moveTo(right, rowY - 4);
ctx.lineTo(right, rowY + 4);
}
ctx.stroke();

if (isLabelAnchor) {
ctx.fillStyle = strongColorById[segment.id] || segment.color;
ctx.font = '10px sans-serif';
const labelX = Math.max(8, Math.min(width - 26, ((left + right) / 2) - 9));
ctx.fillText(segment.label, labelX, rowY - 5);
}
});
});
},

drawCalibrationPulse(ctx, width, height, options = {}) {
if (!options.showCalibrationPulse) return;
const ppm = this.settings.pixelsPerMM;
const gain = Math.max(0.5, Math.min(2, Number(options.amplitude) || 1));
const verticalScale = Math.max(0.4, Math.min(2.4, Number(options.verticalScale) || 1));
const pulseHeight = Math.min(height * 0.62, ppm * 10 * gain * verticalScale);
const baseY = Math.round(height * 0.8);
const x0 = Math.max(2, width - 26);
const x1 = Math.max(4, width - 20);
const x2 = Math.max(6, width - 8);
const pulseColor = options.theme?.waveColor || this.settings.waveColor;
ctx.strokeStyle = pulseColor;
ctx.lineWidth = 1.4;
ctx.beginPath();
ctx.moveTo(x0, baseY);
ctx.lineTo(x1, baseY);
ctx.lineTo(x1, baseY - pulseHeight);
ctx.lineTo(x2, baseY - pulseHeight);
ctx.lineTo(x2, baseY);
ctx.lineTo(Math.min(width - 2, x2 + 2), baseY);
ctx.stroke();
},

 drawLeadStrip(canvasId, rhythm, options = {}) {
 return this.drawStaticStrip(canvasId, rhythm, options);
 },

 drawTwelveLeadGrid(rootId, rhythm, options = {}) {
 const leads = Array.isArray(options.leads) && options.leads.length
 ? options.leads
 : this.LEAD_ORDER;
 const pulseLeads = Array.isArray(options.showCalibrationPulseLeads)
 ? options.showCalibrationPulseLeads
 : null;
 const pulseResolver = typeof options.showCalibrationPulseForLead === 'function'
 ? options.showCalibrationPulseForLead
 : null;
 const { showCalibrationPulseLeads, showCalibrationPulseForLead, ...restOptions } = options;
 leads.forEach((lead, index) => {
 const canvasId = typeof options.canvasIdBuilder === 'function'
 ? options.canvasIdBuilder(lead)
 : this.buildLeadCanvasId(rootId, lead);
 const showPulse = pulseResolver
 ? !!pulseResolver(lead, index, leads)
 : (pulseLeads ? pulseLeads.includes(lead) : !!restOptions.showCalibrationPulse);
 this.drawLeadStrip(canvasId, rhythm, {
 ...restOptions,
 lead,
 showCalibrationPulse: showPulse
 });
 });
 },

 // Draw static ECG strip
 drawStaticStrip(canvasId, rhythm, options = {}) {
 const canvas = document.getElementById(canvasId);
 if (!canvas) return;

 const ctx = canvas.getContext('2d');
 const rect = canvas.getBoundingClientRect();
 
 canvas.width = rect.width * window.devicePixelRatio;
 canvas.height = rect.height * window.devicePixelRatio;
 ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

 const width = rect.width;
 const height = rect.height;
const heartRate = options.heartRate || 72;
const amplitude = options.amplitude || 1;
const verticalScale = options.verticalScale || 1;
const signalNoise = options.signalNoise || options.muscleNoise || 0;
const muscleNoise = options.muscleNoise || signalNoise;
const baselineWander = options.baselineWander || 0;
const powerlineNoise = options.powerlineNoise || 0;
const powerlineHz = options.powerlineHz || 50;
const lineWidth = options.lineWidth || 2;
const shadowBlur = options.shadowBlur || 3;

 // Draw grid
 this.drawGrid(ctx, width, height, options.theme);

 // Calculate parameters
 const ppm = this.settings.pixelsPerMM;
 const speed = options.speed || 25;
 const pixelsPerSecond = speed * ppm;
 const beatsPerSecond = heartRate / 60;
 const pixelsPerBeat = pixelsPerSecond / beatsPerSecond;
 const phasePerPixel = 1 / pixelsPerBeat;
 const rhythmData = ECGDatabase.getRhythmById(rhythm);
 const wp = rhythmData?.waveformParams || {};

 const baseline = height / 2;
 // ECG calibration: 10 mm/mV at gain 1x. `verticalScale` is only a multiplier.
 const scale = this.settings.pixelsPerMM * this.settings.amplitude * verticalScale;

 // Draw waveform
 const waveColor = options.theme?.waveColor || this.settings.waveColor;
 ctx.strokeStyle = waveColor;
 ctx.lineWidth = lineWidth;
 ctx.lineCap = 'round';
 ctx.lineJoin = 'round';
 ctx.shadowColor = waveColor;
 ctx.shadowBlur = shadowBlur;

 ctx.beginPath();
 for (let x = 0; x < width; x++) {
 let phase = (x * phasePerPixel) % 1;
 
 // Add variability where configured.
 const rrVar = Number(wp.rrVariability || wp.variability || (wp.variableRR ? 0.25 : 0));
 if (rrVar > 0) {
 phase += Math.sin(x * 0.02) * Math.min(0.35, rrVar * 0.3);
 }

 const value = this.generateWaveformPoint(rhythm, phase, {
 amplitude,
 time: x / pixelsPerSecond,
 heartRate,
 lead: options.lead || 'II'
 });
const wanderOffset = baselineWander
? Math.sin((x / Math.max(1, width)) * Math.PI * 2 * 1.25) * baselineWander * scale
: 0;
const noiseOffset = muscleNoise
? (Math.random() - 0.5) * muscleNoise * scale
: 0;
const powerlineOffset = powerlineNoise
? Math.sin((x / Math.max(1, pixelsPerSecond)) * Math.PI * 2 * powerlineHz) * powerlineNoise * scale
: 0;
const y = baseline + wanderOffset - value * scale + noiseOffset + powerlineOffset;

 if (x === 0) {
 ctx.moveTo(x, y);
 } else {
 ctx.lineTo(x, y);
 }
 }
 ctx.stroke();
 ctx.shadowBlur = 0;

this.drawCalibrationPulse(ctx, width, height, {
amplitude,
verticalScale,
showCalibrationPulse: options.showCalibrationPulse,
theme: options.theme
});


},

 // Change rhythm on running canvas
 setRhythm(canvasId, rhythm, heartRate) {
 const config = this.activeCanvases.get(canvasId);
 if (!config) return;

 config.rhythm = rhythm;
 if (heartRate) config.heartRate = heartRate;
 this.resetSweep(canvasId);
 },

 // Reset waveform sweep to a clean start.
 resetSweep(canvasId) {
 const config = this.activeCanvases.get(canvasId);
 if (!config) return;

 config.x = 0;
 config.buffer = [];
 this.drawGrid(config.ctx, config.width, config.height, config.theme);
 },

 // Cleanup
 destroy(canvasId) {
 this.stop(canvasId);
 this.activeCanvases.delete(canvasId);
 },

 // Destroy all
 destroyAll() {
 for (const [id] of this.activeCanvases) {
 this.destroy(id);
 }
 }
 };

 // ==================== SECTION RENDERERS ====================
 const Sections = {
 
 // ========== DASHBOARD ==========
 renderDashboard(container) {
 const user = AppState.user;
 const levelInfo = Utils.calculateLevel(user.xp);
 const accuracy = Utils.calcAccuracy(user.totalCorrect, user.totalAnswered);
 const weeklyFocus = LearningPathEngine.getWeeklyFocus();
 const dailyRound = LearningPathEngine.getDailyRound();
 const dailyDone = dailyRound.completedCaseIds.length;
 const onboardingDone = AppState.ui?.onboardingCompleted === true;
 const contextHelp = ECGApp.getContextHelpHTML('dashboard');

 container.innerHTML = `
 ${contextHelp}
 ${!onboardingDone ? `
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Snelle Start (3 min)</h3>
 </div>
 <div class="card-body">
 <div class="grid-3">
 <div class="topic-card">
 <div class="topic-card-title">1. Monitor basis</div>
 <div class="topic-card-desc">Open monitor en wissel 2 ritmes.</div>
 <button class="btn btn-sm btn-outline" onclick="Navigation.navigateTo('monitor')">Start</button>
 </div>
 <div class="topic-card">
 <div class="topic-card-title">2. Module 1 quiz</div>
 <div class="topic-card-desc">Doe een korte basisquiz in leerpad.</div>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.startModulePractice('module_1')">Start</button>
 </div>
 <div class="topic-card">
 <div class="topic-card-title">3. Eerste case</div>
 <div class="topic-card-desc">Koppel ECG aan kliniek in een case.</div>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.startCase('case_chest_pain')">Start</button>
 </div>
 </div>
<button class="btn btn-primary btn-sm mt-2" onclick="ECGApp.completeOnboarding()">Snelle start afgerond</button>
 </div>
 </div>
 ` : ''}

 <div class="grid-2">
 <!-- Welcome Card -->
 <div class="card">
 <div class="card-body">
 <h2 style="font-size: 1.5rem; margin-bottom: 0.5rem;"> Welkom bij ECG Trainer Pro
 </h2>
 <p class="text-muted" style="margin-bottom: 1.5rem;"> Master ECG interpretatie met interactieve oefeningen
 </p>
 
 <div class="vitals-grid" style="margin-bottom: 1.5rem;">
 <div class="vital-card">
 <div class="vital-card-label">Niveau</div>
 <div class="vital-card-value text-primary">${levelInfo.level}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">XP</div>
 <div class="vital-card-value text-success">${user.xp}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Reeks</div>
 <div class="vital-card-value text-warning">${user.streak}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Nauwkeurig</div>
 <div class="vital-card-value text-info">${accuracy}%</div>
 </div>
 </div>

 <div class="progress-bar" style="margin-bottom: 0.5rem;">
 <div class="progress-fill" style="width: ${(levelInfo.currentXP / levelInfo.nextLevelXP) * 100}%"></div>
 </div>
 <p class="text-muted" style="font-size: 0.8rem;">
 ${levelInfo.currentXP} / ${levelInfo.nextLevelXP} XP naar niveau ${levelInfo.level + 1}
 </p>
 </div>
 </div>

 <!-- Quick Stats -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Statistieken</h3>
 </div>
 <div class="card-body">
 <div style="display: grid; gap: 1rem;">
 <div style="display: flex; justify-content: space-between; padding: 0.75rem; background: var(--bg-elevated); border-radius: 8px;">
 <span>Vragen beantwoord</span>
 <strong>${user.totalAnswered}</strong>
 </div>
 <div style="display: flex; justify-content: space-between; padding: 0.75rem; background: var(--bg-elevated); border-radius: 8px;">
 <span>Correct</span>
 <strong class="text-success">${user.totalCorrect}</strong>
 </div>
 <div style="display: flex; justify-content: space-between; padding: 0.75rem; background: var(--bg-elevated); border-radius: 8px;">
 <span>Ritmes beheerst</span>
 <strong class="text-primary">${user.masteredRhythms.length}</strong>
 </div>
 <div style="display: flex; justify-content: space-between; padding: 0.75rem; background: var(--bg-elevated); border-radius: 8px;">
 <span>Topics voltooid</span>
 <strong class="text-info">${user.completedTopics.length}</strong>
 </div>
 </div>
 </div>
 </div>
 </div>

 <!-- Quick Actions -->
 <div class="card">
 <div class="card-header">
<h3 class="card-title">Snel Starten</h3>
 </div>
 <div class="card-body">
 <div class="quick-actions">
 <div class="quick-action" onclick="ECGApp.startQuickQuiz()">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Snelle Quiz</div>
 <div class="quick-action-desc">10 willekeurige vragen</div>
 </div>
 <div class="quick-action" onclick="Navigation.navigateTo('monitor')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Monitor Simulator</div>
 <div class="quick-action-desc">Live ECG ritmes bekijken</div>
 </div>
 <div class="quick-action" onclick="Navigation.navigateTo('library')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">ECG Bibliotheek</div>
 <div class="quick-action-desc">45+ ritmes bestuderen</div>
 </div>
 <div class="quick-action" onclick="Navigation.navigateTo('acls')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">ACLS Protocollen</div>
 <div class="quick-action-desc">Spoed algoritmes</div>
 </div>
 <div class="quick-action" onclick="ECGApp.startCriticalQuiz()">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Kritieke Ritmes</div>
 <div class="quick-action-desc">Focus op levensbedreigende aritmieën</div>
 </div>
 <div class="quick-action" onclick="Navigation.navigateTo('cases')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Klinische Cases</div>
 <div class="quick-action-desc">Praktijkscenario's</div>
 </div>
 </div>
 </div>
 </div>

 <div class="grid-2">
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Leerpad Focus</h3>
 </div>
 <div class="card-body">
 <p class="text-muted mb-2">Aanbevolen volgende stap: <strong>${LearningPathEngine.getCurrentModule()?.title || 'Module 1'}</strong></p>
 <ul class="styled-list">
 ${weeklyFocus.map(item => `<li>${item.name} (${item.accuracy}%)</li>`).join('')}
 </ul>
 <button class="btn btn-primary btn-sm mt-2" onclick="Navigation.navigateTo('learningPath')">Naar Leerpad</button>
 </div>
 </div>
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Dagelijkse Klinische Ronde</h3>
 </div>
 <div class="card-body">
 <p class="text-muted mb-2">Voortgang vandaag: <strong>${dailyDone}/${dailyRound.caseIds.length}</strong></p>
 <div class="btn-group">
 ${dailyRound.caseIds.map(caseId => {
 const caseData = ClinicalCases.getCaseById(caseId);
 if (!caseData) return '';
 const done = dailyRound.completedCaseIds.includes(caseId);
 return `<button class="btn btn-sm ${done ? 'btn-success' : 'btn-outline'}" onclick="ECGApp.startDailyCase('${caseId}')">${done ? '&#10003;' : '&#9675;'} ${caseData.title}</button>`;
 }).join('')}
 </div>
 </div>
 </div>
 </div>

 <!-- Category Overview -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Categorieën</h3>
 </div>
 <div class="card-body">
 <div class="grid-4">
 ${Object.entries(ECGDatabase.categories).map(([id, cat]) => {
 const count = ECGDatabase.getRhythmsByCategory(id).length;
 return `
 <div class="topic-card" onclick="ECGApp.openCategoryQuiz('${id}')">
 <div class="topic-card-icon">${cat.icon}</div>
 <div class="topic-card-title">${cat.name}</div>
 <div class="topic-card-desc">${cat.description}</div>
 <div class="topic-card-meta">
 <span>${count} ritmes</span>
 <span class="badge badge-info">Oefen nu</span>
 </div>
 </div>
 `;
 }).join('')}
 </div>
 </div>
 </div>

 <!-- Recent Critical Rhythms -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Kritieke Ritmes - Ken Deze!</h3>
 </div>
 <div class="card-body">
 <div class="info-box danger">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Levensbedreigende Aritmieën</h4>
 <p>Deze ritmes vereisen onmiddellijke actie. Zorg dat je ze direct herkent!</p>
 </div>
 </div>
 <div class="rhythm-grid" style="margin-top: 1rem;">
 ${ECGDatabase.getCriticalRhythms().slice(0, 6).map(rhythm => `
 <button class="rhythm-btn" onclick="ECGApp.showRhythmDetail('${rhythm.id}')">
 <span class="rhythm-indicator red"></span>
 <span>${rhythm.name}</span>
 </button>
 `).join('')}
 </div>
 </div>
 </div>
 `;
 },
 // ========== MONITOR SIMULATOR ==========
 renderMonitor(container) {
 const rhythms = ECGDatabase.getAllRhythms();
 const monitorUi = ECGApp.ensureMonitorUiState();
 const currentRhythm = ECGDatabase.getRhythmById(AppState.monitor.currentRhythm);
 const monitorSpeed = AppState.monitor.speed || 25;
 const monitorGain = AppState.monitor.amplitude || 1;
 const monitorZoom = AppState.monitor.zoom || 1;
 const monitorLead = AppState.monitor.lead || 'II';
 const artifactLevel = AppState.monitor.artifactLevel || 'none';
 const renderOptions = ECGApp.getMonitorRenderOptions();
 const visualProfile = ECGApp.getMonitorVisualProfile();
 const smallBoxSeconds = (1 / monitorSpeed).toFixed(2);
 const largeBoxSeconds = (5 / monitorSpeed).toFixed(2);
const smallBoxMV = (0.1 / monitorGain).toFixed(2);
const largeBoxMV = (0.5 / monitorGain).toFixed(2);
const allLeads = ECGRenderer.LEAD_ORDER || ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
const displayLeadOrder = ECGApp.getTwelveLeadDisplayOrder().filter(lead => allLeads.includes(lead));
const leadRows = [
['I', 'II', 'III'],
['aVR', 'aVL', 'aVF'],
['V1', 'V2', 'V3'],
 ['V4', 'V5', 'V6']
 ];
 const escapeAttr = (value) => String(value || '')
 .replace(/&/g, '&amp;')
 .replace(/"/g, '&quot;')
 .replace(/</g, '&lt;')
 .replace(/>/g, '&gt;');
 const searchRaw = monitorUi.rhythmSearch || '';
 const searchTerm = searchRaw.trim().toLowerCase();
 const selectedCategory = monitorUi.rhythmCategory || 'all';
 const matchesSearch = (rhythm) => {
 if (!searchTerm) return true;
 const haystack = `${rhythm.name || ''} ${rhythm.shortName || ''} ${rhythm.id || ''}`.toLowerCase();
 return haystack.includes(searchTerm);
 };
 const searchFiltered = rhythms.filter(matchesSearch);
 const categoryCounts = {};
 searchFiltered.forEach(r => {
 categoryCounts[r.category] = (categoryCounts[r.category] || 0) + 1;
 });
 const filteredRhythms = searchFiltered.filter(r => selectedCategory === 'all' || r.category === selectedCategory);
 const groupedCategories = Object.entries(ECGDatabase.categories).map(([catId, cat]) => ({
 catId,
 cat,
 rhythms: filteredRhythms.filter(r => r.category === catId)
 })).filter(group => group.rhythms.length > 0);
 const totalVisible = filteredRhythms.length;
 const hasResults = totalVisible > 0;

 container.innerHTML = `
 ${ECGApp.getContextHelpHTML('monitor')}
<div class="monitor-layout-single">
<div class="card monitor-print-card">
<div class="card-header">
<h3 class="card-title">12-afleidingen ECG Print</h3>
<span class="quiz-calibration-chip">Kalibratie 25 mm/s | 10 mm/mV</span>
</div>
<div class="card-body">
<p class="text-muted" style="font-size:0.86rem;">Alle 12 leads delen dezelfde tijd-as en gain. Klik op een mini-lead om de ritmestrook (onder) te wisselen.</p>
<div class="monitor-paper-wrapper">
<div class="monitor-paper-grid">
${displayLeadOrder.map(lead => `
<div class="monitor-paper-lead ${monitorLead === lead ? 'active' : ''}" onclick="ECGApp.setMonitorLead('${lead}')">
<canvas id="${ECGApp.getMonitorLeadCanvasId(lead)}" class="monitor-paper-canvas"></canvas>
<div class="monitor-paper-lead-label">${lead}</div>
</div>
`).join('')}
</div>
<div class="monitor-rhythm-strip">
<div class="monitor-rhythm-strip-header">
<span class="monitor-rhythm-strip-title">Ritmestrook (focus): Lead ${monitorLead}</span>
<span class="monitor-paper-note">HR <strong id="monitorHR">${AppState.monitor.heartRate}</strong> bpm</span>
</div>
<div class="monitor-paper-lead active" style="cursor: default;">
<canvas id="monitorCanvas" class="monitor-rhythm-canvas"></canvas>
<div class="monitor-paper-lead-label">Lead ${monitorLead}</div>
</div>
</div>
<div class="monitor-paper-footer">
<span>Snelheid: ${monitorSpeed} mm/s</span>
<span>Limb: 10 mm/mV | Chest: 10 mm/mV</span>
<span>Filter: 0.15-150 Hz (educatief)</span>
</div>
</div>

<div class="monitor-controls">
<div class="monitor-quickbar">
<div class="monitor-quick-row">
<button class="btn btn-sm ${AppState.monitor.isRunning ? 'btn-danger' : 'btn-success'}"
 id="monitorToggle"
 onclick="ECGApp.toggleMonitor()">
 ${AppState.monitor.isRunning ? 'Pauze' : 'Start'}
 </button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.toggleMonitorAdvanced()">
 ${monitorUi.advancedOpen ? 'Geavanceerd verbergen' : 'Geavanceerd tonen'}
 </button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.toggleMonitorRhythmPanel()">
 ${monitorUi.rhythmPanelOpen ? 'Ritmelijst inklappen' : 'Ritmelijst tonen'}
 </button>
 </div>

 <div class="monitor-quick-slider">
 <label for="monitorHrInput">Hartfrequentie: <strong id="hrValue">${AppState.monitor.heartRate}</strong> bpm</label>
<input id="monitorHrInput" type="range" min="30" max="200" value="${AppState.monitor.heartRate}" oninput="ECGApp.setMonitorHR(this.value, false)" onchange="ECGApp.setMonitorHR(this.value, true)">
 </div>

 <div class="monitor-quick-selects">
 <div>
 <label for="monitorLeadSelect">Lead</label>
 <select id="monitorLeadSelect" onchange="ECGApp.setMonitorLead(this.value)">
 ${allLeads.map(lead => `<option value="${lead}" ${monitorLead === lead ? 'selected' : ''}>Lead ${lead}</option>`).join('')}
 </select>
 </div>
 <div class="btn-group">
 <button class="btn btn-sm ${monitorSpeed === 25 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorSpeed(25)">25 mm/s</button>
 <button class="btn btn-sm ${monitorGain === 1 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorGain(1)">Gain 1x</button>
 </div>
 <div class="btn-group">
 <button id="monitorFreezeBtn" class="btn btn-sm btn-outline" onclick="ECGApp.toggleMonitorFreeze()">
${AppState.monitor.freezeFrame ? 'Hervat' : 'Freeze'}
</button>
 </div>
 </div>

 <div class="monitor-meta-line">
 <span class="quiz-calibration-chip">Kalibratie 25 mm/s | 10 mm/mV</span>
 <span class="quiz-calibration-chip">Actueel: ${monitorSpeed} mm/s | Gain ${monitorGain}x | Zoom ${monitorZoom}x | Artifact ${artifactLevel}</span>
 </div>
 </div>

${monitorUi.advancedOpen ? `
<div class="monitor-advanced-panel">
<div class="monitor-advanced-grid">
 <div class="monitor-advanced-card">
 <div class="monitor-advanced-title">Sweep / Gain / Zoom</div>
 <div class="btn-group">
 <button class="btn btn-sm ${monitorSpeed === 12.5 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorSpeed(12.5)">12.5</button>
 <button class="btn btn-sm ${monitorSpeed === 25 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorSpeed(25)">25</button>
 <button class="btn btn-sm ${monitorSpeed === 50 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorSpeed(50)">50</button>
 </div>
 <div class="btn-group mt-2">
 <button class="btn btn-sm ${monitorGain === 0.5 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorGain(0.5)">G 0.5x</button>
 <button class="btn btn-sm ${monitorGain === 1 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorGain(1)">G 1x</button>
 <button class="btn btn-sm ${monitorGain === 2 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorGain(2)">G 2x</button>
 </div>
 <div class="btn-group mt-2">
 <button class="btn btn-sm ${monitorZoom === 1 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorZoom(1)">Z 1x</button>
 <button class="btn btn-sm ${monitorZoom === 1.5 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorZoom(1.5)">Z 1.5x</button>
 <button class="btn btn-sm ${monitorZoom === 2 ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorZoom(2)">Z 2x</button>
 </div>
 </div>

 <div class="monitor-advanced-card">
 <div class="monitor-advanced-title">Artifact & kalibratie</div>
 <div class="btn-group">
 <button class="btn btn-sm ${artifactLevel === 'none' ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorArtifact('none')">Artifact uit</button>
 <button class="btn btn-sm ${artifactLevel === 'low' ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorArtifact('low')">Laag</button>
 <button class="btn btn-sm ${artifactLevel === 'medium' ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorArtifact('medium')">Medium</button>
 </div>
 <p class="text-muted" style="font-size:0.8rem; margin-top:0.5rem;"> Tijd/hokje: klein ${smallBoxSeconds}s, groot ${largeBoxSeconds}s | mV/hokje: klein ${smallBoxMV}, groot ${largeBoxMV}
 </p>
 </div>
 </div>

 <div class="monitor-advanced-card">
 <div class="monitor-advanced-title">Lead selectie (12)</div>
 <div class="btn-group" style="margin-bottom:0.45rem;">
 <button class="btn btn-sm btn-outline" onclick="ECGApp.toggleMonitorLeadPad()">
 ${monitorUi.showLeadPad ? 'Lead-pad verbergen' : 'Lead-pad tonen'}
 </button>
 </div>
 ${monitorUi.showLeadPad ? `
 ${leadRows.map(row => `
 <div class="monitor-lead-grid" style="margin-bottom:0.3rem;">
 ${row.map(lead => `
 <button class="btn btn-sm ${monitorLead === lead ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorLead('${lead}')">${lead}</button>
 `).join('')}
 </div>
 `).join('')}
 ` : '<p class="text-muted" style="font-size:0.8rem;">Gebruik de dropdown in Basisweergave om snel van lead te wisselen.</p>'}
 </div>
</div>
` : ''}
</div>
</div>
</div>

<div class="card">
 <div class="card-header">
 <h3 class="card-title" id="monitorRhythmTitle">
 ${Utils.getCategoryIcon(currentRhythm?.category)}
 ${currentRhythm?.name || 'Selecteer een ritme'}
 </h3>
 <span class="badge ${Utils.getDifficultyBadge(currentRhythm?.difficulty)}" id="monitorRhythmDifficulty">
 ${currentRhythm?.difficulty || ''}
 </span>
 </div>
 <div class="card-body">
 <p class="text-muted mb-2" id="monitorRhythmDescription">${currentRhythm?.description || ''}</p>
 <p class="text-muted" style="font-size:0.85rem;">Visuele tip: let op regelmaat R-R, QRS-breedte en relatie P-QRS zoals op een echte bedside monitor.</p>
 <div id="monitorRhythmFeatures">
 ${currentRhythm ? `
 <div class="info-box info">
 <div class="info-box-icon">i</div>
 <div class="info-box-content">
 <h4>ECG Kenmerken</h4>
 <ul class="styled-list">
 ${currentRhythm.ecgFeatures.slice(0, 4).map(f => `<li>${f}</li>`).join('')}
 </ul>
 </div>
 </div>
 ` : ''}
 </div>
 </div>
 </div>

 <div class="card rhythm-browser">
 <div class="card-header">
 <h3 class="card-title">Ritmebrowser</h3>
 <span class="text-muted" style="font-size:0.8rem;">${totalVisible} zichtbaar</span>
 </div>
 ${monitorUi.rhythmPanelOpen ? `
 <div class="card-body">
 <input class="rhythm-browser-search"
 type="text"
 placeholder="Zoek ritme (naam of afkorting)..."
 value="${escapeAttr(searchRaw)}"
 oninput="ECGApp.setMonitorRhythmSearch(this.value)">
 <div class="monitor-filter-chips">
 <button class="btn btn-sm ${selectedCategory === 'all' ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorRhythmCategory('all')"> Alle (${searchFiltered.length})
 </button>
 ${Object.entries(ECGDatabase.categories).map(([catId, cat]) => {
 const count = categoryCounts[catId] || 0;
 return `
 <button class="btn btn-sm ${selectedCategory === catId ? 'btn-primary' : 'btn-outline'}" onclick="ECGApp.setMonitorRhythmCategory('${catId}')">
 ${cat.icon} ${cat.name} (${count})
 </button>
 `;
 }).join('')}
 </div>
 <div class="rhythm-browser-list">
 ${hasResults ? groupedCategories.map(({ catId, cat, rhythms: catRhythms }) => {
 const shouldOpen = searchTerm ? true : currentRhythm?.category === catId;
 return `
 <div class="accordion-item ${shouldOpen ? 'open' : ''}" style="margin-bottom:0.5rem; border: 1px solid var(--border); border-radius: 8px;">
 <div class="accordion-header" onclick="this.parentElement.classList.toggle('open')">
 <h4>${cat.icon} ${cat.name} (${catRhythms.length})</h4>
 <span class="accordion-icon">v</span>
 </div>
 <div class="accordion-body">
 <div style="padding: 0.45rem;">
 ${catRhythms.map(r => `
 <button class="rhythm-btn ${AppState.monitor.currentRhythm === r.id ? 'active' : ''}"
 data-rhythm-id="${r.id}"
 onclick="ECGApp.setMonitorRhythm('${r.id}')"
 style="width: 100%; margin-bottom: 0.25rem;">
 <span class="rhythm-indicator ${r.urgency === 'critical' ? 'red' : r.urgency === 'high' ? 'yellow' : 'green'}"></span>
 <span style="flex: 1; text-align: left;">${r.name}</span>
 <span class="badge ${Utils.getDifficultyBadge(r.difficulty)}" style="font-size:0.58rem; padding:0.12rem 0.38rem;">${r.difficulty}</span>
 </button>
 `).join('')}
 </div>
 </div>
 </div>
 `;
 }).join('') : `
 <div class="info-box warning">
 <div class="info-box-icon">!</div>
 <div class="info-box-content">
 <h4>Geen ritmes gevonden</h4>
 <p>Pas zoekterm of categorie-filter aan om ritmes te tonen.</p>
 </div>
 </div>
 `}
 </div>
 </div>
 ` : ''}
 </div>
 </div>
 `;

// Initialize monitor
setTimeout(() => {
const paperTheme = ECGApp.getPaperTheme();
ECGApp.redrawMonitorLeadOverview();
ECGRenderer.initCanvas('monitorCanvas', {
rhythm: AppState.monitor.currentRhythm,
heartRate: AppState.monitor.heartRate,
speed: monitorSpeed,
amplitude: AppState.monitor.amplitude || 1,
 verticalScale: visualProfile.verticalScale,
 lineWidth: visualProfile.lineWidth,
 shadowBlur: visualProfile.shadowBlur,
lead: monitorLead,
signalNoise: renderOptions.signalNoise,
muscleNoise: renderOptions.muscleNoise,
baselineWander: renderOptions.baselineWander,
powerlineNoise: renderOptions.powerlineNoise,
powerlineHz: renderOptions.powerlineHz,
showCalibrationPulse: false,
theme: paperTheme
});
if (AppState.monitor.isRunning && !AppState.monitor.freezeFrame) {
ECGRenderer.start('monitorCanvas', { reset: false });
} else {
ECGRenderer.drawStaticStrip('monitorCanvas', AppState.monitor.currentRhythm, {
heartRate: AppState.monitor.heartRate,
speed: monitorSpeed,
 amplitude: AppState.monitor.amplitude || 1,
 verticalScale: visualProfile.verticalScale,
 lineWidth: visualProfile.lineWidth,
 shadowBlur: visualProfile.shadowBlur,
lead: monitorLead,
signalNoise: renderOptions.signalNoise,
muscleNoise: renderOptions.muscleNoise,
baselineWander: renderOptions.baselineWander,
powerlineNoise: renderOptions.powerlineNoise,
powerlineHz: renderOptions.powerlineHz,
showCalibrationPulse: false,
theme: paperTheme
});
}
}, 100);
 },

 // ========== ECG LIBRARY ==========
 renderLibrary(container) {
 const categories = ECGDatabase.categories;
 const selectedCat = AppState.library.selectedCategory;
 const searchQuery = AppState.library.searchQuery;
 const libraryView = ECGApp.getLibraryViewState();
 const libraryLead = (ECGRenderer.LEAD_ORDER || []).includes(libraryView.defaultLead) ? libraryView.defaultLead : 'II';
 const previewSeconds = Math.max(4, Math.min(12, Number(libraryView.previewSeconds) || 8));
 const compactCards = libraryView.compactCards === true;
 ECGApp.cleanupLibraryPreviewObserver();

 let rhythms = selectedCat === 'all' 
 ? ECGDatabase.getAllRhythms() 
 : ECGDatabase.getRhythmsByCategory(selectedCat);

 if (searchQuery) {
 rhythms = ECGDatabase.searchRhythms(searchQuery);
 }

 const getLooksLikeText = (rhythm) => {
 const explicit = Array.isArray(rhythm.looksLike) ? rhythm.looksLike : [];
 if (explicit.length) return explicit.slice(0, 3).join(', ');
 const ids = Array.isArray(rhythm.differentialIds) ? rhythm.differentialIds : [];
 const names = ids
 .map(id => ECGDatabase.getRhythmById(id)?.name)
 .filter(Boolean);
 if (names.length) return names.slice(0, 3).join(', ');
 const lookalikes = Array.isArray(rhythm.lookalikes) ? rhythm.lookalikes : [];
 const byLookalike = lookalikes
 .map(item => ECGDatabase.getRhythmById(item?.id)?.name)
 .filter(Boolean);
 return byLookalike.length ? byLookalike.slice(0, 3).join(', ') : 'Geen directe lookalike opgegeven.';
 };

 const getDistinguishersText = (rhythm) => {
 const explicit = Array.isArray(rhythm.keyDistinguishers) ? rhythm.keyDistinguishers.filter(Boolean) : [];
 if (explicit.length) return explicit.slice(0, 3).join(' | ');
 const fromFeatures = Array.isArray(rhythm.ecgFeatures) ? rhythm.ecgFeatures.filter(Boolean) : [];
 return fromFeatures.length ? fromFeatures.slice(0, 3).join(' | ') : 'Gebruik systematische analyse: regelmaat, QRS-breedte en P-QRS-relatie.';
 };

 const getFirstSafeStepText = (rhythm) => {
 if (typeof rhythm.firstSafeStep === 'string' && rhythm.firstSafeStep.trim().length) return rhythm.firstSafeStep;
 if (typeof rhythm.firstAction === 'string' && rhythm.firstAction.trim().length) return rhythm.firstAction;
 return 'Start met hemodynamische beoordeling en volg lokaal protocol.';
 };

 container.innerHTML = `
 <div class="card mb-2">
 <div class="card-body">
 <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
 <!-- Search -->
 <div style="flex: 1; min-width: 200px;">
 <input type="text" 
 placeholder="Zoek ritme..." 
 value="${searchQuery}"
 oninput="ECGApp.searchLibrary(this.value)"
 style="width: 100%; padding: 0.75rem 1rem; background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 0.95rem;">
 </div>
 
 <!-- Category Filter -->
 <select onchange="ECGApp.filterLibrary(this.value)"
 style="padding: 0.75rem 1rem; background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 0.95rem; min-width: 180px;">
 <option value="all" ${selectedCat === 'all' ? 'selected' : ''}>Alle categorieën</option>
 ${Object.entries(categories).map(([id, cat]) => `
 <option value="${id}" ${selectedCat === id ? 'selected' : ''}>
 ${cat.icon} ${cat.name}
 </option>
 `).join('')}
 </select>

 <!-- Count -->
 <span class="text-muted">${rhythms.length} ritmes</span>
 </div>
 </div>
 </div>

 <!-- Rhythm Grid -->
 <div class="library-grid-readable">
 ${rhythms.map(rhythm => `
 <div class="card library-rhythm-card" onclick="ECGApp.showRhythmDetail('${rhythm.id}')">
 <div class="card-body">
 <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
 <div>
 <h3 style="font-size: 1rem; margin-bottom: 0.25rem;">${rhythm.name}</h3>
 <span class="text-muted" style="font-size: 0.8rem;">${rhythm.shortName}</span>
 </div>
 <span class="badge ${Utils.getDifficultyBadge(rhythm.difficulty)}">${rhythm.difficulty}</span>
 </div>

 <div class="library-meta-row">
 <span class="library-calibration-chip">25 mm/s | 10 mm/mV</span>
 <span class="library-calibration-chip">Lead ${libraryLead}</span>
 <span class="library-calibration-chip">~${previewSeconds}s strip</span>
 <span class="library-calibration-chip">${Utils.getCategoryIcon(rhythm.category)} ${categories[rhythm.category]?.name || ''}</span>
 </div>

 <!-- Leesbare ECG Preview -->
 <div class="monitor-paper-wrapper library-preview-monitor">
 <div class="monitor-paper-lead active" style="cursor: default;">
 <canvas id="preview_${rhythm.id}" class="library-preview-canvas" data-rhythm-id="${rhythm.id}"></canvas>
 <div class="monitor-paper-lead-label">Lead ${libraryLead}</div>
 </div>
 </div>

 <p class="library-signature">
 <strong>Kernpatroon:</strong> ${rhythm.signaturePattern || rhythm.whyCorrect || rhythm.description}
 </p>

 ${!compactCards ? `
 <div class="library-diff-block">
 <div><strong>Lijkt op:</strong> ${getLooksLikeText(rhythm)}</div>
 <div><strong>Zo onderscheid je het:</strong> ${getDistinguishersText(rhythm)}</div>
 <div><strong>Eerste veilige stap:</strong> ${getFirstSafeStepText(rhythm)}</div>
 </div>
 ` : ''}

 <p class="library-desc">
 ${rhythm.description}
 </p>

 <div style="display: flex; justify-content: space-between; align-items: center;">
 <span style="font-size: 0.75rem;" class="text-muted">
 Richtlijn: ERC/ESC default
 </span>
 <span>
 ${rhythm.urgency === 'critical' ? '<span class="badge badge-critical">KRITIEK</span>' : ''}
 ${rhythm.urgency === 'high' ? '<span class="badge badge-hard">URGENT</span>' : ''}
 </span>
 </div>
 </div>
 </div>
 `).join('')}
 </div>
 `;

 // Draw preview strips (batch + lazy on scroll)
 setTimeout(() => {
 const canvases = Array.from(container.querySelectorAll('.library-preview-canvas'));
 if (!canvases.length) return;

 const drawPreview = (canvas) => {
 if (!canvas || canvas.dataset.rendered === '1') return;
 const rhythmId = canvas.dataset.rhythmId;
 const rhythm = ECGDatabase.getRhythmById(rhythmId);
 if (!rhythm) return;
 ECGRenderer.drawStaticStrip(canvas.id, rhythm.id, ECGApp.getLibraryRenderOptions(rhythm, {
 lead: libraryLead
 }));
 canvas.dataset.rendered = '1';
 };

 const batchSize = Math.max(1, Math.min(canvases.length, Number(libraryView.lazyRenderBatch) || 12));
 canvases.slice(0, batchSize).forEach(drawPreview);
 const deferred = canvases.slice(batchSize);
 if (!deferred.length) return;

 if ('IntersectionObserver' in window) {
 const observer = new IntersectionObserver((entries) => {
 entries.forEach(entry => {
 if (entry.isIntersecting) {
 drawPreview(entry.target);
 observer.unobserve(entry.target);
 }
 });
 }, { root: null, rootMargin: '180px 0px', threshold: 0.05 });
 ECGApp.libraryPreviewObserver = observer;
 deferred.forEach(canvas => observer.observe(canvas));
 } else {
 deferred.forEach(drawPreview);
 }
 }, 90);
 },

 // ========== SYSTEMATIC ANALYSIS ==========
 renderSystematic(container) {
 const checklist = AppState.learningPath?.checklistTraining || { sessions: 0, activeSince: null, lastCompleted: null };
 const elapsed = LearningPathEngine.getChecklistElapsedMinutes();

 container.innerHTML = `
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Systematische ECG Analyse</h3>
 </div>
 <div class="card-body">
 <div class="info-box info mb-3">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Gebruik altijd een systematische aanpak!</h4>
 <p>Een gestructureerde benadering voorkomt dat je belangrijke bevindingen mist.</p>
 </div>
 </div>

 <div class="algorithm-box warning mb-3">
 <div class="algorithm-title"> Mentale Checklist Training</div>
 <p class="text-muted" style="margin-top: 0.5rem;"> Sessies voltooid: <strong>${checklist.sessions || 0}</strong>
 ${checklist.activeSince ? `* Timer actief: <strong>${elapsed} min</strong>` : ''}
 </p>
 <div class="grid-2" style="margin-top: 0.75rem;">
 <label><input type="checkbox" class="sys-checklist-step"> Frequentie bepaald</label>
 <label><input type="checkbox" class="sys-checklist-step"> Ritme geclassificeerd</label>
 <label><input type="checkbox" class="sys-checklist-step"> Geleiding (PR/QRS) beoordeeld</label>
 <label><input type="checkbox" class="sys-checklist-step"> ST-T/QTc beoordeeld</label>
 </div>
 <div class="btn-group mt-2">
 <button class="btn btn-outline btn-sm" onclick="ECGApp.startChecklistTraining()"> Start Timer</button>
 <button class="btn btn-primary btn-sm" onclick="ECGApp.completeChecklistTraining()">Sessie afronden</button>
 </div>
 </div>

 <div class="algorithm-box info mb-3">
 <div class="algorithm-title"> Mini-drills per stap</div>
 <p class="text-muted" style="margin-top:0.5rem;">Korte 30-60 sec checks om het 10-stappenmodel te automatiseren.</p>
 <div class="btn-group mt-2" style="flex-wrap: wrap;">
 <button class="btn btn-sm btn-outline" onclick="ECGApp.openSystematicDrill('rate')">Frequentie drill</button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.openSystematicDrill('rhythm')">Ritme drill</button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.openSystematicDrill('conduction')">Geleiding drill</button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.openSystematicDrill('ischemia')">ST/T drill</button>
 </div>
 </div>

 <div class="algorithm-box info">
 <div class="algorithm-title"> 10-Stappen ECG Analyse</div>
 <div class="algorithm-steps">
 <div class="algorithm-step">
 <span class="algorithm-step-num">1</span>
 <div>
 <strong>Kalibratie & Kwaliteit</strong>
 <p class="text-muted" style="font-size: 0.85rem;">10mm/mV, 25mm/s, basislijn stabiel, artefacten?</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">2</span>
 <div>
 <strong>Hartfrequentie</strong>
 <p class="text-muted" style="font-size: 0.85rem;">300/grote hokjes of 6-sec methode. Normaal: 60-100 bpm</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">3</span>
 <div>
 <strong>Ritme</strong>
 <p class="text-muted" style="font-size: 0.85rem;">Regelmatig? Sinusritme? P-golf voor elk QRS?</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">4</span>
 <div>
 <strong>Hartas</strong>
 <p class="text-muted" style="font-size: 0.85rem;">Normaal -30° tot +90°. Check I en aVF</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">5</span>
 <div>
 <strong>P-golf</strong>
 <p class="text-muted" style="font-size: 0.85rem;">Aanwezig? Morfologie? Duur < 120ms, hoogte < 2.5mm</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">6</span>
 <div>
 <strong>PR-interval</strong>
 <p class="text-muted" style="font-size: 0.85rem;">120-200ms (3-5 kleine hokjes). Constant?</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">7</span>
 <div>
 <strong>QRS-complex</strong>
 <p class="text-muted" style="font-size: 0.85rem;">Duur < 120ms. Morfologie? Q-golven? R-progressie?</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">8</span>
 <div>
 <strong>ST-segment</strong>
 <p class="text-muted" style="font-size: 0.85rem;">Iso-elektrisch? Elevatie/depressie? > 1mm significant</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">9</span>
 <div>
 <strong>T-golf</strong>
 <p class="text-muted" style="font-size: 0.85rem;">Concordant met QRS? Inversie? Hyperacuut?</p>
 </div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">10</span>
 <div>
 <strong>QT-interval</strong>
 <p class="text-muted" style="font-size: 0.85rem;">QTc < 450 ms (mannen) / < 460 ms (vrouwen). Bazett: QTc = QT/√RR</p>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>

 <!-- Reference Values -->
 <div class="grid-2">
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Normale Waarden</h3>
 </div>
 <div class="card-body">
 <table class="data-table">
 <thead>
 <tr>
 <th>Parameter</th>
 <th>Normaal</th>
 </tr>
 </thead>
 <tbody>
 <tr><td>Hartfrequentie</td><td>60-100 bpm</td></tr>
 <tr><td>PR-interval</td><td>120-200 ms</td></tr>
 <tr><td>QRS-duur</td><td>&lt; 120 ms</td></tr>
 <tr><td>QTc</td><td>&lt; 450 ms (mannen), &lt; 460 ms (vrouwen)</td></tr>
 <tr><td>P-golf duur</td><td>&lt; 120 ms</td></tr>
 <tr><td>P-golf hoogte</td><td>&lt; 2.5 mm</td></tr>
 <tr><td>Hartas</td><td>-30° tot +90°</td></tr>
 </tbody>
 </table>
 </div>
 </div>

 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Hartfrequentie Berekening</h3>
 </div>
 <div class="card-body">
 <div class="algorithm-box success">
 <div class="algorithm-title">Regelmatig Ritme</div>
 <p style="margin-top: 0.5rem;">
 <strong>HR = 300 / aantal grote hokjes tussen R-toppen</strong>
 </p>
 <p class="text-muted" style="font-size: 0.85rem; margin-top: 0.5rem;"> Of memoriseer: 300-150-100-75-60-50
 </p>
 </div>
 
 <div class="algorithm-box warning mt-2">
 <div class="algorithm-title">Onregelmatig Ritme</div>
 <p style="margin-top: 0.5rem;">
 <strong>HR = aantal R-toppen in 6 sec × 10</strong>
 </p>
 <p class="text-muted" style="font-size: 0.85rem; margin-top: 0.5rem;">
 6 seconden = 30 grote hokjes
 </p>
 </div>
 </div>
 </div>
 </div>

 <!-- Axis Determination -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> As Bepaling (Snel)</h3>
 </div>
 <div class="card-body">
 <div class="grid-2">
 <div>
 <table class="data-table">
 <thead>
 <tr>
 <th>Lead I</th>
 <th>aVF</th>
 <th>As</th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td class="text-success">+ (positief)</td>
 <td class="text-success">+ (positief)</td>
 <td><strong>Normaal</strong> (0° tot +90°)</td>
 </tr>
 <tr>
 <td class="text-success">+ (positief)</td>
 <td class="text-danger">- (negatief)</td>
 <td><strong>Linker as</strong> (-30° tot -90°)</td>
 </tr>
 <tr>
 <td class="text-danger">- (negatief)</td>
 <td class="text-success">+ (positief)</td>
 <td><strong>Rechter as</strong> (+90° tot +180°)</td>
 </tr>
 <tr>
 <td class="text-danger">- (negatief)</td>
 <td class="text-danger">- (negatief)</td>
 <td><strong>Extreme as</strong> ("no man's land")</td>
 </tr>
 </tbody>
 </table>
 </div>
 <div>
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Ezelsbruggetje</h4>
 <p><strong>"Duim omhoog"</strong> - Als Lead I positief is, wijst de as naar links (normaal of LAD)</p>
 </div>
 </div>
 <div class="info-box info mt-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Oorzaken Asdeviatie</h4>
 <p><strong>LAD:</strong> LAFB, LVH, inferior MI</p>
 <p><strong>RAD:</strong> LPFB, RVH, lateraal MI, PE</p>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 `;
 },

 // ========== QUIZ MODE ==========
 renderQuiz(container) {
 if (AppState.quiz.active) {
 Sections.renderActiveQuiz(container);
 } else {
 Sections.renderQuizSetup(container);
 }
 },

 renderQuizSetup(container) {
 const recoveryAvailable = LearningCoachEngine.buildRecoveryQueue(1).length > 0;
 const recoveryAction = recoveryAvailable
 ? "ECGApp.startCoachSession('recovery')"
 : "ECGApp.showPrerequisiteHelp('recovery')";
 container.innerHTML = `
 ${ECGApp.getContextHelpHTML('quiz')}
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Quiz Configuratie</h3>
 </div>
 <div class="card-body">
 <div class="grid-2">
 <!-- Quiz Mode Selection -->
 <div>
 <h4 style="margin-bottom: 1rem;">Kies Quiz Modus</h4>
 <div class="quick-actions" style="grid-template-columns: 1fr;">
 <div class="quick-action" onclick="ECGApp.startQuiz('standard')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Standaard Quiz</div>
 <div class="quick-action-desc">10 vragen, geen tijdslimiet</div>
 </div>
 <div class="quick-action" onclick="ECGApp.startQuiz('timed')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Tijdsdruk</div>
 <div class="quick-action-desc">30 seconden per vraag</div>
 </div>
 <div class="quick-action" onclick="ECGApp.startQuiz('survival')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Survivalmodus</div>
 <div class="quick-action-desc">Ga door tot je een fout maakt</div>
 </div>
 <div class="quick-action" onclick="ECGApp.startQuiz('clinical')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Klinische Scenario's</div>
 <div class="quick-action-desc">ECG + patiënt context</div>
 </div>
 <div class="quick-action" onclick="ECGApp.startCriticalQuiz()">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Kritieke Ritmes</div>
 <div class="quick-action-desc">Alleen high/critical ritmes</div>
 </div>
 <div class="quick-action ${recoveryAvailable ? '' : 'locked'}" onclick="${recoveryAction}">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Herstelronde</div>
 <div class="quick-action-desc">Fout beantwoorde ritmes (laatste 7 dagen)</div>
 ${!recoveryAvailable ? '<div class="quick-action-help">Eerst fouten opbouwen via een quiz.</div>' : ''}
 </div>
 <div class="quick-action" onclick="ECGApp.startQuiz('exam')">
 <div class="quick-action-icon">*</div>
 <div class="quick-action-title">Examenmodus</div>
 <div class="quick-action-desc">20 vragen, zonder hints, domeinrapport</div>
 </div>
 </div>
 </div>

 <!-- Difficulty & Category -->
 <div>
 <h4 style="margin-bottom: 1rem;">Instellingen</h4>
 
 <div style="margin-bottom: 1.5rem;">
 <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Moeilijkheid</label>
 <select id="quizDifficulty" style="width: 100%; padding: 0.75rem; background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary);">
 <option value="all">Alle niveaus</option>
 <option value="easy">Makkelijk</option>
 <option value="medium">Gemiddeld</option>
 <option value="hard">Moeilijk</option>
 </select>
 </div>

 <div style="margin-bottom: 1.5rem;">
 <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Categorie</label>
 <select id="quizCategory" style="width: 100%; padding: 0.75rem; background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary);">
 <option value="all">Alle categorieën</option>
 ${Object.entries(ECGDatabase.categories).map(([id, cat]) => `
 <option value="${id}">${cat.icon} ${cat.name}</option>
 `).join('')}
 </select>
 </div>

 <div style="margin-bottom: 1.5rem;">
 <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Aantal vragen</label>
 <select id="quizCount" style="width: 100%; padding: 0.75rem; background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary);">
 <option value="5" ${AppState.settings?.defaultQuizCount === 5 ? 'selected' : ''}>5 vragen</option>
 <option value="10" ${AppState.settings?.defaultQuizCount === 10 || !AppState.settings?.defaultQuizCount ? 'selected' : ''}>10 vragen</option>
 <option value="20" ${AppState.settings?.defaultQuizCount === 20 ? 'selected' : ''}>20 vragen</option>
 <option value="50" ${AppState.settings?.defaultQuizCount === 50 ? 'selected' : ''}>50 vragen</option>
 </select>
 </div>

 <button class="btn btn-primary btn-lg" style="width: 100%;" onclick="ECGApp.startQuiz('standard')"> Start Quiz
 </button>
 </div>
 </div>
 </div>
 </div>

 <!-- Recent Results -->
 ${AppState.user.quizHistory.length > 0 ? `
 <div class="card mt-2">
 <div class="card-header">
 <h3 class="card-title"> Recente Resultaten</h3>
 </div>
 <div class="card-body">
 <table class="data-table">
 <thead>
 <tr>
 <th>Datum</th>
 <th>Modus</th>
 <th>Score</th>
 <th>Nauwkeurigheid</th>
 </tr>
 </thead>
 <tbody>
 ${AppState.user.quizHistory.slice(-5).reverse().map(result => `
 <tr>
 <td>${Utils.formatDate(result.date)}</td>
 <td>${result.mode}</td>
 <td>${result.correct}/${result.total}</td>
 <td class="${result.accuracy >= 80 ? 'text-success' : result.accuracy >= 60 ? 'text-warning' : 'text-danger'}">
 ${result.accuracy}%
 </td>
 </tr>
 `).join('')}
 </tbody>
 </table>
 </div>
 </div>
 ` : ''}
 `;
 },

 renderActiveQuiz(container) {
 const quiz = AppState.quiz;
 const rhythm = quiz.currentRhythm;
 const progress = ((quiz.currentQuestion) / quiz.totalQuestions) * 100;
 const adaptive = quiz.currentAdaptiveProfile || QuizEngine.getAdaptiveProfile(quiz);
 const visualProfile = adaptive?.visual || {};
 const allowHints = quiz.mode !== 'exam' && (AppState.settings?.showHints !== false || !!adaptive?.forceHints);

 if (!rhythm) {
 container.innerHTML = '<p>Laden...</p>';
 return;
 }

 const buildMorphologyGuide = () => {
 const rhythmText = rhythm.characteristics?.rhythm || 'onbekend';
 const pText = rhythm.characteristics?.pWave || 'beoordeel P-golven';
 const qrsRaw = rhythm.characteristics?.qrsComplex;
 const qrsText = typeof qrsRaw === 'object'
 ? `${qrsRaw.min || '?'}-${qrsRaw.max || '?'} ${qrsRaw.unit || 'ms'}`
 : (qrsRaw || 'beoordeel QRS-breedte');
 return `
 <div class="info-box info mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Leerhulp (module basis)</h4>
 <ul class="styled-list">
 <li><strong>Ritme:</strong> ${rhythmText}</li>
 <li><strong>P-golf:</strong> ${pText}</li>
 <li><strong>QRS:</strong> ${qrsText}</li>
 </ul>
 </div>
 </div>
 `;
 };

const payload = quiz.currentQuestionPayload || QuizEngine.buildQuestionPayload(quiz, rhythm);
const questionType = payload?.type || quiz.questionType || 'recognition';
const options = Array.isArray(payload?.options) ? payload.options : [];
const questionPrompt = payload?.prompt || 'Welk ritme zie je?';
const visualContext = payload?.visualContext || {};
const allLeads = ECGRenderer.LEAD_ORDER || ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
const displayLeads = ECGApp.getTwelveLeadDisplayOrder().filter(lead => allLeads.includes(lead));
const currentFocusLead = allLeads.includes(AppState.quizView?.focusLead)
? AppState.quizView.focusLead
: (visualContext.defaultFocusLead || 'II');
 AppState.quizView.focusLead = currentFocusLead;
 const keyLeadSet = new Set((visualContext.keyLeads || []).filter(lead => allLeads.includes(lead)));
 const speedMm = visualProfile.speed || 25;
 const gainX = visualProfile.amplitude || 1;
 const smallBoxSeconds = (1 / speedMm).toFixed(2);
 const largeBoxSeconds = (5 / speedMm).toFixed(2);
 const smallBoxMV = (0.1 / gainX).toFixed(2);
 const largeBoxMV = (0.5 / gainX).toFixed(2);
 const compactMeta = AppState.quizView?.compactMeta !== false;
 const showDetailedCalibration = AppState.quizView?.showDetailedCalibration === true;
 const leadHintText = visualContext.showLeadHint && keyLeadSet.size
 ? `Focus-leads: ${Array.from(keyLeadSet).join(', ')}`
 : 'Klik op een mini-lead voor vergroting.';
const buildLeadCard = (lead, roleLabel) => {
const isActive = lead === currentFocusLead;
const isKeyLead = !!visualContext.showLeadHint && keyLeadSet.has(lead);
const roleText = isKeyLead ? 'key lead' : (roleLabel || '');
const cardClasses = ['quiz-lead-card', isActive ? 'active' : '', isKeyLead ? 'key-lead' : '']
.filter(Boolean)
.join(' ');
return `
<div class="${cardClasses}" data-lead="${lead}" onclick="ECGApp.setQuizFocusLead('${lead}')">
<canvas id="${ECGApp.getQuizLeadCanvasId(lead)}" class="quiz-lead-canvas" data-lead="${lead}"></canvas>
<div class="quiz-lead-caption">
<span class="quiz-lead-name">${lead}</span>
${roleText ? `<span class="quiz-lead-role">${roleText}</span>` : ''}
</div>
</div>
`;
};
 quiz.currentOptionIds = options.map(o => o.id);

 container.innerHTML = `
 <!-- Progress Bar -->
 <div class="card mb-2">
 <div class="card-body" style="padding: 1rem;">
 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
 <span>Vraag ${quiz.currentQuestion + 1} van ${quiz.totalQuestions}</span>
 <div style="display: flex; gap: 1rem; align-items: center;">
 ${quiz.mode === 'exam' ? '<span class="badge badge-hard">Examenmodus</span>' : ''}
 ${quiz.mode === 'critical' ? '<span class="badge badge-critical">Kritieke ritmes</span>' : ''}
 ${quiz.mode === 'recovery' ? '<span class="badge badge-medium">Herstelronde</span>' : ''}
 ${quiz.mode === 'coach' ? '<span class="badge badge-info">Leercoach</span>' : ''}
 ${quiz.mode === 'sprint' ? '<span class="badge badge-info">Sprint 5m</span>' : ''}
 ${quiz.questionType === 'differential' ? '<span class="badge badge-info">Differentiaal</span>' : ''}
 ${quiz.questionType === 'first_action' ? '<span class="badge badge-warning">Eerste stap</span>' : ''}
 ${adaptive?.levelLabel ? `<span class="badge badge-info">${adaptive.levelLabel}</span>` : ''}
<span class="text-success">Score ${quiz.score}</span>
 ${quiz.mode === 'timed' ? `
 <span class="text-warning" id="quizTimer"> ${quiz.timeRemaining}s</span>
 ` : ''}
 </div>
 </div>
 <div class="progress-bar">
 <div class="progress-fill" style="width: ${progress}%"></div>
 </div>
 </div>
 </div>

 <!-- ECG Display -->
 <div class="ecg-monitor mb-2">
 <div class="ecg-monitor-header">
 <div class="ecg-monitor-title">
 <span></span>
 ${questionPrompt}
 </div>
 <div class="ecg-monitor-vitals">
 <div class="vital-display">
 <div class="vital-label">HR</div>
 <div class="vital-value green">${rhythm.characteristics?.rate?.typical || '--'}</div>
 </div>
 </div>
 </div>
 <div class="ecg-canvas-wrapper">
 <div class="quiz-hybrid-layout">
 <div class="quiz-ecg-toolbar">
 <div class="quiz-ecg-meta-compact">
 ${AppState.quizView?.showCalibrationBar !== false ? `
 <span class="quiz-calibration-chip">Kalibratie ${speedMm} mm/s | 10 mm/mV</span>
 ${(!compactMeta || showDetailedCalibration) ? `
 <span class="quiz-calibration-chip">Gain ${gainX}x (10 mm/mV basis)</span>
 <span class="quiz-calibration-chip">Tijd/hokje klein ${smallBoxSeconds}s | groot ${largeBoxSeconds}s</span>
 <span class="quiz-calibration-chip">mV/hokje klein ${smallBoxMV} | groot ${largeBoxMV}</span>
 ` : ''}
 ` : ''}
 <button class="btn btn-sm btn-outline" onclick="ECGApp.toggleQuizCalibrationDetails()">
 ${showDetailedCalibration ? 'Details verbergen' : 'Details tonen'}
 </button>
 </div>
 <div class="quiz-lead-hint">${leadHintText}</div>
 </div>

<div class="monitor-paper-wrapper">
<div class="monitor-paper-grid quiz-lead-grid">
${displayLeads.map(lead => buildLeadCard(lead, keyLeadSet.has(lead) ? 'key lead' : '')).join('')}
</div>
<div class="monitor-rhythm-strip">
<div class="monitor-rhythm-strip-header">
<span class="monitor-rhythm-strip-title" id="quizFocusLeadTitle">Ritmestrook (focus): Lead ${currentFocusLead}</span>
<span class="monitor-paper-note">HR ${rhythm.characteristics?.rate?.typical || '--'} bpm</span>
</div>
<div class="monitor-paper-lead active" style="cursor: default;">
<canvas id="quizECGFocus" class="monitor-rhythm-canvas"></canvas>
${AppState.quizView?.showLeadLabels !== false ? `<div class="monitor-paper-lead-label" id="quizFocusLeadChip">Lead ${currentFocusLead}</div>` : ''}
</div>
</div>
<div class="monitor-paper-footer">
<span>Snelheid: ${speedMm} mm/s</span>
<span>Limb: 10 mm/mV | Chest: 10 mm/mV</span>
<span>${leadHintText}</span>
</div>
</div>
</div>
</div>
</div>
 </div>

 ${adaptive?.showMorphologyGuide ? buildMorphologyGuide() : ''}

 <!-- Answer Options -->
 <div class="card">
 <div class="card-body">
 <div class="quiz-options" id="quizOptions">
 ${options.map((opt, index) => `
 <div class="quiz-option" data-answer="${opt.id}" onclick="ECGApp.selectAnswer('${opt.id}')">
 <span class="quiz-option-key">${String.fromCharCode(65 + index)}</span>
 <div class="quiz-option-content">
 <div class="quiz-option-title">${questionType === 'first_action' ? opt.label : opt.name}</div>
 <div class="quiz-option-desc">
 ${questionType === 'first_action'
 ? (opt.description || 'Kies de eerste veilige stap.')
 : `${opt.shortName} - ${(opt.description || '').substring(0, 60)}...`}
 </div>
 </div>
 </div>
 `).join('')}
 </div>

 <!-- Feedback Panel -->
 <div class="feedback-panel" id="feedbackPanel"></div>

 <!-- Action Buttons -->
 <div class="btn-group mt-3" style="justify-content: space-between;">
 ${allowHints ? `
 <button class="btn btn-outline" onclick="ECGApp.showHint()"> Hint
 </button>
 ` : '<span class="text-muted" style="font-size:0.85rem;">Hints staan uit</span>'}
 <button class="btn btn-primary hidden" id="nextBtn" onclick="ECGApp.nextQuestion()"> Volgende
 </button>
 </div>
 </div>
 </div>
 `;

 ECGApp.updateBreadcrumb(`Quiz > Vraag ${quiz.currentQuestion + 1}/${quiz.totalQuestions}`);

 // Draw ECG
 setTimeout(() => {
 const rate = rhythm.characteristics?.rate?.typical || 72;
const commonOptions = {
heartRate: rate,
speed: visualProfile.speed || 25,
amplitude: visualProfile.amplitude || 1,
signalNoise: visualProfile.signalNoise || 0,
baselineWander: visualProfile.baselineWander || 0,
theme: ECGApp.getPaperTheme()
};
ECGRenderer.drawLeadStrip('quizECGFocus', rhythm.id, {
...commonOptions,
lead: AppState.quizView.focusLead || currentFocusLead,
verticalScale: (visualProfile.verticalScale || 1) * (AppState.quizView?.zoom || 1),
lineWidth: Math.max(2.1, visualProfile.lineWidth || 2),
shadowBlur: Math.max(2.2, visualProfile.shadowBlur || 3),
showCalibrationPulse: false
});

ECGRenderer.drawTwelveLeadGrid('quizLead', rhythm.id, {
...commonOptions,
verticalScale: Math.max(0.75, (visualProfile.verticalScale || 1) * 0.82),
lineWidth: Math.max(1.35, (visualProfile.lineWidth || 2) - 0.65),
shadowBlur: Math.max(1.5, (visualProfile.shadowBlur || 3) - 1.2),
leads: displayLeads,
showCalibrationPulse: false,
canvasIdBuilder: (lead) => ECGApp.getQuizLeadCanvasId(lead)
});
 ECGApp.updateQuizLeadSelectionStyles();
 }, 100);

 // Start timer if timed mode
 if (quiz.mode === 'timed') {
 ECGApp.startQuizTimer();
 }
 },

 // ========== CLINICAL CASES ==========
 renderCases(container) {
 container.innerHTML = `
 ${ECGApp.getContextHelpHTML('cases')}
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Klinische Cases</h3>
 </div>
 <div class="card-body">
 <p class="text-muted mb-3">Oefen met ${ClinicalCases.getAllCases().length} realistische IC/SEH scenario's waar je ECG-interpretatie combineert met klinische context.</p>

 <div class="grid-2">
 ${ClinicalCases.getAllCases().map(caseData => `
 <div class="card" style="cursor: pointer;" onclick="ECGApp.startCase('${caseData.id}')">
 <div class="card-body">
 <div class="case-header">
 <div class="case-avatar">${caseData.patientIcon}</div>
 <div class="case-info">
 <h3>${caseData.title}</h3>
 <p>${caseData.patientInfo}</p>
 </div>
 </div>
 <p class="text-muted" style="font-size: 0.9rem;">${caseData.presentation}</p>
 ${caseData.moduleId ? `<p class="text-muted" style="font-size:0.8rem;">Leerpad: ${LearningPathEngine.getModuleById(caseData.moduleId)?.title || caseData.moduleId}</p>` : ''}
 <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem;">
 <span class="badge ${Utils.getDifficultyBadge(caseData.difficulty)}">${caseData.difficulty}</span>
 <span class="text-muted" style="font-size: 0.8rem;">${caseData.duration} min</span>
 </div>
 </div>
 </div>
 `).join('')}
 </div>
 </div>
 </div>
 `;
 },

 // ========== ACLS ALGORITHMS ==========
 renderACLS(container) {
 container.innerHTML = `
 <div class="emergency-banner">
 <span class="pulse">*</span>
 <span>ACLS Protocollen - Spoedsituaties</span>
 </div>
 <div class="info-box info mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Primaire bron</h4>
 <p>
 <a href="${MedicalSourceRegistry.erc_als_2025.url}" target="_blank" rel="noopener noreferrer">${MedicalSourceRegistry.erc_als_2025.title}</a>
 </p>
 <p class="text-muted" style="margin-top: 0.35rem;">ERC/ESC default; volg lokaal protocol.</p>
 </div>
 </div>

 <!-- Cardiac Arrest Algorithm -->
 <div class="card mb-2">
 <div class="card-header">
 <h3 class="card-title"> Hartstilstand Algoritme</h3>
 </div>
 <div class="card-body">
 <div class="tabs">
 <div class="tab active" onclick="ECGApp.switchACLSTab('shockable')">Schokbaar (VF/pVT)</div>
 <div class="tab" onclick="ECGApp.switchACLSTab('nonshockable')">Niet-schokbaar (Asystolie/PEA)</div>
 </div>

 <div class="tab-content active" id="tab-shockable">
 <div class="algorithm-box critical">
<div class="algorithm-title">VF / Polsloze VT</div>
 <div class="algorithm-steps">
 <div class="algorithm-step critical">
 <span class="algorithm-step-num">1</span>
 <div><strong>DEFIBRILLATIE</strong> - gebruik fabrikantadviesenergie; bij onbekende instelling kies de hoogste aanbevolen energie en escaleer indien nodig</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">2</span>
 <div><strong>CPR</strong> - 2 minuten, minimaliseer onderbrekingen (volg lokaal ALS-protocol)</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">3</span>
 <div><strong>Ritmecheck</strong> - Nog VF/pVT?</div>
 </div>
 <div class="algorithm-step critical">
 <span class="algorithm-step-num">4</span>
 <div><strong>DEFIBRILLATIE</strong> - ga direct door met CPR; geef <strong>Adrenaline 1mg IV</strong> na de 3e schok, daarna elke 3-5 min</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">5</span>
 <div><strong>CPR</strong> - 2 minuten</div>
 </div>
 <div class="algorithm-step critical">
 <span class="algorithm-step-num">6</span>
 <div><strong>Na 3e schok:</strong> <strong>Amiodaron 300mg IV</strong> (overweeg 150mg na 5e schok)</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">7</span>
 <div>Herhaal cyclus. Overweeg <strong>Amiodaron 150mg</strong> bij 5e schok</div>
 </div>
 </div>
 </div>
 </div>

 <div class="tab-content" id="tab-nonshockable">
 <div class="algorithm-box warning">
 <div class="algorithm-title"> Asystolie / PEA</div>
 <div class="algorithm-steps">
 <div class="algorithm-step">
 <span class="algorithm-step-num">1</span>
 <div><strong>CPR</strong> starten - Goede kwaliteit!</div>
 </div>
 <div class="algorithm-step critical">
 <span class="algorithm-step-num">2</span>
 <div><strong>Adrenaline 1mg IV</strong> - Zo snel mogelijk</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">3</span>
 <div><strong>CPR</strong> - 2 minuten</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">4</span>
 <div><strong>Ritmecheck</strong> - Schokbaar geworden?</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">5</span>
 <div><strong>Adrenaline 1mg IV</strong> elke 3-5 minuten</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">6</span>
 <div><strong>Behandel reversibele oorzaken (4H/4T)</strong></div>
 </div>
 </div>
 </div>

 <div class="grid-2 mt-3">
 <div class="algorithm-box info">
 <div class="algorithm-title">4 H's</div>
 <ul class="styled-list">
 <li><strong>H</strong>ypoxie</li>
 <li><strong>H</strong>ypovolemie</li>
 <li><strong>H</strong>ypo/hyperkaliëmie</li>
 <li><strong>H</strong>ypothermie</li>
 </ul>
 </div>
 <div class="algorithm-box info">
 <div class="algorithm-title">4 T's</div>
 <ul class="styled-list">
 <li><strong>T</strong>ensie pneumothorax</li>
 <li><strong>T</strong>amponade (harttamponade)</li>
 <li><strong>T</strong>oxines</li>
 <li><strong>T</strong>rombose (coronair/pulmonaal)</li>
 </ul>
 </div>
 </div>
 </div>
 </div>
 </div>

 <!-- Tachycardia Algorithm -->
 <div class="card mb-2">
 <div class="card-header">
<h3 class="card-title">Tachycardie met Pols</h3>
 </div>
 <div class="card-body">
 <div class="algorithm-box">
 <div class="algorithm-title"> Eerste Beoordeling</div>
 <p style="margin: 0.5rem 0;">Is de patiënt <strong>hemodynamisch instabiel</strong>?</p>
 <ul class="styled-list">
 <li>Hypotensie (SBP < 90)</li>
 <li>Bewustzijnsdaling</li>
 <li>Pijn op de borst</li>
 <li>Acuut hartfalen</li>
 </ul>
 </div>

 <div class="grid-2 mt-2">
 <div class="algorithm-box critical">
<div class="algorithm-title">INSTABIEL</div>
 <p style="margin: 0.5rem 0;"><strong>Gesynchroniseerde cardioversie!</strong></p>
 <ul class="styled-list">
 <li>Gebruik fabrikantadviesenergie als startpunt</li>
 <li>Escaleer energie bij persisterende tachycardie</li>
 <li>Sedatie indien tijd</li>
 </ul>
 </div>
 <div class="algorithm-box success">
<div class="algorithm-title">STABIEL</div>
 <p style="margin: 0.5rem 0;">Beoordeel QRS breedte:</p>
 <ul class="styled-list">
<li><strong>Smal (< 120ms):</strong> vagale manoeuvres -> adenosine</li>
<li><strong>Breed (= 120ms):</strong> beoordeel regelmaat; monomorf regelmatig -> anti-aritmicum mogelijk, onregelmatig/instabiel -> (gesynchroniseerde) cardioversie en specialistische beoordeling</li>
 </ul>
 </div>
 </div>

 <div class="info-box warning mt-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Adenosine Dosering</h4>
 <p><strong>Primair (ERC/ESC):</strong> 6mg snelle IV push, daarna 12mg en 18mg (RCUK/ERC-profiel), met flush via grote perifere lijn.<br><strong>AHA-alternatief:</strong> 6mg gevolgd door 12mg; verdere herhaling volgens lokaal AHA-gebaseerd protocol.<br><strong>Volg lokaal protocol.</strong> Alleen gebruiken bij regelmatige ritmes, bij brede complexen uitsluitend in regelmatige monomorfe context.</p>
 </div>
 </div>
 </div>
 </div>

 <!-- Bradycardia Algorithm -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Bradycardie</h3>
 </div>
 <div class="card-body">
 <div class="algorithm-box">
 <div class="algorithm-title"> Beoordeling</div>
 <p style="margin: 0.5rem 0;">HF &lt; 60 en symptomen of hemodynamische instabiliteit?</p>
 </div>

 <div class="algorithm-box warning mt-2">
 <div class="algorithm-title"> Behandeling Symptomatische Bradycardie</div>
 <div class="algorithm-steps">
 <div class="algorithm-step">
 <span class="algorithm-step-num">1</span>
 <div><strong>Atropine 0,5mg (500 µg) IV</strong> - Herhaal elke 3-5 min (max 3mg)</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">2</span>
 <div><strong>Transcutane pacing</strong> - Bij onvoldoende respons</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">3</span>
 <div><strong>Adrenaline infusie</strong> 2-10 µg/min of <strong>Dopamine</strong> 5-20 µg/kg/min</div>
 </div>
 <div class="algorithm-step">
 <span class="algorithm-step-num">4</span>
 <div><strong>Transveneuze pacing</strong> - Definitief</div>
 </div>
 </div>
 </div>

 <div class="info-box info mt-2">
 <div class="info-box-icon">i</div>
 <div class="info-box-content">
 <h4>Richtlijnverschil atropine (bradycardie)</h4>
 <p><strong>Primair (ERC/ESC):</strong> atropine 500 mcg IV elke 3-5 min (max 3 mg).<br><strong>AHA-alternatief:</strong> atropine 1 mg IV elke 3-5 min (max 3 mg).<br><strong>Volg lokaal protocol.</strong> Bij aanhoudende instabiliteit: vroegtijdig pacingpad.</p>
 </div>
 </div>
 <div class="info-box danger mt-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Atropine NIET effectief bij:</h4>
 <p>AV-blok type II (Mobitz II) en derdegraads AV-blok met breed QRS escape.<br> Start direct met pacing!</p>
 </div>
 </div>
 </div>
 </div>
 `;
 },

 // ========== MEDICATIONS ==========
 renderDrugs(container) {
 container.innerHTML = `
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Medicatie & ECG Effecten</h3>
 </div>
 <div class="card-body">
 <div class="info-box info mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Primaire bronnen</h4>
 <p><a href="${MedicalSourceRegistry.esc_svt_2019.url}" target="_blank" rel="noopener noreferrer">${MedicalSourceRegistry.esc_svt_2019.title}</a></p>
 <p><a href="${MedicalSourceRegistry.esc_af_2024.url}" target="_blank" rel="noopener noreferrer">${MedicalSourceRegistry.esc_af_2024.title}</a></p>
 </div>
 </div>
 <div class="tabs">
 <div class="tab active" onclick="ECGApp.switchDrugTab('antiarrhythmic')">Anti-aritmica</div>
 <div class="tab" onclick="ECGApp.switchDrugTab('emergency')">Spoed Medicatie</div>
 <div class="tab" onclick="ECGApp.switchDrugTab('qtprolonging')">QT-verlenging</div>
 </div>

 <div class="tab-content active" id="tab-antiarrhythmic">
 <div class="accordion">
 <!-- Amiodaron -->
 <div class="accordion-item open">
 <div class="accordion-header" onclick="this.parentElement.classList.toggle('open')">
 <h4> Amiodaron (Klasse III)</h4>
 <span class="accordion-icon">v</span>
 </div>
 <div class="accordion-body">
 <div class="accordion-content">
 <p><strong>Indicaties:</strong> VT, VF, AF rate/rhythm control, SVT</p>
 <p><strong>Dosering:</strong></p>
 <ul class="styled-list">
 <li>VF/pVT: 300mg IV bolus, dan 150mg</li>
 <li>Stabiele VT: 150mg IV over 10 min</li>
 <li>AF: 300mg IV over 1u, dan 900mg/24u</li>
 </ul>
 <p><strong>ECG effecten:</strong></p>
 <ul class="styled-list">
 <li>QT-verlenging</li>
 <li>Bradycardie</li>
 <li>PR-verlenging</li>
 </ul>
 <div class="info-box warning mt-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p><strong>Let op:</strong> Torsades de Pointes risico, hypotensie bij snelle infusie</p>
 </div>
 </div>
 </div>
 </div>
 </div>

 <!-- Adenosine -->
 <div class="accordion-item">
 <div class="accordion-header" onclick="this.parentElement.classList.toggle('open')">
 <h4> Adenosine</h4>
 <span class="accordion-icon">v</span>
 </div>
 <div class="accordion-body">
 <div class="accordion-content">
 <p><strong>Indicaties:</strong> Primair voor regelmatige smalcomplex SVT (diagnostisch en therapeutisch); alleen selectief bij regelmatige monomorfe breedcomplex tachycardie</p>
 <p><strong>Dosering:</strong> Primair (ERC/ESC): 6mg -> 12mg -> 18mg snelle IV push + flush. AHA-alternatief: 6mg -> 12mg met lokale herhaalstrategie. Volg lokaal protocol.</p>
 <p><strong>ECG effecten:</strong></p>
 <ul class="styled-list">
 <li>Transiënte asystolie (normaal!)</li>
 <li>Onthult onderliggend ritme (flutter, atriale tachycardie)</li>
 <li>Beëindigt AVNRT/AVRT</li>
 </ul>
 <div class="info-box danger mt-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p><strong>Vermijd/let op:</strong> bij pre-excitatie (WPW) + AF geen AV-knoopblokkers (incl. adenosine); ook vermijden bij 2e/3e graads AV-blok zonder pacemaker. Wees voorzichtig bij ernstige astma/COPD. Gebruik adenosine vooral bij regelmatige monomorfe ritmes.</p>
 </div>
 </div>
 </div>
 </div>
 </div>

 <!-- Bètablokkers -->
 <div class="accordion-item">
 <div class="accordion-header" onclick="this.parentElement.classList.toggle('open')">
 <h4> Bètablokkers (Klasse II)</h4>
 <span class="accordion-icon">v</span>
 </div>
 <div class="accordion-body">
 <div class="accordion-content">
 <p><strong>Voorbeelden:</strong> Metoprolol, Esmolol, Bisoprolol</p>
 <p><strong>Indicaties:</strong> Rate control AF/flutter, SVT, sinustachycardie, ACS</p>
 <p><strong>Dosering (Metoprolol):</strong> 2.5-5mg IV langzaam, herhaal elke 5 min (max 15mg)</p>
 <p><strong>ECG effecten:</strong></p>
 <ul class="styled-list">
 <li>Hartfrequentie verlaging</li>
 <li>PR-verlenging</li>
 <li>Geen significante QRS/QT verandering</li>
 </ul>
 </div>
 </div>
 </div>

 <!-- Digoxine -->
 <div class="accordion-item">
 <div class="accordion-header" onclick="this.parentElement.classList.toggle('open')">
 <h4> Digoxine</h4>
 <span class="accordion-icon">v</span>
 </div>
 <div class="accordion-body">
 <div class="accordion-content">
 <p><strong>Indicaties:</strong> AF rate control in geselecteerde context (met name bij hartfalen of wanneer andere rate-control middelen minder geschikt zijn)</p>
 <p><strong>Dosering:</strong> 0.5mg IV, dan 0.25mg elke 6u (max 1mg/24u)</p>
 <p><strong>ECG effect (therapeutisch):</strong></p>
 <ul class="styled-list">
 <li>ST "scooping" (Salvador Dalí snor)</li>
 <li>QT verkorting</li>
 <li>T afvlakking/inversie</li>
 </ul>
 <p><strong>ECG toxiciteit:</strong></p>
 <ul class="styled-list">
 <li>Elke aritmie mogelijk!</li>
 <li>Bidirectionele VT (pathognomonisch)</li>
 <li>Versneld junctioneel ritme</li>
 <li>AF met regelmatige ventrikelrespons</li>
 </ul>
 </div>
 </div>
 </div>
 </div>
 </div>

 <div class="tab-content" id="tab-emergency">
 <table class="data-table">
 <thead>
 <tr>
 <th>Medicatie</th>
 <th>Indicatie</th>
 <th>Dosering</th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td><strong>Adrenaline</strong></td>
 <td>Hartstilstand, anafylaxie, ernstige bradycardie</td>
 <td>1mg IV elke 3-5 min (hartstilstand)<br>2-10 µg/min infusie (bradycardie)</td>
 </tr>
 <tr>
 <td><strong>Atropine</strong></td>
 <td>Symptomatische bradycardie</td>
 <td>0,5mg (500 µg) IV elke 3-5 min (max 3mg)</td>
 </tr>
 <tr>
 <td><strong>Magnesium</strong></td>
 <td>Torsades de Pointes, hypomagnesiëmie</td>
 <td>2g IV over 10-15 min (TdP: bolus)</td>
 </tr>
 <tr>
 <td><strong>Calcium</strong></td>
 <td>Hyperkaliëmie, hypocalciëmie, Ca-blokker overdosis</td>
 <td>10ml CaCl 10% of 30ml Ca-gluconaat 10%</td>
 </tr>
 <tr>
 <td><strong>NaHCO3</strong></td>
 <td>Hyperkaliëmie, TCA overdosis, ernstige acidose</td>
 <td>50-100 mEq IV</td>
 </tr>
 </tbody>
 </table>
 </div>

 <div class="tab-content" id="tab-qtprolonging">
 <div class="info-box danger mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Risico op Torsades de Pointes!</h4>
 <p>Combinaties van QT-verlengende medicatie vermijden. Monitor QTc.</p>
 </div>
 </div>

 <div class="grid-2">
 <div>
 <h4 style="margin-bottom: 0.75rem;">Anti-aritmica</h4>
 <ul class="styled-list">
 <li>Amiodaron</li>
 <li>Sotalol</li>
 <li>Flecaïnide</li>
 <li>Procaïnamide</li>
 </ul>
 </div>
 <div>
 <h4 style="margin-bottom: 0.75rem;">Antibiotica</h4>
 <ul class="styled-list">
 <li>Macroliden (azitromycine, erytromycine)</li>
 <li>Fluoroquinolonen (ciprofloxacine, moxifloxacine)</li>
 <li>Cotrimoxazol</li>
 </ul>
 </div>
 <div>
 <h4 style="margin-bottom: 0.75rem;">Psychiatrie</h4>
 <ul class="styled-list">
 <li>Haloperidol</li>
 <li>Antidepressiva (TCA's, SSRI's)</li>
 <li>Antipsychotica (quetiapine, risperidon)</li>
 </ul>
 </div>
 <div>
 <h4 style="margin-bottom: 0.75rem;">Overig</h4>
 <ul class="styled-list">
 <li>Methadon</li>
 <li>Ondansetron</li>
 <li>Domperidon</li>
 <li>Antihistaminica</li>
 </ul>
 </div>
 </div>
 </div>
 </div>
 </div>
 `;
 },

 // ========== CRITERIA & REFERENCE ==========
 renderCriteria(container) {
 container.innerHTML = `
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> ECG Criteria & Referentiewaarden</h3>
 </div>
 <div class="card-body">
 <div class="info-box info mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Primaire bron</h4>
 <p><a href="${MedicalSourceRegistry.esc_acs_2023.url}" target="_blank" rel="noopener noreferrer">${MedicalSourceRegistry.esc_acs_2023.title}</a></p>
 </div>
 </div>
 <div class="tabs">
 <div class="tab active" onclick="ECGApp.switchCriteriaTab('intervals')">Intervallen</div>
 <div class="tab" onclick="ECGApp.switchCriteriaTab('hypertrophy')">Hypertrofie</div>
 <div class="tab" onclick="ECGApp.switchCriteriaTab('ischemia')">Ischemie</div>
 <div class="tab" onclick="ECGApp.switchCriteriaTab('blocks')">Blokken</div>
 </div>

 <div class="tab-content active" id="tab-intervals">
 <table class="data-table">
 <thead>
 <tr>
 <th>Parameter</th>
 <th>Normaal</th>
 <th>Afwijkend</th>
 <th>Klinische betekenis</th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td><strong>Hartfrequentie</strong></td>
 <td>60-100 bpm</td>
 <td>< 60: bradycardie<br>> 100: tachycardie</td>
 <td>Beoordeel in klinische context</td>
 </tr>
 <tr>
 <td><strong>PR-interval</strong></td>
 <td>120-200 ms<br>(3-5 kleine hokjes)</td>
 <td>< 120: pre-excitatie (WPW)<br>> 200: 1e graads AV-blok</td>
 <td>Geleidingstijd atrium -> ventrikel</td>
 </tr>
 <tr>
 <td><strong>QRS-duur</strong></td>
 <td>< 120 ms<br>(< 3 kleine hokjes)</td>
 <td>110-119: mogelijk incompleet BBB/IVCD<br>= 120: compleet BBB of andere intraventriculaire geleidingsstoornis</td>
 <td>Intraventriculaire geleiding</td>
 </tr>
 <tr>
 <td><strong>QTc-interval</strong></td>
<td>M: < 440 ms<br>V: < 460 ms</td>
 <td>> 500 ms: hoog TdP risico<br>< 340 ms: kort QT syndroom</td>
 <td>QTc = QT / vRR (Bazett)</td>
 </tr>
 <tr>
 <td><strong>P-golf duur</strong></td>
 <td>< 120 ms</td>
 <td>> 120 ms: P-mitrale (LAE)</td>
 <td>Atriale depolarisatietijd</td>
 </tr>
 <tr>
 <td><strong>P-golf hoogte</strong></td>
 <td>< 2.5 mm</td>
 <td>> 2.5 mm: P-pulmonale (RAE)</td>
 <td>Atriale amplitude in II</td>
 </tr>
 </tbody>
 </table>
 </div>

 <div class="tab-content" id="tab-hypertrophy">
 <h4 style="margin-bottom: 1rem;">Linkerventrikel Hypertrofie (LVH)</h4>
 <div class="algorithm-box info">
 <div class="algorithm-title">Sokolow-Lyon Criteria</div>
 <p style="margin: 0.5rem 0;"><strong>S V1 + R V5/V6 = 35 mm</strong></p>
 <p class="text-muted">Specificiteit ~95%, sensitiviteit ~20%</p>
 </div>
 <div class="algorithm-box info mt-2">
 <div class="algorithm-title">Cornell Criteria</div>
 <p style="margin: 0.5rem 0;">
<strong>M: R aVL + S V3 > 28 mm</strong><br>
<strong>V: R aVL + S V3 > 20 mm</strong>
 </p>
 </div>

 <h4 style="margin: 1.5rem 0 1rem;">Rechterventrikel Hypertrofie (RVH)</h4>
 <div class="algorithm-box warning">
 <div class="algorithm-title">RVH Criteria</div>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 <li>R V1 > 7 mm</li>
 <li>R/S ratio V1 > 1</li>
 <li>Rechter asdeviatie (> 90°)</li>
 <li>S V5/V6 > 7 mm</li>
 <li>qR patroon V1</li>
 </ul>
 </div>
 </div>

 <div class="tab-content" id="tab-ischemia">
 <h4 style="margin-bottom: 1rem;">STEMI Criteria</h4>
 <div class="algorithm-box critical">
 <div class="algorithm-title">ST-elevatie Significantie</div>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 <li><strong>V2-V3:</strong> ≥ 2.0 mm (mannen > 40j), ≥ 2.5 mm (mannen < 40j), ≥ 1.5 mm (vrouwen)</li>
 <li><strong>Overige afleidingen:</strong> ≥ 1 mm in 2 aangrenzende afleidingen</li>
 <li><strong>Posterior:</strong> ST-depressie V1-V3 + hoge R</li>
 </ul>
 </div>

 <div class="info-box warning mt-2">
 <div class="info-box-icon">!</div>
 <div class="info-box-content">
 <h4>STEMI-equivalenten</h4>
 <p><strong>Primair (ERC/ESC):</strong> de Winter en posterior ischemie kunnen acute coronairocclusie representeren zonder klassieke ST-elevatie.<br><strong>AHA-alternatief:</strong> vergelijkbare hoog-risico interpretatie met urgente reperfusie-overweging.<br><strong>Volg lokaal protocol.</strong></p>
 </div>
 </div>

 <h4 style="margin: 1.5rem 0 1rem;">Coronaire Territoria</h4>
 <table class="data-table">
 <thead>
 <tr>
 <th>Locatie</th>
 <th>Afleidingen</th>
 <th>Arterie</th>
 </tr>
 </thead>
 <tbody>
 <tr><td>Septaal</td><td>V1-V2</td><td>LAD (septale tak)</td></tr>
 <tr><td>Anterior</td><td>V3-V4</td><td>LAD</td></tr>
 <tr><td>Lateraal</td><td>I, aVL, V5-V6</td><td>LCx of LAD</td></tr>
 <tr><td>Inferior</td><td>II, III, aVF</td><td>RCA (80%) of LCx</td></tr>
 <tr><td>Posterior</td><td>V7-V9 (of reciprook V1-V3)</td><td>RCA of LCx</td></tr>
 <tr><td>Rechter ventrikel</td><td>V4R</td><td>RCA (proximaal)</td></tr>
 </tbody>
 </table>
 </div>

 <div class="tab-content" id="tab-blocks">
 <h4 style="margin-bottom: 1rem;">Bundeltakblok Criteria</h4>
 <div class="grid-2">
 <div class="algorithm-box info">
 <div class="algorithm-title">RBBB</div>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 <li>QRS = 120 ms</li>
 <li>rSR' in V1-V2 (M-patroon)</li>
 <li>Brede S in I, V6</li>
 <li>Ezelsbruggetje: <strong>MaRRoW</strong></li>
 </ul>
 </div>
 <div class="algorithm-box warning">
 <div class="algorithm-title">LBBB</div>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 <li>QRS = 120 ms</li>
 <li>Brede R in I, aVL, V5-V6</li>
 <li>QS of rS in V1</li>
 <li>Afwezig septale q in I, V5-V6</li>
 <li>Ezelsbruggetje: <strong>WiLLiaM</strong></li>
 </ul>
 </div>
 </div>

 <div class="info-box info mt-2">
 <div class="info-box-icon">i</div>
 <div class="info-box-content">
 <h4>LBBB bij ACS (nuance)</h4>
 <p><strong>Primair (ERC/ESC):</strong> nieuw LBBB is niet op zichzelf diagnostisch voor STEMI; combineer met klachten, seriele ECG-veranderingen en aanvullende criteria.<br><strong>AHA/ACC-alternatief:</strong> vergelijkbare nuance met aanvullende ischemiecriteria (zoals Sgarbossa-context).<br><strong>Volg lokaal protocol.</strong></p>
 </div>
 </div>

 <h4 style="margin: 1.5rem 0 1rem;">AV-blok Classificatie</h4>
 <table class="data-table">
 <thead>
 <tr>
 <th>Type</th>
 <th>Kenmerken</th>
 <th>Urgentie</th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td>1e graads</td>
 <td>PR > 200ms, elke P geleidt</td>
 <td class="text-success">Laag</td>
 </tr>
 <tr>
 <td>2e graads type I<br>(Wenckebach)</td>
 <td>Progressieve PR-verlenging -> dropped beat</td>
 <td class="text-warning">Medium</td>
 </tr>
 <tr>
 <td>2e graads type II<br>(Mobitz II)</td>
 <td>Constante PR -> plotse dropped beat</td>
 <td class="text-danger">Hoog</td>
 </tr>
 <tr>
 <td>3e graads<br>(Compleet)</td>
 <td>Geen relatie P-QRS, escape ritme</td>
 <td class="text-danger">KRITIEK</td>
 </tr>
 </tbody>
 </table>
 </div>
 </div>
 </div>
 `;
 }
 };

 // ==================== CLINICAL CASES DATA ====================
 const ClinicalCases = {
 cases: [
 {
 id: 'case_chest_pain',
 title: 'Pijn op de borst op de SEH',
 patientIcon: '*',
 patientInfo: 'Man, 58 jaar',
 presentation: 'Plotselinge pijn op de borst sinds 2 uur, uitstralend naar linkerarm, misselijk.',
 vitals: { hr: 95, bp: '150/95', spo2: 96, rr: 20 },
 rhythm: 'stemi_anterior',
 difficulty: 'medium',
 duration: 10,
 questions: [
 {
 question: 'Wat is je eerste diagnose op basis van dit ECG?',
 options: ['Normaal sinusritme', 'Anterieur STEMI', 'NSTEMI', 'Pericarditis'],
 correct: 1,
 explanation: 'ST-elevatie in V1-V4 met reciproke depressie in II, III, aVF wijst op een anterieur STEMI door LAD occlusie.'
 },
 {
 question: 'Wat is de eerste actie?',
 options: ['Troponine afwachten', 'CT-thorax', 'Cath lab activeren', 'Stress ECG'],
 correct: 2,
 explanation: 'Bij STEMI geldt \"tijd = myocard\". Activeer direct het cathlab voor primaire PCI binnen regionale streeftijden; als tijdige PCI niet haalbaar is, volg lokaal fibrinolyseprotocol.'
 }
 ]
 },
 {
 id: 'case_syncope',
 title: 'Syncope bij oudere patiënt',
 patientIcon: '*',
 patientInfo: 'Man, 78 jaar',
 presentation: 'Collaps thuis, geen pijn, eerder ook "wegrakingen". Digoxine en metoprolol gebruik.',
 vitals: { hr: 35, bp: '90/60', spo2: 94, rr: 14 },
 rhythm: 'avblock_3rd',
 difficulty: 'hard',
 duration: 12,
 questions: [
 {
 question: 'Welk ritme zie je?',
 options: ['Sinusbradycardie', 'Tweedegraads AV-blok', 'Derdegraads AV-blok', 'Junctioneel ritme'],
 correct: 2,
 explanation: 'P-golven en QRS-complexen zijn volledig onafhankelijk van elkaar. Dit is compleet hartblok.'
 },
 {
 question: 'Welke behandeling is nodig?',
 options: ['Afwachten', 'Alleen atropine', 'Transcutane pacing', 'Adenosine'],
 correct: 2,
 explanation: 'Bij compleet hartblok met hemodynamische instabiliteit is transcutane pacing geïndiceerd als bridge naar transveneuze pacing/permanente pacemaker.'
 }
 ]
 },
 {
 id: 'case_palpitations',
 title: 'Hartkloppingen op de IC',
 patientIcon: '*',
 patientInfo: 'Vrouw, 34 jaar',
 presentation: 'Plotselinge hartkloppingen, licht duizelig, postoperatief dag 2 na appendectomie.',
 vitals: { hr: 185, bp: '105/70', spo2: 98, rr: 18 },
 rhythm: 'svt',
 difficulty: 'easy',
 duration: 8,
 questions: [
 {
 question: 'Wat is de meest waarschijnlijke diagnose?',
 options: ['Sinustachycardie', 'Atriumfibrilleren', 'SVT', 'Ventriculaire tachycardie'],
 correct: 2,
 explanation: 'Regelmatige smalle complex tachycardie met een frequentie van 185/min zonder duidelijke P-golven wijst op SVT.'
 },
 {
 question: 'Wat is de eerste behandelstap?',
 options: ['Cardioversie', 'Vagale manoeuvres', 'Amiodaron', 'Defibrillatie'],
 correct: 1,
 explanation: 'Bij stabiele SVT beginnen we met vagale manoeuvres (bij voorkeur gemodificeerde Valsalva). Als dit faalt, adenosine.'
 }
 ]
 },
 {
 id: 'case_resuscitation',
 title: 'Reanimatie op de IC',
 patientIcon: '*',
 patientInfo: 'Man, 65 jaar',
 presentation: 'Post-CABG dag 1, plotseling niet reagerend, geen pols voelbaar.',
 vitals: { hr: 0, bp: '-', spo2: '-', rr: 0 },
 rhythm: 'vfib',
 difficulty: 'medium',
 duration: 10,
 questions: [
 {
 question: 'Welk ritme zie je?',
 options: ['Asystolie', 'PEA', 'Ventrikelfibrilleren', 'Fijne VF'],
 correct: 2,
 explanation: 'Chaotisch ritme zonder herkenbare QRS-complexen met variërende amplitude = ventrikelfibrilleren.'
 },
 {
 question: 'Wat is de eerste actie?',
 options: ['Adrenaline toedienen', 'Defibrilleren (fabrikantadviesenergie)', 'Intuberen', 'Echocardiogram'],
 correct: 1,
 explanation: 'VF is een schokbaar ritme. Start CPR en defibrilleer zo snel mogelijk met fabrikantadviesenergie (bij bifasisch vaak 120-200J), met energie-escalatie volgens lokaal protocol.'
 }
 ]
 },
 {
 id: 'case_potassium',
 title: 'Spierzwakte en ECG veranderingen',
 patientIcon: '*',
 patientInfo: 'Man, 72 jaar',
 presentation: 'Chronische nierinsufficiëntie, gemiste dialyse, spierzwakte, bradycard op monitor.',
 vitals: { hr: 45, bp: '100/70', spo2: 95, rr: 16 },
 rhythm: 'hyperkalemia',
 difficulty: 'hard',
 duration: 12,
 questions: [
 {
 question: 'Wat valt op aan dit ECG?',
 options: ['ST-elevatie', 'Spitse T-golven en breed QRS', 'Diepe Q-golven', 'Delta golven'],
 correct: 1,
 explanation: 'Spitse "tenting" T-golven, verbrede QRS-complexen en afgevlakte P-golven zijn klassieke tekenen van hyperkaliëmie.'
 },
 {
 question: 'Wat is de eerste behandeling?',
 options: ['Insuline/glucose', 'Calcium IV', 'Dialyse', 'Natriumbicarbonaat'],
 correct: 1,
 explanation: 'Calcium IV is de eerste stap - het stabiliseert de hartspiercel membraan. Daarna K+ verlagen met insuline/glucose en elimineren via dialyse.'
 }
 ]
 },
 {
 id: 'case_af_rvr',
 title: 'Snelle AF op de IC',
 patientIcon: '*',
 patientInfo: 'Vrouw, 68 jaar',
 presentation: 'Opgenomen voor pneumonie, nu kortademig, onregelmatige pols.',
 vitals: { hr: 142, bp: '130/85', spo2: 92, rr: 24 },
 rhythm: 'atrial_fibrillation',
 difficulty: 'medium',
 duration: 10,
 questions: [
 {
 question: 'Wat is het ritme?',
 options: ['Atriumflutter', 'Atriumfibrilleren', 'MAT', 'Sinustachycardie'],
 correct: 1,
 explanation: 'Onregelmatig onregelmatig ritme zonder duidelijke P-golven, met fibrillatiegolven in de baseline = atriumfibrilleren.'
 },
 {
 question: 'Welke behandeling is eerste keus voor rate control?',
 options: ['Flecaïnide', 'Metoprolol', 'Amiodaron', 'Adenosine'],
 correct: 1,
 explanation: 'Bij stabiele AF is rate control meestal met een bètablokker (zoals metoprolol) of, afhankelijk van LV-functie/comorbiditeit, een non-DHP calciumantagonist. Digoxine vooral in geselecteerde situaties (bijv. hartfalen/sedentair). Flecaïnide is rhythm-control, niet eerste keus voor rate control.'
 }
 ]
 },
 {
 id: 'case_post_arrest_stemi',
 moduleId: 'module_5',
 title: 'Post-ROSC met ischemisch patroon',
 patientIcon: '*',
 patientInfo: 'Man, 61 jaar',
 presentation: 'ROSC na korte VF-reanimatie, nu geintubeerd en hemodynamisch net stabiel.',
 vitals: { hr: 108, bp: '102/64', spo2: 98, rr: 14 },
 rhythm: 'stemi_inferior',
 difficulty: 'hard',
 duration: 12,
 learningObjectives: [
 'Herken een inferieur STEMI-patroon na ROSC',
 'Koppel post-arrestzorg aan snelle reperfusieregeling'
 ],
 debrief: 'Na ROSC blijft oorzaakbehandeling cruciaal; bij STEMI-criteria blijft urgente coronairangiografie aangewezen.',
 questions: [
 {
 type: 'recognition',
 question: 'Welke ECG-conclusie past het best?',
 options: ['Normale post-arrest repolarisatie', 'Inferieur STEMI-patroon', 'Alleen pericarditis', 'Alleen rechterbundeltakblok'],
 correct: 1,
 explanation: 'ST-elevatie in inferieure afleidingen met passend territoriaal patroon past bij inferieur STEMI.',
 sourceId: 'esc_acs_2023',
 guidelineRef: 'ESC ACS 2023: STEMI-interpretatie en reperfusiebeleid in post-arrestcontext.'
 },
 {
 type: 'first_action',
 question: 'Wat is de eerstvolgende beste stap?',
 options: ['Alleen seriele troponines afwachten', 'Urgente coronairstrategie/cathlab in gang zetten', 'Eerst 24 uur observatie zonder interventie', 'Alleen anti-aritmica voortzetten'],
 correct: 1,
 explanation: 'Bij post-ROSC met STEMI-patroon is snelle invasieve coronairstrategie aangewezen conform ACS-richtlijn.',
 sourceId: 'esc_acs_2023',
 guidelineRef: 'ESC ACS 2023: onmiddellijke reperfusiestrategie bij STEMI.'
 }
 ]
 },
 {
 id: 'case_sepsis_tachyarrhythmia',
 moduleId: 'module_3',
 title: 'Sepsis met tachyaritmie',
 patientIcon: '*',
 patientInfo: 'Vrouw, 74 jaar',
 presentation: 'Septische shock op de IC, nu toenemende tachycardie en dyspneu.',
 vitals: { hr: 156, bp: '98/58', spo2: 91, rr: 30 },
 rhythm: 'atrial_fibrillation',
 difficulty: 'hard',
 duration: 11,
 learningObjectives: [
 'Differentieer AF met snelle respons van sinus/sepsis-tachycardie',
 'Koppel ritmebehandeling aan oorzaakgerichte sepsiszorg'
 ],
 debrief: 'Bij sepsis met AF-RVR behandel je parallel: hemodynamiek, infectiebron en ritme/frequentiecontrole.',
 questions: [
 {
 type: 'recognition',
 question: 'Welke ritmediagnose is het meest waarschijnlijk?',
 options: ['Sinustachycardie', 'Atriumfibrilleren met snelle ventrikelrespons', 'Atriumflutter 2:1', 'Monomorfe VT'],
 correct: 1,
 explanation: 'Het onregelmatig-onregelmatige patroon zonder consistente P-golven past bij AF met RVR.',
 sourceId: 'esc_af_2024',
 guidelineRef: 'ESC AF 2024: AF-diagnostiek in acute setting.'
 },
 {
 type: 'first_action',
 question: 'Wat is de beste eerste managementstap?',
 options: ['Alleen adenosine geven', 'Hemodynamische stabiliteit beoordelen en oorzaak plus rate-control parallel behandelen', 'Direct elektrische defibrillatie zonder ritmebeoordeling', 'Geen ritme-interventie doen'],
 correct: 1,
 explanation: 'Bij mogelijk nog stabiele AF in sepsis staat gecombineerde oorzaakbehandeling en gecontroleerde rate-control centraal.',
 sourceId: 'esc_af_2024',
 guidelineRef: 'ESC AF 2024: rate-control in klinische context met hemodynamische beoordeling.'
 }
 ]
 },
 {
 id: 'case_intox_qt',
 moduleId: 'module_7',
 title: 'Intoxicatie met QT-verlenging',
 patientIcon: '*',
 patientInfo: 'Vrouw, 29 jaar',
 presentation: 'Inname van meerdere QT-verlengende middelen, nu palpitaties en presyncope.',
 vitals: { hr: 118, bp: '110/68', spo2: 97, rr: 20 },
 rhythm: 'long_qt',
 difficulty: 'hard',
 duration: 10,
 learningObjectives: [
 'Herken een risicovol lang-QT-patroon',
 'Start torsades-profylaxe en triggercorrectie'
 ],
 debrief: 'Lang QT verhoogt torsadesrisico; corrigeer reversibele factoren snel en monitor continu.',
 questions: [
 {
 type: 'recognition',
 question: 'Wat is de belangrijkste ECG-bevinding?',
 options: ['Kort PR-interval met delta-golf', 'Verlengd QTc met torsadesrisico', 'Acute ST-elevatie', 'Sinoatriaal blok'],
 correct: 1,
 explanation: 'Een duidelijk verlengd QTc in deze context wijst op verhoogd risico op polymorfe VT/torsades.',
 sourceId: 'esc_va_2022',
 guidelineRef: 'ESC VA 2022: lang QT als substrate voor polymorfe VT/torsades.'
 },
 {
 type: 'first_action',
 question: 'Wat is de eerste veilige stap?',
 options: ['QT-verlengende middelen continueren', 'Stop uitlokkende middelen, corrigeer elektrolyten en geef magnesium bij risico/aritmie', 'Adenosine als standaardbehandeling', 'Alleen geruststellen en ontslag'],
 correct: 1,
 explanation: 'Eerste stap is triggerstop en correctie van elektrolyten; magnesium is aangewezen bij torsadesrisico of polymorfe VT.',
 sourceId: 'esc_va_2022',
 guidelineRef: 'ESC VA 2022: acute aanpak van torsadesgevoeligheid en polymorfe VT.'
 }
 ]
 },
 {
 id: 'case_hypokalemia_qt',
 moduleId: 'module_7',
 title: 'Hypokaliemie op de bewaking',
 patientIcon: '*',
 patientInfo: 'Man, 67 jaar',
 presentation: 'Diureticagebruik, nu spierkrampen en extrasystolen op telemetrie.',
 vitals: { hr: 102, bp: '124/76', spo2: 97, rr: 18 },
 rhythm: 'hypokalemia',
 difficulty: 'medium',
 duration: 9,
 learningObjectives: [
 'Herken U-golven en repolarisatieveranderingen bij hypokaliemie',
 'Voorkom progressie naar ventriculaire aritmieen'
 ],
 debrief: 'Hypokaliemie vergroot aritmiekans. Corrigeer kalium gericht en monitor ECG-dynamiek.',
 questions: [
 {
 type: 'recognition',
 question: 'Welk patroon past het best bij hypokaliemie?',
 options: ['Spitse T-golven met PR-verkorting', 'Afgevlakte T-golven met prominente U-golven', 'Diffuse ST-elevatie met PR-depressie', 'Breedcomplex escape-ritme'],
 correct: 1,
 explanation: 'Afgevlakte T-golven, ST-depressie en prominente U-golven zijn klassiek voor hypokaliemie.',
 sourceId: 'erc_als_2025',
 guidelineRef: 'ERC/ALS 2025: ECG-patronen en risicocontext bij elektrolytstoornissen.'
 },
 {
 type: 'first_action',
 question: 'Wat is de eerste managementstap?',
 options: ['Kaliumsuppletie starten met continue ECG-monitoring', 'Geen actie, alleen herhalen over 24 uur', 'Direct adenosine bolus', 'Alleen anti-aritmica starten'],
 correct: 0,
 explanation: 'Bij symptomatische of ECG-relevante hypokaliemie start je gecontroleerde kaliumcorrectie met ritmemonitoring.',
 sourceId: 'erc_als_2025',
 guidelineRef: 'ERC/ALS 2025: vroege correctie van reversibele metabole oorzaken.'
 }
 ]
 },
 {
 id: 'case_pacemaker_failure',
 moduleId: 'module_7',
 title: 'Pacemakerprobleem na opname',
 patientIcon: '*',
 patientInfo: 'Man, 81 jaar',
 presentation: 'Bekende pacemakerdrager met duizeligheid en near-syncope.',
 vitals: { hr: 38, bp: '88/54', spo2: 95, rr: 17 },
 rhythm: 'pacemaker_malfunction',
 difficulty: 'hard',
 duration: 11,
 learningObjectives: [
 'Herken falende pacing/capture op ECG',
 'Start veilige overbrugging bij symptomatische bradycardie'
 ],
 debrief: 'Bij pacemakerfailure staat eerst patientveiligheid voorop: monitoren, tijdelijke overbrugging en device-evaluatie.',
 questions: [
 {
 type: 'recognition',
 question: 'Welke ECG-conclusie is het meest waarschijnlijk?',
 options: ['Normale dual-chamber pacing', 'Pacemaker malfunction met capture-sensingprobleem', 'Sinusritme zonder deviceactiviteit', 'Typische AVNRT'],
 correct: 1,
 explanation: 'Pacing spikes zonder consistente capture en/of onjuiste sensing passen bij pacemaker malfunction.',
 sourceId: 'esc_pacing_2021',
 guidelineRef: 'ESC Pacing 2021: herkenning van capture/sensing-problemen.'
 },
 {
 type: 'first_action',
 question: 'Wat is de eerste veilige stap bij deze instabiliteit?',
 options: ['Afwachten tot devicecontrole morgen', 'Transcutane pacing/overbrugging en urgente pacemaker-evaluatie', 'Adenosine geven', 'Alleen orale medicatie starten'],
 correct: 1,
 explanation: 'Bij symptomatische bradycardie door vermoedelijke devicefailure is tijdelijke pacingoverbrugging met urgente evaluatie passend.',
 sourceId: 'esc_pacing_2021',
 guidelineRef: 'ESC Pacing 2021: acute overbrugging en urgente device-evaluatie.'
 }
 ]
 },
 {
 id: 'case_dewinter_acs',
 moduleId: 'module_6',
 title: 'ACS-equivalent zonder ST-elevatie',
 patientIcon: '*',
 patientInfo: 'Man, 52 jaar',
 presentation: 'Aanhoudende thoracale pijn en vegetatieve klachten, geen klassieke ST-elevatie.',
 vitals: { hr: 104, bp: '138/88', spo2: 97, rr: 22 },
 rhythm: 'deWinter',
 difficulty: 'hard',
 duration: 12,
 learningObjectives: [
 'Herken het de Winter-patroon als occlusie-equivalent',
 'Escaleer reperfusiebeleid ondanks afwezigheid van klassiek STEMI'
 ],
 debrief: 'Het de Winter-patroon is hoog-risico voor acute coronairocclusie en vraagt snelle invasieve strategie.',
 questions: [
 {
 type: 'recognition',
 question: 'Hoe interpreteer je dit ECG het best?',
 options: ['Laag-risico NSTEMI zonder urgentie', 'de Winter-patroon, STEMI-equivalent', 'Pericarditis', 'Benigne vroege repolarisatie'],
 correct: 1,
 explanation: 'Upsloping ST-depressie met hoge symmetrische T-golven in precordiale afleidingen past bij de Winter, een STEMI-equivalent.',
 sourceId: 'de_winter_2019',
 guidelineRef: 'de Winter review: STEMI-equivalent patroon met hoge occlusiewaarde.'
 },
 {
 type: 'first_action',
 question: 'Wat is de juiste eerste vervolgstap?',
 options: ['Afwachten op seriele ECG-verandering', 'Behandel als acute coronairocclusie en activeer urgente coronairstrategie', 'Alleen pijnstilling en ontslag', 'Adenosine proefbehandeling'],
 correct: 1,
 explanation: 'Ondanks ontbrekende klassieke ST-elevatie behandel je dit patroon als acute occlusie met urgente reperfusiestrategie.',
 sourceId: 'esc_acs_2023',
 guidelineRef: 'ESC ACS 2023: hoog-risico ischemiepatronen vereisen urgente coronairstrategie.'
 }
 ]
 },
 {
 id: 'case_unstable_brady',
 moduleId: 'module_5',
 title: 'Instabiele bradycardie op de SEH',
 patientIcon: '*',
 patientInfo: 'Vrouw, 79 jaar',
 presentation: 'Duizelig, klam en hypotensief met episodes van bijna-syncope.',
 vitals: { hr: 32, bp: '82/48', spo2: 93, rr: 20 },
 rhythm: 'avblock_2nd_type2',
 difficulty: 'hard',
 duration: 10,
 learningObjectives: [
 'Herken hooggradig geleidingsprobleem met instabiliteit',
 'Kies tijdige pacing-escalatie boven afwachten'
 ],
 debrief: 'Bij Mobitz II met instabiliteit is vroege pacing essentieel; alleen medicamenteus beleid is vaak onvoldoende.',
 questions: [
 {
 type: 'recognition',
 question: 'Welke ritmediagnose is het meest waarschijnlijk?',
 options: ['Sinusbradycardie', 'Mobitz I (Wenckebach)', 'Mobitz II AV-blok', 'Junctionele tachycardie'],
 correct: 2,
 explanation: 'Constante PR-intervalen met plots uitvallende QRS-complexen passen bij Mobitz II.',
 sourceId: 'esc_pacing_2021',
 guidelineRef: 'ESC Pacing 2021: diagnostische kenmerken Mobitz II.'
 },
 {
 type: 'first_action',
 question: 'Wat is de eerste veilige stap bij deze instabiliteit?',
 options: ['Alleen observeren', 'Direct pacingpad starten (transcutaan) en specialistisch opschalen', 'Adenosine geven', 'Alleen orale beta-blokker geven'],
 correct: 1,
 explanation: 'Instabiele hooggradige AV-geleidingsstoornis vraagt directe pacingoverbrugging en snelle escalatie.',
 sourceId: 'erc_als_2025',
 guidelineRef: 'ERC/ALS 2025: instabiele bradycardie met pacing-escalatie.'
 }
 ]
 },
 {
 id: 'case_wide_complex_tachy',
 moduleId: 'module_5',
 title: 'Breedcomplex tachycardie met differentiaal',
 patientIcon: '*',
 patientInfo: 'Man, 63 jaar',
 presentation: 'Acute palpitaties met thoracale druk, bekende ischemische cardiomyopathie.',
 vitals: { hr: 172, bp: '108/66', spo2: 95, rr: 22 },
 rhythm: 'vtach_monomorphic',
 difficulty: 'hard',
 duration: 12,
 learningObjectives: [
 'Benader breedcomplex tachycardie primair als VT bij twijfel',
 'Kies veilig eerste behandelpad op basis van stabiliteit'
 ],
 debrief: 'Bij breedcomplex tachycardie en structurele hartziekte is VT het meest waarschijnlijk tot het tegendeel bewezen is.',
 questions: [
 {
 type: 'differential',
 question: 'Welke diagnose is hier het meest waarschijnlijk?',
 options: ['SVT met aberrantie', 'Monomorfe ventriculaire tachycardie', 'Atriumflutter 2:1', 'Sinustachycardie met bundeltakblok'],
 correct: 1,
 explanation: 'Regelmatige breedcomplex tachycardie in deze klinische context moet als VT worden benaderd.',
 sourceId: 'esc_va_2022',
 guidelineRef: 'ESC VA 2022: brede-complex tachycardie als VT benaderen bij twijfel.'
 },
 {
 type: 'first_action',
 question: 'Wat is de eerste veilige behandelstrategie?',
 options: ['Adenosine standaard geven', 'Hemodynamische stabiliteit direct beoordelen en VT-pad volgen (anti-aritmicum of cardioversie)', 'Geen interventie starten', 'Alleen pijnstilling geven'],
 correct: 1,
 explanation: 'De eerste stap is stabiliteit beoordelen en vervolgens VT-management kiezen; bij instabiliteit direct gesynchroniseerde cardioversie.',
 sourceId: 'esc_va_2022',
 guidelineRef: 'ESC VA 2022: acute VT-aanpak op basis van stabiliteit.'
 }
 ]
 }
 ],

 getAllCases() {
 return this.cases;
 },

 getCaseById(id) {
 return this.cases.find(c => c.id === id);
 }
 };

 // Ensure every case question has explanation + single primary source URL.
 MedicalContentAudit.ensureCaseQuestionSources();

 // ==================== DEEL 4 GAAT HIER VERDER ====================

 // ==================== QUIZ LOGIC ====================
 const QuizEngine = {
 getTimedSeconds() {
 return parseInt(AppState.settings?.timerSeconds, 10) || 30;
 },
 
 // Initialize a new quiz
 init(options = {}) {
 const quiz = AppState.quiz;
 
 // Reset quiz state
 quiz.active = true;
 quiz.mode = options.mode || 'standard';
 quiz.difficulty = options.difficulty || 'all';
 quiz.category = options.category || 'all';
 quiz.moduleId = options.moduleId || null;
 quiz.predefinedRhythms = Array.isArray(options.predefinedRhythms) ? [...new Set(options.predefinedRhythms)] : [];
 quiz.examBlueprintQueue = [];
 quiz.currentQuestion = 0;
 quiz.totalQuestions = options.totalQuestions || 10;
 quiz.score = 0;
 quiz.answers = [];
 quiz.selectedAnswer = null;
 quiz.showingFeedback = false;
 quiz.timeRemaining = quiz.mode === 'timed' ? this.getTimedSeconds() : 0;
 quiz.pendingConfidence = null;
 quiz.pendingAnswerIndex = null;
 quiz.currentOptionIds = [];
 quiz.currentAdaptiveProfile = null;
 quiz.currentQuestionPayload = null;
 quiz.questionType = 'recognition';
 quiz.questionTypeMix = this.getQuestionTypeMix(quiz);
 
 // For survival mode, unlimited questions
 if (quiz.mode === 'survival') {
 quiz.totalQuestions = 999;
 }
 if (quiz.mode === 'exam') {
 quiz.totalQuestions = 20;
 quiz.difficulty = 'all';
 quiz.category = 'all';
 quiz.examBlueprintQueue = this.buildExamBlueprintQueue(quiz.totalQuestions);
 quiz.predefinedRhythms = [...quiz.examBlueprintQueue];
 }
 if (quiz.mode === 'critical') {
 const criticalIds = ECGDatabase.getCriticalRhythms().map(r => r.id);
 quiz.predefinedRhythms = (quiz.predefinedRhythms && quiz.predefinedRhythms.length)
 ? quiz.predefinedRhythms.filter(id => criticalIds.includes(id))
 : criticalIds;
 quiz.totalQuestions = Math.max(1, Math.min(options.totalQuestions || 10, quiz.predefinedRhythms.length || 10));
 quiz.difficulty = 'all';
 quiz.category = 'all';
 }
 if (quiz.mode === 'recovery') {
 quiz.totalQuestions = Math.min(10, quiz.predefinedRhythms.length || 10);
 }
 if (quiz.mode === 'coach') {
 quiz.totalQuestions = Math.min(10, quiz.predefinedRhythms.length || 10);
 }
 if (quiz.mode === 'sprint') {
 quiz.totalQuestions = Math.min(5, quiz.predefinedRhythms.length || 5);
 }
 
 // Generate first question
 this.generateQuestion();
 
 return quiz;
 },

 getExamDomainForRhythm(rhythm) {
 if (!rhythm) return 'overig';
 const toxIds = new Set(['hyperkalemia', 'hypokalemia', 'hypercalcemia', 'hypocalcemia', 'long_qt', 'digoxin_toxicity', 'pacemaker_malfunction']);
 if (toxIds.has(rhythm.id)) return 'elektrolyten_tox';
 if (rhythm.category === 'ischemia') return 'ischemie_equivalenten';
 if (rhythm.category === 'blocks') return 'geleiding';
 if (rhythm.category === 'ventricular' || rhythm.id === 'asystole' || rhythm.id === 'pea') return 'ventriculair_arrest';
 if (rhythm.category === 'atrial' || rhythm.category === 'tachycardia') return 'atriaal_tachy';
 if (rhythm.category === 'normal' || rhythm.category === 'bradycardia') return 'basis_sinus_brady';
 return 'overig';
 },

 getExamBlueprintSpec() {
 return [
 { domain: 'basis_sinus_brady', count: 4 },
 { domain: 'atriaal_tachy', count: 5 },
 { domain: 'geleiding', count: 3 },
 { domain: 'ventriculair_arrest', count: 4 },
 { domain: 'ischemie_equivalenten', count: 3 },
 { domain: 'elektrolyten_tox', count: 1 }
 ];
 },

 pickFromPool(pool, count, excludeIds) {
 const result = [];
 const available = Utils.shuffle(pool.filter(r => !excludeIds.has(r.id)));
 for (let i = 0; i < Math.min(count, available.length); i++) {
 result.push(available[i].id);
 excludeIds.add(available[i].id);
 }
 return result;
 },

 buildExamBlueprintQueue(totalQuestions = 20) {
 const allRhythms = ECGDatabase.getAllRhythms();
 const used = new Set();
 const queue = [];

 this.getExamBlueprintSpec().forEach(({ domain, count }) => {
 const pool = allRhythms.filter(r => this.getExamDomainForRhythm(r) === domain);
 queue.push(...this.pickFromPool(pool, count, used));
 });

 if (queue.length < totalQuestions) {
 queue.push(...this.pickFromPool(allRhythms, totalQuestions - queue.length, used));
 }

 return queue.slice(0, totalQuestions);
 },

 getAdaptiveProfile(quiz) {
 const moduleId = quiz?.moduleId || null;
 const total = Math.max(1, quiz?.totalQuestions || 10);
 const progress = ((quiz?.currentQuestion || 0) + 1) / total;

 const base = {
 levelLabel: 'Standaard',
 allowedDifficulties: null,
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 speed: 25,
 amplitude: 1,
 verticalScale: 1,
 lineWidth: 2,
 shadowBlur: 3,
 signalNoise: 0.01,
 baselineWander: 0.01
 }
 };

 if (quiz?.mode === 'exam') {
 return {
 ...base,
 levelLabel: 'Examen',
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 0.95,
 lineWidth: 1.8,
 signalNoise: 0.03,
 baselineWander: 0.02
 }
 };
 }

 if (!moduleId) {
 if (quiz?.difficulty === 'easy') {
 return {
 ...base,
 levelLabel: 'Basis',
 distractorCount: 2,
 forceHints: true,
 showMorphologyGuide: true,
 visual: {
 ...base.visual,
 verticalScale: 1.1,
 lineWidth: 2.6,
 signalNoise: 0,
 baselineWander: 0
 }
 };
 }
 if (quiz?.difficulty === 'hard') {
 return {
 ...base,
 levelLabel: 'Gevorderd',
 visual: {
 ...base.visual,
 verticalScale: 0.92,
 lineWidth: 1.9,
 signalNoise: 0.03,
 baselineWander: 0.02
 }
 };
 }
 return base;
 }

 const profileByModule = {
 module_1: progress < 0.7
 ? {
 levelLabel: 'Module 1 - Basis',
 allowedDifficulties: ['easy'],
 distractorCount: 2,
 forceHints: true,
 showMorphologyGuide: true,
 visual: {
 ...base.visual,
 verticalScale: 1.2,
 lineWidth: 2.8,
 signalNoise: 0,
 baselineWander: 0
 }
 }
 : {
 levelLabel: 'Module 1 - Basis+',
 allowedDifficulties: ['easy', 'medium'],
 distractorCount: 2,
 forceHints: true,
 showMorphologyGuide: true,
 visual: {
 ...base.visual,
 verticalScale: 1.1,
 lineWidth: 2.6,
 signalNoise: 0.005,
 baselineWander: 0
 }
 },
 module_2: {
 levelLabel: 'Module 2 - Intro Analyse',
 allowedDifficulties: ['easy', 'medium'],
 distractorCount: 3,
 forceHints: true,
 showMorphologyGuide: true,
 visual: {
 ...base.visual,
 verticalScale: 1.05,
 lineWidth: 2.4,
 signalNoise: 0.008,
 baselineWander: 0.005
 }
 },
 module_3: progress < 0.6
 ? {
 levelLabel: 'Module 3 - Opbouw',
 allowedDifficulties: ['medium'],
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 1,
 signalNoise: 0.015,
 baselineWander: 0.01
 }
 }
 : {
 levelLabel: 'Module 3 - Uitdaging',
 allowedDifficulties: ['medium', 'hard'],
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 0.95,
 lineWidth: 2,
 signalNoise: 0.02,
 baselineWander: 0.015
 }
 },
 module_4: {
 levelLabel: 'Module 4 - Geleiding',
 allowedDifficulties: ['medium', 'hard'],
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 0.95,
 lineWidth: 2,
 signalNoise: 0.02,
 baselineWander: 0.015
 }
 },
 module_5: {
 levelLabel: 'Module 5 - Spoed',
 allowedDifficulties: ['medium', 'hard'],
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 0.92,
 lineWidth: 1.9,
 signalNoise: 0.025,
 baselineWander: 0.02
 }
 },
 module_6: {
 levelLabel: 'Module 6 - Ischemie',
 allowedDifficulties: ['medium', 'hard'],
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 0.92,
 lineWidth: 1.9,
 signalNoise: 0.025,
 baselineWander: 0.02
 }
 },
 module_7: {
 levelLabel: 'Module 7 - Tox/Elektrolyt',
 allowedDifficulties: ['medium', 'hard'],
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 0.9,
 lineWidth: 1.9,
 signalNoise: 0.03,
 baselineWander: 0.02
 }
 },
 module_8: {
 levelLabel: 'Module 8 - Integratie',
 allowedDifficulties: ['hard', 'medium'],
 distractorCount: 3,
 forceHints: false,
 showMorphologyGuide: false,
 visual: {
 ...base.visual,
 verticalScale: 0.88,
 lineWidth: 1.8,
 signalNoise: 0.035,
 baselineWander: 0.025
 }
 }
 };

 return profileByModule[moduleId] || base;
 },

 getQuestionTypeMix(quiz) {
 const fallback = { recognition: 0.5, differential: 0.3, first_action: 0.2 };
 if (!quiz) return fallback;

 if (quiz.mode === 'exam') return { recognition: 0.4, differential: 0.4, first_action: 0.2 };
 if (quiz.mode === 'critical') return { recognition: 0.25, differential: 0.35, first_action: 0.4 };
 if (quiz.mode === 'recovery') return { recognition: 0.35, differential: 0.4, first_action: 0.25 };

 const moduleNum = parseInt((quiz.moduleId || '').replace('module_', ''), 10);
 if (!Number.isNaN(moduleNum)) {
 if (moduleNum <= 2) return { recognition: 0.7, differential: 0.2, first_action: 0.1 };
 if (moduleNum <= 4) return { recognition: 0.5, differential: 0.35, first_action: 0.15 };
 return { recognition: 0.3, differential: 0.4, first_action: 0.3 };
 }

 return quiz.questionTypeMix || fallback;
 },

 pickQuestionType(quiz, rhythm) {
 const mix = this.getQuestionTypeMix(quiz);
 const roll = Math.random();
 const rec = Math.max(0, mix.recognition || 0);
 const diff = Math.max(0, mix.differential || 0);
 const thresholdDiff = rec + diff;

 let type = roll < rec
 ? 'recognition'
 : roll < thresholdDiff
 ? 'differential'
 : 'first_action';

 const hasDifferential = Array.isArray(rhythm?.differentialIds) && rhythm.differentialIds.length > 0;
 const hasAction = typeof rhythm?.firstAction === 'string' && rhythm.firstAction.trim().length > 0;

 if (type === 'differential' && !hasDifferential) type = 'recognition';
 if (type === 'first_action' && !hasAction) type = hasDifferential ? 'differential' : 'recognition';

 return type;
 },

 buildFirstActionOptions(rhythm, pool) {
 const all = Array.isArray(pool) && pool.length ? pool : ECGDatabase.getAllRhythms();
 const correctId = `action_${rhythm.id}`;
 const options = [{
 id: correctId,
 label: rhythm.firstAction || 'Voer ABCDE uit en volg lokaal protocol',
 description: rhythm.firstActionWhy || 'Eerste veilige stap op basis van ritmekenmerken en klinische context.',
 rhythmId: rhythm.id
 }];

 const distractors = Utils.shuffle(
 all
 .filter(r => r.id !== rhythm.id && typeof r.firstAction === 'string' && r.firstAction.trim().length > 0)
 .map(r => ({
 id: `action_${r.id}`,
 label: r.firstAction,
 description: r.firstActionWhy || 'Mogelijke actie in een andere ritmecontext.',
 rhythmId: r.id
 }))
 );

 const seenLabels = new Set(options.map(o => o.label.toLowerCase()));
 for (const candidate of distractors) {
 const key = (candidate.label || '').toLowerCase();
 if (seenLabels.has(key)) continue;
 seenLabels.add(key);
 options.push(candidate);
 if (options.length >= 4) break;
 }

 while (options.length < 4) {
 options.push({
 id: `action_generic_${options.length}`,
 label: 'Alleen observeren en later herhalen',
 description: 'Deze keuze is meestal onveilig bij acute ritmestoornissen zonder aanvullende beoordeling.',
 rhythmId: 'generic'
 });
 }

 return {
 type: 'first_action',
 prompt: `Wat is de eerste veilige stap bij ${rhythm.name}?`,
 correctId,
 options: Utils.shuffle(options).slice(0, 4)
 };
 },

 buildVisualContext(quiz, rhythm) {
 const allLeads = ECGRenderer.LEAD_ORDER || ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
 const keyLeadsRaw = Array.isArray(rhythm?.leadProfile?.keyLeads)
 ? rhythm.leadProfile.keyLeads
 : ['II', 'V1', 'V5'];
 const keyLeads = keyLeadsRaw.filter(lead => allLeads.includes(lead)).slice(0, 6);
 const defaultFocusLead = keyLeads.includes('II') ? 'II' : (keyLeads[0] || 'II');
 const moduleNum = parseInt((quiz?.moduleId || '').replace('module_', ''), 10);
 const showLeadHint = Number.isNaN(moduleNum) ? true : moduleNum <= 2;
 return {
 defaultFocusLead,
 keyLeads,
 showLeadHint
 };
 },

 buildQuestionPayload(quiz, rhythm, pool = []) {
 if (!rhythm) return null;
 const type = this.pickQuestionType(quiz, rhythm);
 const visualContext = this.buildVisualContext(quiz, rhythm);

 if (type === 'first_action') {
 const firstActionPayload = this.buildFirstActionOptions(rhythm, pool);
 firstActionPayload.visualContext = visualContext;
 return firstActionPayload;
 }

 const all = Array.isArray(pool) && pool.length ? pool : ECGDatabase.getAllRhythms();
 const optionRhythms = [rhythm];

 if (type === 'differential') {
 const differential = [];
 (rhythm.differentialIds || []).forEach(id => {
 const r = ECGDatabase.getRhythmById(id);
 if (r && r.id !== rhythm.id) differential.push(r);
 });
 if (differential.length < 3) {
 ECGDatabase.getDistractors(rhythm.id, 6)
 .filter(r => r.id !== rhythm.id)
 .forEach(r => differential.push(r));
 }
 optionRhythms.push(...Utils.shuffle(differential).slice(0, 3));
 } else {
 optionRhythms.push(
 ...ECGDatabase.getDistractors(rhythm.id, 6)
 .filter(r => r.id !== rhythm.id)
 .slice(0, 3)
 );
 }

 const unique = [];
 const seen = new Set();
 optionRhythms.forEach(r => {
 if (r && !seen.has(r.id)) {
 seen.add(r.id);
 unique.push(r);
 }
 });

 return {
 type,
 prompt: type === 'differential'
 ? `Welk ritme past het best bij dit ECG (differentiaal)?`
 : 'Welk ritme zie je?',
 correctId: rhythm.id,
 visualContext,
 options: Utils.shuffle(unique.slice(0, 4)).map(r => ({
 id: r.id,
 name: r.name,
 shortName: r.shortName,
 description: r.description,
 rhythmId: r.id
 }))
 };
 },

 // Generate a new question
 generateQuestion() {
 const quiz = AppState.quiz;
 const askedIds = quiz.answers.map(a => a.rhythmId);
 const quality = AppState.quizQuality || {};
 const repeatWindow = Math.max(1, parseInt(quality.repeatGuardWindow, 10) || 5);
 const diversityWindow = Math.max(repeatWindow, parseInt(quality.diversityWindow, 10) || 10);
 const maxCategoryShare = Math.max(0.1, Math.min(0.9, Number(quality.maxCategoryShare) || 0.4));
 const recentIds = askedIds.slice(-repeatWindow);
 const adaptive = this.getAdaptiveProfile(quiz);
 quiz.currentAdaptiveProfile = adaptive;
 
 // Get rhythm based on settings
 const options = {
 difficulty: quiz.difficulty,
 category: quiz.category,
 exclude: askedIds // Prefer not to repeat rhythms
 };
 if (quiz.moduleId) {
 options.moduleId = quiz.moduleId;
 }

 const chooseBestCandidate = (pool) => {
 if (!Array.isArray(pool) || pool.length === 0) return null;

 const usageCount = {};
 askedIds.forEach(id => {
 usageCount[id] = (usageCount[id] || 0) + 1;
 });
 const recentAnswers = (quiz.answers || []).slice(-diversityWindow);
 const recentCategoryCount = {};
 recentAnswers.forEach(ans => {
 const rhythm = ECGDatabase.getRhythmById(ans.rhythmId);
 if (!rhythm?.category) return;
 recentCategoryCount[rhythm.category] = (recentCategoryCount[rhythm.category] || 0) + 1;
 });

 const nonRecent = pool.filter(r => !recentIds.includes(r.id));
 const unusedNonRecent = nonRecent.filter(r => !askedIds.includes(r.id));
 const unusedAny = pool.filter(r => !askedIds.includes(r.id));

 const candidates =
 unusedNonRecent.length > 0 ? unusedNonRecent :
 nonRecent.length > 0 ? nonRecent :
 unusedAny.length > 0 ? unusedAny :
 pool;

 const maxCategoryCount = Math.max(1, Math.floor(diversityWindow * maxCategoryShare));
 const categoryBalanced = candidates.filter(r => (recentCategoryCount[r.category] || 0) < maxCategoryCount);
 const candidatePool = categoryBalanced.length > 0 ? categoryBalanced : candidates;

 let minUsage = Infinity;
 candidatePool.forEach(r => {
 const count = usageCount[r.id] || 0;
 if (count < minUsage) minUsage = count;
 });

 const leastUsed = candidatePool.filter(r => (usageCount[r.id] || 0) === minUsage);
 return leastUsed[Math.floor(Math.random() * leastUsed.length)] || null;
 };

 const predefinedId = quiz.predefinedRhythms?.[quiz.currentQuestion];
 // Force refresh each question so we never accidentally reuse previous rhythm.
 quiz.currentRhythm = null;
 if (predefinedId) {
 const predefinedRhythm = ECGDatabase.getRhythmById(predefinedId);
 if (predefinedRhythm) {
 quiz.currentRhythm = predefinedRhythm;
 }
 }

 const getPool = () => {
 let pool = [];
 if (quiz.mode === 'critical') {
 pool = ECGDatabase.getCriticalRhythms();
 } else {
 pool = quiz.moduleId
 ? LearningPathEngine.getModuleRhythms(quiz.moduleId)
 : ECGDatabase.getAllRhythms();
 }

 if (quiz.category && quiz.category !== 'all') {
 pool = pool.filter(r => r.category === quiz.category);
 }
 if (quiz.difficulty && quiz.difficulty !== 'all') {
 pool = pool.filter(r => r.difficulty === quiz.difficulty);
 }

 if (Array.isArray(adaptive.allowedDifficulties) && adaptive.allowedDifficulties.length > 0) {
 const adaptivePool = pool.filter(r => adaptive.allowedDifficulties.includes(r.difficulty));
 if (adaptivePool.length > 0) {
 pool = adaptivePool;
 }
 }
 return pool;
 };
 
 // For category-specific quiz
 if (!quiz.currentRhythm) {
 const pool = getPool();
 if (pool.length > 0) {
 quiz.currentRhythm = chooseBestCandidate(pool);
 } else {
 if (quiz.mode === 'critical') {
 const criticalPool = ECGDatabase.getCriticalRhythms()
 .filter(r => !recentIds.includes(r.id));
 if (criticalPool.length > 0) {
 quiz.currentRhythm = criticalPool[Math.floor(Math.random() * criticalPool.length)];
 } else {
 quiz.currentRhythm = ECGDatabase.getCriticalRhythms()[0] || null;
 }
 } else {
 // Final fallback: avoid immediate repeats even when filters are empty.
 const fallback = ECGDatabase.getRandomRhythm({
 ...options,
 exclude: recentIds
 });
 quiz.currentRhythm = fallback || ECGDatabase.getRandomRhythm(options);
 }
 }
 }
 
 // Reset question state
 quiz.selectedAnswer = null;
 quiz.showingFeedback = false;
 quiz.pendingConfidence = null;
 quiz.pendingAnswerIndex = null;
 quiz.currentOptionIds = [];

 const payloadPool = getPool();
 quiz.currentQuestionPayload = this.buildQuestionPayload(quiz, quiz.currentRhythm, payloadPool);
 quiz.questionType = quiz.currentQuestionPayload?.type || 'recognition';
 quiz.questionTypeMix = this.getQuestionTypeMix(quiz);
 if (Array.isArray(quiz.currentQuestionPayload?.options)) {
 quiz.currentOptionIds = quiz.currentQuestionPayload.options.map(o => o.id);
 }
 const defaultFocusLead = quiz.currentQuestionPayload?.visualContext?.defaultFocusLead;
 if (defaultFocusLead && (ECGRenderer.LEAD_ORDER || []).includes(defaultFocusLead)) {
 AppState.quizView.focusLead = defaultFocusLead;
 }
 
 // Reset timer for timed mode
 if (quiz.mode === 'timed') {
 quiz.timeRemaining = this.getTimedSeconds();
 }
 
 return quiz.currentRhythm;
 },

 // Check answer
 checkAnswer(selectedRhythmId) {
 const quiz = AppState.quiz;
 
 if (quiz.showingFeedback) return null;
 
 quiz.selectedAnswer = selectedRhythmId;
 quiz.showingFeedback = true;

 const correctAnswerId = quiz.currentQuestionPayload?.correctId || quiz.currentRhythm.id;
 const isCorrect = selectedRhythmId === correctAnswerId;
 
 // Update score
 if (isCorrect) {
 quiz.score++;
 AppState.user.totalCorrect++;
 }
 AppState.user.totalAnswered++;
 
 // Calculate XP
 const timeBonus = quiz.mode === 'timed' ? Math.floor(quiz.timeRemaining / 3) : 0;
 const xpEarned = Utils.calculateXP(isCorrect, quiz.currentRhythm.difficulty, timeBonus);
 AppState.user.xp += xpEarned;
 
 // Update streak
 if (isCorrect) {
 AppState.user.streak++;
 }
 
 // Record answer
 quiz.answers.push({
 rhythmId: quiz.currentRhythm.id,
 rhythmName: quiz.currentRhythm.name,
 selectedId: selectedRhythmId,
 correctId: correctAnswerId,
 correct: isCorrect,
 xpEarned,
 mode: quiz.mode,
 questionType: quiz.questionType || 'recognition',
 questionPrompt: quiz.currentQuestionPayload?.prompt || 'Welk ritme zie je?',
 confidence: null,
 optionIds: Array.isArray(quiz.currentOptionIds) ? [...quiz.currentOptionIds] : [],
 answeredAt: new Date().toISOString(),
 timeSpent: quiz.mode === 'timed' ? (this.getTimedSeconds() - quiz.timeRemaining) : 0
 });
 quiz.pendingAnswerIndex = quiz.answers.length - 1;
 quiz.pendingConfidence = null;
 
 // Stop timer
 if (quiz.timerInterval) {
 clearInterval(quiz.timerInterval);
 quiz.timerInterval = null;
 }
 
// Save progress (debounced to keep quiz interactions responsive)
Storage.scheduleSave(900);
 
 return {
 isCorrect,
 correctRhythm: quiz.currentRhythm,
 xpEarned
 };
 },

 // Move to next question
 nextQuestion() {
 const quiz = AppState.quiz;

 if (quiz.showingFeedback && AppState.coach.confidenceCaptureRequired && quiz.pendingAnswerIndex !== null) {
 const answer = quiz.answers[quiz.pendingAnswerIndex];
 if (!answer?.confidence) {
 ECGApp.showModal('Zelfvertrouwen ontbreekt', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Kies eerst je zelfvertrouwen: Zeker, Twijfel of Gok.</p>
 </div>
 </div>
 `);
 return true;
 }
 }
 
 quiz.currentQuestion++;
 
 // Check if quiz is complete
 const lastAnswer = quiz.answers[quiz.answers.length - 1];
 if ((quiz.mode === 'survival' && lastAnswer && !lastAnswer.correct) || quiz.currentQuestion >= quiz.totalQuestions) {
 this.endQuiz();
 return false;
 }
 
 // Generate next question
 this.generateQuestion();
 return true;
 },

 // End the quiz
 endQuiz() {
 const quiz = AppState.quiz;
 
 // Stop timer
 if (quiz.timerInterval) {
 clearInterval(quiz.timerInterval);
 quiz.timerInterval = null;
 }
 
 // Calculate final stats
 const totalAnswered = quiz.answers.length;
 const correctAnswers = quiz.answers.filter(a => a.correct).length;
 const accuracy = totalAnswered > 0 ? Math.round((correctAnswers / totalAnswered) * 100) : 0;
 const totalXP = quiz.answers.reduce((sum, a) => sum + a.xpEarned, 0);
 
 // Save to history
 AppState.user.quizHistory.push({
 date: new Date().toISOString(),
 mode: quiz.mode,
 difficulty: quiz.difficulty,
 category: quiz.category,
 moduleId: quiz.moduleId,
 total: totalAnswered,
 correct: correctAnswers,
 accuracy,
 xpEarned: totalXP,
 answers: quiz.answers
 });

 if (['coach', 'recovery', 'sprint'].includes(quiz.mode)) {
 LearningCoachEngine.markCoachCompletion(quiz.answers.map(a => a.rhythmId));
 }
 
 // Check for mastered rhythms
 this.updateMasteredRhythms();
 LearningPathEngine.syncState();
 LearningCoachEngine.syncAnalytics();
 
 // Reset quiz state
 quiz.active = false;
 
// Save final quiz state before showing results
Storage.flushSave('manual');
 
 // Show results
 ECGApp.showQuizResults({
 total: totalAnswered,
 correct: correctAnswers,
 accuracy,
 xpEarned: totalXP,
 answers: quiz.answers
 });
 },

 // Update mastered rhythms based on performance
 updateMasteredRhythms() {
 const history = AppState.user.quizHistory;
 const rhythmStats = {};
 
 // Aggregate stats per rhythm from all quiz answers
 history.forEach(quiz => {
 if (quiz.answers) {
 quiz.answers.forEach(answer => {
 if (!rhythmStats[answer.rhythmId]) {
 rhythmStats[answer.rhythmId] = { correct: 0, total: 0 };
 }
 rhythmStats[answer.rhythmId].total++;
 if (answer.correct) {
 rhythmStats[answer.rhythmId].correct++;
 }
 });
 }
 });
 
 // Mark as mastered if >= 3 correct answers with >= 80% accuracy
 for (const [rhythmId, stats] of Object.entries(rhythmStats)) {
 const accuracy = stats.total > 0 ? (stats.correct / stats.total) : 0;
 if (stats.correct >= 3 && accuracy >= 0.8) {
 if (!AppState.user.masteredRhythms.includes(rhythmId)) {
 AppState.user.masteredRhythms.push(rhythmId);
 }
 }
 }
 },

 // Get hint for current question
 getHint() {
 const rhythm = AppState.quiz.currentRhythm;
 if (!rhythm) return null;

 if (AppState.quiz.questionType === 'first_action') {
 const actionHints = [rhythm.firstActionWhy, rhythm.escalationCue].filter(Boolean);
 if (actionHints.length > 0) {
 return actionHints[Math.floor(Math.random() * actionHints.length)];
 }
 }
 
 const hints = rhythm.quizHints || rhythm.ecgFeatures || [];
 if (hints.length === 0) return 'Geen hint beschikbaar';
 
 return hints[Math.floor(Math.random() * hints.length)];
 },

 // Timer tick (for timed mode)
 tick() {
 const quiz = AppState.quiz;
 
 if (!quiz.active || quiz.showingFeedback) return;
 
 quiz.timeRemaining--;
 
 // Update display
 const timerEl = document.getElementById('quizTimer');
 if (timerEl) {
 timerEl.textContent = `${quiz.timeRemaining}s`;
 if (quiz.timeRemaining <= 10) {
 timerEl.classList.add('text-danger');
 }
 }
 
 // Time's up
 if (quiz.timeRemaining <= 0) {
 this.checkAnswer('timeout');
 ECGApp.showTimeoutFeedback();
 }
 }
 };

 // ==================== MAIN APP CONTROLLER ====================
 const ECGApp = {
 
 // ========== INITIALIZATION ==========
 init() {
 console.log('ECG Trainer Pro v2.5 initializing...');
 
 // Load saved data
 Storage.load();
 LearningCoachEngine.ensureState();
 LearningCoachEngine.syncAnalytics();
 LearningPathEngine.syncState();
 MedicalContentAudit.ensureRhythmMetadata();
 MedicalContentAudit.ensureCaseQuestionSources();
 if (!AppState.learningAnalytics.lastReviewDate) {
 AppState.learningAnalytics.lastReviewDate = '2026-02-16';
 }
 AppState.learningAnalytics.medicalCoverage = MedicalContentAudit.validateCoverage();
 
 // Initialize navigation
 Navigation.init();
 
// Update sidebar stats
this.updateSidebarStats();

// Initial diagnostics snapshot for troubleshooting.
DiagnosticsEngine.runQuick();
const deferredDiagnostics = () => {
try {
DiagnosticsEngine.runFull();
Storage.scheduleSave(2000);
} catch (diagErr) {
console.warn('Volledige diagnostics run mislukt:', diagErr);
}
};
if (typeof window.requestIdleCallback === 'function') {
window.requestIdleCallback(deferredDiagnostics, { timeout: 4000 });
} else {
setTimeout(deferredDiagnostics, 1500);
}
 
 // Setup keyboard shortcuts
 this.setupKeyboardShortcuts();
 
 // Setup window events
window.addEventListener('beforeunload', () => {
ECGRenderer.destroyAll();
Storage.flushSave('beforeunload');
});
 
// Mark as active today
AppState.user.lastActive = new Date().toISOString();
Storage.scheduleSave(1000);
 
 console.log('ECG Trainer Pro ready!');
 },

 // ========== SIDEBAR ==========
 updateSidebarStats() {
 const user = AppState.user;
 const accuracy = Utils.calcAccuracy(user.totalCorrect, user.totalAnswered);
 
 const streakEl = document.getElementById('sidebarStreak');
 const xpEl = document.getElementById('sidebarXP');
 const accEl = document.getElementById('sidebarAccuracy');
 const profileEl = document.getElementById('sidebarProfile');
 
 if (streakEl) streakEl.textContent = user.streak;
 if (xpEl) xpEl.textContent = user.xp;
 if (accEl) accEl.textContent = `${accuracy}%`;
 if (profileEl) profileEl.textContent = AppState.profile?.name || 'Standaard';
 },

 // ========== NAVIGATION ==========
 navigateTo(section) {
 Navigation.navigateTo(section);
 },

 updateBreadcrumb(contextText = '') {
 const breadcrumb = document.getElementById('pageBreadcrumb');
 if (!breadcrumb) return;

 const section = Navigation.sections[AppState.currentSection];
 const sectionLabel = section?.title
 ? section.title.replace(/^[^\s]+\s/, '')
 : 'Dashboard';

 const parts = ['Dashboard'];
 if (AppState.currentSection !== 'dashboard') parts.push(sectionLabel);
 if (contextText) parts.push(contextText);
 breadcrumb.textContent = parts.join(' > ');
 },

 getContextHelpHTML(sectionId = AppState.currentSection) {
 if (AppState.ui?.contextualHelp === false) return '';

 const map = {
 monitor: 'Monitor: kies uit alle 12 afleidingen, zet artifact aan/uit en gebruik Freeze om het spoor rustig te analyseren.',
 quiz: 'Quiz: beoordeel het 12-lead overzicht plus focus-lead. Kijk eerst naar ritme, QRS-breedte, territorium en urgentie.',
 cases: 'Cases: prioriteer hemodynamische stabiliteit, benoem eerstvolgende veilige stap en wanneer je opschaalt.',
 learningPath: 'Leerpad: als iets vergrendeld is zie je exact welke criteria nog ontbreken en hoeveel nog nodig is.'
 };

 const text = map[sectionId];
 if (!text) return '';
 return `<div class="context-help-card"> ${text}</div>`;
 },

 showLockReason({ target = 'actie', requirements = [] } = {}) {
 const reqItems = Array.isArray(requirements) ? requirements : [];
 const requirementList = reqItems.length
 ? `<ul class="styled-list" style="margin-top:0.5rem;">${reqItems.map(item => `<li>${item}</li>`).join('')}</ul>`
 : '<p class="text-muted" style="margin-top:0.5rem;">Voltooi eerst de vereiste stappen in het leerpad.</p>';

 this.showModal('Nog niet beschikbaar', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>${target}</h4>
 <p>Deze actie is nog vergrendeld. Rond eerst onderstaande criteria af:</p>
 ${requirementList}
 </div>
 </div>
 `);
 },

completeOnboarding() {
AppState.ui.onboardingCompleted = true;
Storage.scheduleSave(800);
if (AppState.currentSection === 'dashboard') {
Sections.renderDashboard(Utils.$('#contentArea'));
}
},

runDiagnostics() {
const { result, checks } = DiagnosticsEngine.runFull();
Storage.scheduleSave(1200);

const statusBadge = (ok, label) => ok
? `<li>OK ${label}</li>`
: `<li>Niet OK ${label}</li>`;

this.showModal('App-check Resultaat', `
<div class="info-box ${checks.binding.ok && checks.navigation.ok && checks.coverage.ok && checks.monitor.ok && checks.variation.ok && checks.visual.ok ? 'success' : 'warning'}">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Laatste run: ${(result.lastRunAt || '').replace('T', ' ').slice(0, 19)}</h4>
 <p style="margin-top:0.35rem;"> Score: <strong>${result.score || 0}</strong>/100 (${result.scoreBand || 'Onbekend'})
 </p>
 <ul class="styled-list" style="margin-top:0.5rem;">
 ${statusBadge(checks.binding.ok, 'Actie-bindings')}
 ${statusBadge(checks.navigation.ok, 'Navigatie-secties')}
${statusBadge(checks.coverage.ok, 'Medische brondekking')}
${statusBadge(checks.variation.ok, 'Quizvariatie')}
${statusBadge(checks.monitor.ok, 'Monitorinstellingen')}
${statusBadge(checks.visual.ok, 'Monitor visual QA')}
</ul>
</div>
</div>
 ${checks.binding.ok ? '' : `
 <div class="info-box danger" style="margin-top:0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Bindings issues</h4>
 <ul class="styled-list">${result.bindingIssues.map(i => `<li>${i}</li>`).join('')}</ul>
 </div>
 </div>
 `}
 ${checks.navigation.ok ? '' : `
 <div class="info-box warning" style="margin-top:0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Navigatie issues</h4>
 <ul class="styled-list">${result.sectionIssues.map(i => `<li>${i}</li>`).join('')}</ul>
 </div>
 </div>
 `}
 ${checks.coverage.ok ? '' : `
 <div class="info-box warning" style="margin-top:0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Brondekking issues</h4>
 <ul class="styled-list">
 <li>Ritmes zonder volledige dekking: ${checks.coverage.missingRhythm}</li>
 <li>Casevragen zonder volledige dekking: ${checks.coverage.missingQuestions}</li>
 <li>Ongeldige bron-URL's: ${checks.coverage.invalidUrls.length}</li>
 </ul>
 </div>
 </div>
 `}
 ${checks.monitor.ok ? '' : `
 <div class="info-box warning" style="margin-top:0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Monitor issues</h4>
 <ul class="styled-list">${checks.monitor.issues.map(i => `<li>${i}</li>`).join('')}</ul>
 </div>
 </div>
 `}
${checks.variation.ok ? '' : `
<div class="info-box info" style="margin-top:0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Quizvariatie advies</h4>
 <p>Unieke ritmes: ${checks.variation.uniqueRhythms}/${checks.variation.sampleAnswers} (gem. ${checks.variation.uniqueRatio}%).</p>
 <p>Min. unieke ratio per 20-vragenrun: ${checks.variation.minUniqueRatio || 0}% (doel: ${checks.variation.target || 75}%).</p>
 <p class="text-muted" style="margin-top:0.35rem;">Directe herhalingen: ${checks.variation.immediateRepeats}. Doe een nieuwe mixquiz of herstelronde om meer spreiding op te bouwen.</p>
</div>
</div>
`}
${checks.visual.ok ? '' : `
<div class="info-box warning" style="margin-top:0.75rem;">
<div class="info-box-icon">*</div>
<div class="info-box-content">
<h4>Monitor visual issues</h4>
<ul class="styled-list">${checks.visual.issues.map(i => `<li>${i}</li>`).join('')}</ul>
<p class="text-muted" style="margin-top:0.35rem;">Artifactcontrast: none->low ${checks.visual.artifact?.noneToLowPct ?? 0}% | low->medium ${checks.visual.artifact?.lowToMediumPct ?? 0}%.</p>
</div>
</div>
`}
`);
},

 // ========== QUIZ FUNCTIONS ==========
 startQuiz(mode = 'standard') {
 let difficulty = document.getElementById('quizDifficulty')?.value || 'all';
 let category = document.getElementById('quizCategory')?.value || 'all';
 let count = parseInt(document.getElementById('quizCount')?.value, 10) || AppState.settings?.defaultQuizCount || 10;

 if (mode === 'exam') {
 difficulty = 'all';
 category = 'all';
 count = 20;
 }
 if (mode === 'critical') {
 difficulty = 'all';
 category = 'all';
 const criticalCount = ECGDatabase.getCriticalRhythms().length;
 if (criticalCount === 0) {
 this.showModal('Geen kritieke ritmes', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Er zijn op dit moment geen high/critical ritmes beschikbaar in de dataset.</p>
 </div>
 </div>
 `);
 return;
 }
 count = Math.max(1, Math.min(10, criticalCount || 10));
 }

 if (['standard', 'timed', 'clinical'].includes(mode)) {
 let pool = ECGDatabase.getAllRhythms();
 if (category !== 'all') {
 pool = pool.filter(r => r.category === category);
 }
 if (difficulty !== 'all') {
 pool = pool.filter(r => r.difficulty === difficulty);
 }
 if (pool.length > 0 && count > pool.length) {
 count = pool.length;
 this.showModal('Aantal vragen aangepast', `
 <div class="info-box info">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Voor deze filters zijn <strong>${pool.length}</strong> unieke ritmes beschikbaar.</p>
 <p class="text-muted" style="margin-top:0.5rem;">De quiz is aangepast naar ${pool.length} vragen om herhaling te voorkomen.</p>
 </div>
 </div>
 `);
 }
 }
 
 QuizEngine.init({
 mode,
 difficulty,
 category,
 totalQuestions: count
 });
 
 // Re-render quiz section
 Sections.renderQuiz(Utils.$('#contentArea'));
 },

 startQuickQuiz() {
 try {
 QuizEngine.init({
 mode: 'standard',
 difficulty: 'all',
 category: 'all',
 totalQuestions: AppState.settings?.defaultQuizCount || 10
 });
 Navigation.navigateTo('quiz');
 if (AppState.currentSection === 'quiz') {
 Sections.renderQuiz(Utils.$('#contentArea'));
 }
 } catch (error) {
 console.error('Snelle quiz mislukt:', error);
 this.showModal('Snelle Quiz Mislukt', `
 <div class="info-box danger">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Kon snelle quiz niet starten.</p>
 <p class="text-muted" style="margin-top: 0.5rem;">${error.message}</p>
 </div>
 </div>
 `);
 }
 },

 startModulePractice(moduleId) {
 const status = LearningPathEngine.getModuleStatus(moduleId);
 if (!status) {
 this.showModal('Module niet gevonden', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Deze module kon niet worden geladen. Herlaad de pagina en probeer opnieuw.</p>
 </div>
 </div>
 `);
 return;
 }
 const moduleDefinitions = LearningPathEngine.moduleDefinitions || [];
 const moduleIndex = moduleDefinitions.findIndex(m => m.id === moduleId);
 const previousModule = moduleIndex > 0
 ? LearningPathEngine.getModuleStatus(moduleDefinitions[moduleIndex - 1].id)
 : null;
 if (!status.unlocked) {
 const req = status.requirementsMet || {};
 this.showLockReason({
 target: `${status.title} is nog vergrendeld`,
requirements: [
`Vorige module voltooid: ${previousModule ? `${previousModule.completed ? 'Ja' : 'Nee'} ${previousModule.title}` : 'n.v.t.'}`,
`Quizdoel gehaald: ${req.qMet ? 'Ja' : 'Nee'}`,
`Checklist/case-eisen gehaald: ${(req.sMet !== false && req.cMet !== false) ? 'Ja' : 'Nee'}`
]
});
 return;
 }

 const modulePool = LearningPathEngine.getModuleRhythms(moduleId);
 const desiredCount = AppState.settings?.defaultQuizCount || 10;
 const questionCount = modulePool.length > 0
 ? Math.min(desiredCount, modulePool.length)
 : desiredCount;

 QuizEngine.init({
 mode: 'standard',
 difficulty: 'all',
 category: 'all',
 moduleId,
 totalQuestions: questionCount
 });
 Navigation.navigateTo('quiz');
 },

 showPrerequisiteHelp(type = 'general') {
 if (type === 'recovery') {
 this.showLockReason({
 target: 'Herstelronde nog niet beschikbaar',
 requirements: [
 'Start eerst een standaard quiz of snelle quiz',
 'Maak minimaal 1 fout antwoord',
 'Open daarna opnieuw Herstelronde'
 ]
 });
 return;
 }
 this.showLockReason({
 target: 'Actie nog niet beschikbaar',
 requirements: ['Voltooi eerst de benodigde stappen in het leerpad']
 });
 },

 startCoachSession(mode = 'daily') {
 let queue = [];
 if (mode === 'recovery') {
 queue = LearningCoachEngine.buildRecoveryQueue(10);
 } else if (mode === 'sprint') {
 queue = LearningCoachEngine.buildDailyQueue(5);
 } else {
 queue = LearningCoachEngine.buildDailyQueue(10);
 mode = 'coach';
 }

 if (!queue.length) {
 if (mode === 'recovery') {
 this.showPrerequisiteHelp('recovery');
 return;
 }
 this.showModal('Leercoach', `
 <div class="info-box info">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Geen geschikte items beschikbaar. Doe eerst een paar quizvragen om adaptieve coaching op te bouwen.</p>
 </div>
 </div>
 `);
 return;
 }

 AppState.coach.active = true;
 AppState.coach.mode = mode;
 AppState.coach.queue = queue;
 AppState.coach.completed = [];

 QuizEngine.init({
 mode,
 difficulty: 'all',
 category: 'all',
 totalQuestions: queue.length,
 predefinedRhythms: queue
 });
 Navigation.navigateTo('quiz');
 },

 startCriticalQuiz() {
 const criticalRhythms = ECGDatabase.getCriticalRhythms();
 if (!criticalRhythms.length) {
 this.showModal('Geen kritieke ritmes gevonden', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Er zijn geen kritieke ritmes beschikbaar in de huidige dataset.</p>
 </div>
 </div>
 `);
 return;
 }

 const queue = Utils.shuffle(criticalRhythms.map(r => r.id));
 QuizEngine.init({
 mode: 'critical',
 difficulty: 'all',
 category: 'all',
 totalQuestions: Math.min(10, queue.length),
 predefinedRhythms: queue
 });
 Navigation.navigateTo('quiz');
 },

 openCategoryQuiz(category) {
 QuizEngine.init({
 mode: 'standard',
 difficulty: 'all',
 category,
 totalQuestions: 10
 });
 
 Navigation.navigateTo('quiz');
 },

getQuizLeadCanvasId(lead) {
const safeLead = String(lead || 'II').replace(/[^a-z0-9]/gi, '').toLowerCase();
return `quizLead_${safeLead}`;
},

getMonitorLeadCanvasId(lead) {
const safeLead = String(lead || 'II').replace(/[^a-z0-9]/gi, '').toLowerCase();
return `monitorLead_${safeLead}`;
},

getPaperTheme() {
return {
backgroundColor: '#fffafb',
gridColorMinor: '#f9d8de',
gridColor: '#ef9aaa',
waveColor: '#111827',
sweepColor: 'rgba(190, 24, 93, 0.35)',
overlayTextColor: '#9f1239'
};
},

getLibraryViewState() {
 const defaults = typeof StateFactory?.createLibraryView === 'function'
 ? StateFactory.createLibraryView()
 : {
 defaultLead: 'II',
 previewSeconds: 8,
 highContrast: true,
 compactCards: false,
 lazyRenderBatch: 12
 };
 AppState.libraryView = {
 ...defaults,
 ...(AppState.libraryView || {})
 };
 const allLeads = ECGRenderer.LEAD_ORDER || ['II'];
 if (!allLeads.includes(AppState.libraryView.defaultLead)) {
 AppState.libraryView.defaultLead = 'II';
 }
 const seconds = Number(AppState.libraryView.previewSeconds);
 AppState.libraryView.previewSeconds = Number.isFinite(seconds)
 ? Math.max(4, Math.min(12, Math.round(seconds)))
 : 8;
 const batch = Number(AppState.libraryView.lazyRenderBatch);
 AppState.libraryView.lazyRenderBatch = Number.isFinite(batch)
 ? Math.max(6, Math.min(24, Math.round(batch)))
 : 12;
 AppState.libraryView.highContrast = AppState.libraryView.highContrast !== false;
 AppState.libraryView.compactCards = AppState.libraryView.compactCards === true;
 return AppState.libraryView;
},

getLibraryPaperTheme() {
 const base = this.getPaperTheme();
 const view = this.getLibraryViewState();
 if (view.highContrast === false) return base;
 return {
 ...base,
 waveColor: '#0f172a',
 gridColor: '#e88ea0',
 gridColorMinor: '#f7dbe1',
 sweepColor: 'rgba(190, 24, 93, 0.18)'
 };
},

getLibraryRenderOptions(rhythm, overrides = {}) {
 const view = this.getLibraryViewState();
 const lead = (ECGRenderer.LEAD_ORDER || []).includes(view.defaultLead) ? view.defaultLead : 'II';
 const rate = rhythm?.characteristics?.rate?.typical || 72;
 return {
 heartRate: rate,
 speed: 25,
 amplitude: 1,
 verticalScale: 1.05,
 lineWidth: 2.1,
 shadowBlur: 2.2,
 signalNoise: 0,
 muscleNoise: 0,
 baselineWander: 0,
 powerlineNoise: 0,
 powerlineHz: 0,
 lead,
 showCalibrationPulse: false,
 theme: this.getLibraryPaperTheme(),
 ...overrides
 };
},

cleanupLibraryPreviewObserver() {
 if (this.libraryPreviewObserver) {
 this.libraryPreviewObserver.disconnect();
 this.libraryPreviewObserver = null;
 }
},

getTwelveLeadDisplayOrder() {
return ['I', 'aVR', 'V1', 'V4', 'II', 'aVL', 'V2', 'V5', 'III', 'aVF', 'V3', 'V6'];
},

updateQuizLeadSelectionStyles() {
const activeLead = AppState.quizView?.focusLead || 'II';
Utils.$$('.quiz-lead-card').forEach(card => {
card.classList.toggle('active', card.dataset.lead === activeLead);
 });

 const focusTitle = document.getElementById('quizFocusLeadTitle');
 if (focusTitle) focusTitle.textContent = `Ritmestrook (focus): Lead ${activeLead}`;
 const focusChip = document.getElementById('quizFocusLeadChip');
 if (focusChip) focusChip.textContent = `Lead ${activeLead}`;
},

 redrawQuizLeadViews() {
 const quiz = AppState.quiz;
 const rhythm = quiz.currentRhythm;
 if (!quiz.active || !rhythm) return;
 const focusCanvas = document.getElementById('quizECGFocus');
 if (!focusCanvas) return;

const adaptive = quiz.currentAdaptiveProfile || QuizEngine.getAdaptiveProfile(quiz);
const visualProfile = adaptive?.visual || {};
const rate = rhythm.characteristics?.rate?.typical || 72;
const leads = ECGRenderer.LEAD_ORDER || ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
const displayLeads = this.getTwelveLeadDisplayOrder().filter(lead => leads.includes(lead));
const commonOptions = {
heartRate: rate,
speed: visualProfile.speed || 25,
amplitude: visualProfile.amplitude || 1,
signalNoise: visualProfile.signalNoise || 0,
baselineWander: visualProfile.baselineWander || 0,
theme: this.getPaperTheme()
};

ECGRenderer.drawLeadStrip('quizECGFocus', rhythm.id, {
...commonOptions,
lead: AppState.quizView?.focusLead || 'II',
verticalScale: (visualProfile.verticalScale || 1) * (AppState.quizView?.zoom || 1),
lineWidth: Math.max(2.1, visualProfile.lineWidth || 2),
shadowBlur: Math.max(2.2, visualProfile.shadowBlur || 3),
showCalibrationPulse: false
});
ECGRenderer.drawTwelveLeadGrid('quizLead', rhythm.id, {
...commonOptions,
verticalScale: Math.max(0.75, (visualProfile.verticalScale || 1) * 0.82),
lineWidth: Math.max(1.35, (visualProfile.lineWidth || 2) - 0.65),
shadowBlur: Math.max(1.5, (visualProfile.shadowBlur || 3) - 1.2),
leads: displayLeads,
showCalibrationPulse: false,
canvasIdBuilder: (lead) => this.getQuizLeadCanvasId(lead)
});
 this.updateQuizLeadSelectionStyles();
 },

 setQuizFocusLead(lead = 'II') {
 const allowed = ECGRenderer.LEAD_ORDER || [];
 if (!allowed.includes(lead)) return;
AppState.quizView.focusLead = lead;
this.redrawQuizLeadViews();
Storage.scheduleSave(900);
},

 toggleQuizCalibrationDetails() {
 AppState.quizView.showDetailedCalibration = !(AppState.quizView.showDetailedCalibration === true);
if (AppState.currentSection === 'quiz' && AppState.quiz.active) {
Sections.renderActiveQuiz(Utils.$('#contentArea'));
}
Storage.scheduleSave(900);
},

 selectAnswer(rhythmId) {
 const quiz = AppState.quiz;
 if (quiz.showingFeedback) return;
 
 // Visual selection
 Utils.$$('.quiz-option').forEach(opt => {
 opt.classList.remove('selected');
 if (opt.dataset.answer === rhythmId) {
 opt.classList.add('selected');
 }
 });
 
 // Check answer
 const result = QuizEngine.checkAnswer(rhythmId);
 if (!result) return;
 
 // Show feedback
 this.showAnswerFeedback(result);
 },

 showAnswerFeedback(result) {
 const { isCorrect, correctRhythm, xpEarned } = result;
 const quiz = AppState.quiz;
 const payload = quiz.currentQuestionPayload || {};
 const correctAnswerId = payload.correctId || correctRhythm.id;
 const selectedRhythm = ECGDatabase.getRhythmById(quiz.selectedAnswer);
 const selectedOption = (payload.options || []).find(o => o.id === quiz.selectedAnswer);
 const whyCorrect = correctRhythm.whyCorrect || MedicalContentAudit.buildWhyCorrect(correctRhythm);
 const source = MedicalContentAudit.getSource(correctRhythm.sourceId);
 const guidelineRef = MedicalContentAudit.getGuidelineReferenceForRhythm(correctRhythm);
 const examinerEnabled = AppState.settings?.examinerMode !== false;
 
 // Update option styling
 Utils.$$('.quiz-option').forEach(opt => {
 opt.classList.add('disabled');
 
 if (opt.dataset.answer === correctAnswerId) {
 opt.classList.add('correct');
 } else if (opt.dataset.answer === quiz.selectedAnswer && !isCorrect) {
 opt.classList.add('incorrect');
 }
 });
 
 // Show feedback panel
 const feedbackPanel = document.getElementById('feedbackPanel');
 if (feedbackPanel) {
 feedbackPanel.className = `feedback-panel show ${isCorrect ? 'correct' : 'incorrect'}`;
 feedbackPanel.innerHTML = `
 <div class="feedback-header">
 <div class="feedback-icon">${isCorrect ? '&#10004;' : '&#10006;'}</div>
 <div>
 <div class="feedback-title">${isCorrect ? 'Correct!' : 'Helaas, niet juist'}</div>
 <div class="feedback-subtitle">
 ${isCorrect ? `+${xpEarned} XP verdiend` : `Het juiste antwoord was: ${correctRhythm.name}`}
 </div>
 </div>
 </div>
 <div style="margin-top: 1rem;">
 <h4 style="margin-bottom: 0.5rem;">${correctRhythm.name}</h4>
 <p class="text-muted" style="margin-bottom: 0.75rem;">${correctRhythm.description}</p>
 <div class="info-box info" style="margin: 0 0 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Waarom dit correct is</h4>
 <p>${whyCorrect}</p>
 </div>
 </div>
 <div class="info-box info" style="margin: 0;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Belangrijke kenmerken</h4>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 ${correctRhythm.ecgFeatures.slice(0, 3).map(f => `<li>${f}</li>`).join('')}
 </ul>
 </div>
 </div>
 <div class="info-box success" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Bron (richtlijn/paper)</h4>
 <p>
 <a href="${source.url}" target="_blank" rel="noopener noreferrer">${source.title}</a>
 </p>
 <p class="text-muted" style="margin-top: 0.35rem;">${correctRhythm.sourceNote || 'ERC/ESC default; volg lokaal protocol.'}</p>
 </div>
 </div>
 ${!isCorrect ? `
 <div class="info-box warning" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Context Card: verschil met je keuze</h4>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 <li><strong>Jouw keuze:</strong> ${selectedRhythm?.name || selectedOption?.label || 'Onbekend'}</li>
 <li><strong>Correct:</strong> ${correctRhythm.name}</li>
 <li><strong>Belangrijk verschil:</strong> ${(correctRhythm.ecgFeatures?.[0] || 'Let op ritme, QRS-breedte en P-golven')}</li>
 ${correctRhythm.urgency === 'critical' || correctRhythm.urgency === 'high'
 ? '<li><strong>Rode vlag:</strong> potentieel urgent/levensbedreigend patroon.</li>'
 : ''}
 </ul>
 </div>
 </div>
 ` : ''}
 ${!isCorrect && examinerEnabled ? `
 <div class="info-box danger" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Examiner Mode - relevante guideline-paragraaf</h4>
 <p>${guidelineRef || source.keySection || 'Zie primaire richtlijnbron voor de onderliggende paragraaf.'}</p>
 </div>
 </div>
 ` : ''}
 <div class="info-box ${isCorrect ? 'success' : 'warning'}" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Zelfvertrouwen (verplicht)</h4>
 <p class="text-muted" style="margin: 0.35rem 0 0.75rem;">Hoe zeker was je van je keuze?</p>
 <div class="btn-group">
<button class="btn btn-sm btn-outline" onclick="ECGApp.captureConfidence('sure')">Zeker</button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.captureConfidence('doubt')"> Twijfel</button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.captureConfidence('guess')"> Gok</button>
 </div>
 </div>
 </div>
 </div>
 `;
 }
 
 // Show next button
 const nextBtn = document.getElementById('nextBtn');
 if (nextBtn) {
 nextBtn.classList.remove('hidden');
 nextBtn.disabled = true;
 nextBtn.textContent = 'Kies zelfvertrouwen';
 
 // Update button text for last question
 if (quiz.currentQuestion >= quiz.totalQuestions - 1 || 
 (quiz.mode === 'survival' && !isCorrect)) {
 nextBtn.dataset.finalLabel = 'Bekijk Resultaten';
 } else {
nextBtn.dataset.finalLabel = 'Volgende >';
 }
 }
 
 // Update sidebar stats
 this.updateSidebarStats();
 },

 captureConfidence(level) {
 const quiz = AppState.quiz;
 if (!quiz.active || quiz.pendingAnswerIndex === null) return;
 const answer = quiz.answers[quiz.pendingAnswerIndex];
 if (!answer || answer.confidence) return;

answer.confidence = level;
quiz.pendingConfidence = level;
LearningCoachEngine.registerAnswerReview(answer);
LearningCoachEngine.syncAnalytics();
Storage.scheduleSave(900);

 const nextBtn = document.getElementById('nextBtn');
 if (nextBtn) {
 nextBtn.disabled = false;
nextBtn.textContent = nextBtn.dataset.finalLabel || 'Volgende >';
 }
 },

 showTimeoutFeedback() {
 const quiz = AppState.quiz;
 const correctRhythm = quiz.currentRhythm;
 const whyCorrect = correctRhythm.whyCorrect || MedicalContentAudit.buildWhyCorrect(correctRhythm);
 const source = MedicalContentAudit.getSource(correctRhythm.sourceId);
 const guidelineRef = MedicalContentAudit.getGuidelineReferenceForRhythm(correctRhythm);
 const examinerEnabled = AppState.settings?.examinerMode !== false;
 
 // Update option styling
 Utils.$$('.quiz-option').forEach(opt => {
 opt.classList.add('disabled');
 if (opt.dataset.answer === (quiz.currentQuestionPayload?.correctId || correctRhythm.id)) {
 opt.classList.add('correct');
 }
 });
 
 // Show feedback panel
 const feedbackPanel = document.getElementById('feedbackPanel');
 if (feedbackPanel) {
 feedbackPanel.className = 'feedback-panel show incorrect';
 feedbackPanel.innerHTML = `
 <div class="feedback-header">
 <div class="feedback-icon">*</div>
 <div>
 <div class="feedback-title">Tijd is op!</div>
 <div class="feedback-subtitle">Het juiste antwoord was: ${correctRhythm.name}</div>
 </div>
 </div>
 <div class="info-box info" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Waarom dit correct is</h4>
 <p>${whyCorrect}</p>
 </div>
 </div>
 <div class="info-box success" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Bron (richtlijn/paper)</h4>
 <p><a href="${source.url}" target="_blank" rel="noopener noreferrer">${source.title}</a></p>
 </div>
 </div>
 ${examinerEnabled ? `
 <div class="info-box danger" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Examiner Mode - relevante guideline-paragraaf</h4>
 <p>${guidelineRef || source.keySection || 'Zie primaire richtlijnbron voor de onderliggende paragraaf.'}</p>
 </div>
 </div>
 ` : ''}
 <div class="info-box warning" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Zelfvertrouwen (verplicht)</h4>
 <p class="text-muted" style="margin: 0.35rem 0 0.75rem;">Hoe zeker was je van je keuze voordat de tijd op was?</p>
 <div class="btn-group">
<button class="btn btn-sm btn-outline" onclick="ECGApp.captureConfidence('sure')">Zeker</button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.captureConfidence('doubt')"> Twijfel</button>
 <button class="btn btn-sm btn-outline" onclick="ECGApp.captureConfidence('guess')"> Gok</button>
 </div>
 </div>
 </div>
 `;
 }
 
 // Show next button
 const nextBtn = document.getElementById('nextBtn');
 if (nextBtn) {
 nextBtn.classList.remove('hidden');
 nextBtn.disabled = true;
 if (quiz.currentQuestion >= quiz.totalQuestions - 1) {
 nextBtn.dataset.finalLabel = 'Bekijk Resultaten';
 } else {
nextBtn.dataset.finalLabel = 'Volgende >';
 }
 nextBtn.textContent = 'Kies zelfvertrouwen';
 }
 },

 showHint() {
 if (AppState.quiz.mode === 'exam') {
 this.showModal('Examenmodus', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Hints staan uit in Examenmodus.</p>
 </div>
 </div>
 `);
 return;
 }
 const hint = QuizEngine.getHint();
 if (!hint) return;
 
 this.showModal('Hint', `
 <div class="info-box info">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p style="font-size: 1.1rem;">${hint}</p>
 </div>
 </div>
 `);
 },

 nextQuestion() {
 const hasMore = QuizEngine.nextQuestion();
 
 if (hasMore) {
 // Re-render quiz
 Sections.renderActiveQuiz(Utils.$('#contentArea'));
 }
 // If no more questions, QuizEngine.endQuiz() was called which triggers showQuizResults
 },

 startQuizTimer() {
 const quiz = AppState.quiz;
 
 if (quiz.timerInterval) {
 clearInterval(quiz.timerInterval);
 }
 
 quiz.timerInterval = setInterval(() => {
 QuizEngine.tick();
 }, 1000);
 },

 showQuizResults(results) {
 const { total, correct, accuracy, xpEarned, answers } = results;
 const isExam = AppState.quiz.mode === 'exam';
 
 let grade = '';
 let gradeText = 'Goed geprobeerd!';
 if (accuracy >= 90) {
 grade = '';
 gradeText = 'Uitstekend!';
 } else if (accuracy >= 80) {
 grade = '';
 gradeText = 'Zeer goed!';
 } else if (accuracy >= 70) {
 grade = '';
 gradeText = 'Goed gedaan!';
 }
 
 const content = Utils.$('#contentArea');
 const domainLabel = {
 basis_sinus_brady: 'Basis/Sinus/Brady',
 atriaal_tachy: 'Atriaal/Tachy',
 geleiding: 'Geleiding',
 ventriculair_arrest: 'Ventriculair/Arrest',
 ischemie_equivalenten: 'Ischemie/Equivalenten',
 elektrolyten_tox: 'Elektrolyten/Toxiciteit',
 overig: 'Overig'
 };
 const examDomainStats = isExam
 ? Object.entries(
 answers.reduce((acc, ans) => {
 const rhythm = ECGDatabase.getRhythmById(ans.rhythmId);
 const key = QuizEngine.getExamDomainForRhythm(rhythm);
 if (!acc[key]) acc[key] = { total: 0, correct: 0 };
 acc[key].total++;
 if (ans.correct) acc[key].correct++;
 return acc;
 }, {})
 ).map(([cat, stat]) => ({
 cat,
 total: stat.total,
 correct: stat.correct,
 accuracy: stat.total > 0 ? Math.round((stat.correct / stat.total) * 100) : 0
 }))
 : [];
 if (isExam) {
 LearningCoachEngine.applyExamDomainRecommendations(examDomainStats);
 AppState.learningPath.weeklyFocus = LearningCoachEngine.getWeeklyFocus();
 }
 const examAdvice = isExam
 ? examDomainStats
 .filter(d => d.total > 0)
 .sort((a, b) => a.accuracy - b.accuracy)
 .slice(0, 3)
 : [];

 content.innerHTML = `
 <div class="card">
 <div class="card-body">
 <div class="score-display">
 <div class="score-circle" style="--score: ${accuracy}">
 <div class="score-inner">
 <div class="score-value">${accuracy}%</div>
 <div class="score-label">Nauwkeurigheid</div>
 </div>
 </div>
 <h2 style="font-size: 1.75rem; margin-bottom: 0.5rem;">${grade} ${gradeText}</h2>
 <p class="text-muted" style="margin-bottom: 1.5rem;"> Je hebt ${correct} van de ${total} vragen goed beantwoord
 </p>
 ${isExam ? '<p class="text-warning" style="margin-bottom: 1rem;">Examenmodus afgerond: hints uit, domeinrapport hieronder.</p>' : ''}
 
 <div class="vitals-grid" style="max-width: 400px; margin: 0 auto 2rem;">
 <div class="vital-card">
 <div class="vital-card-label">Score</div>
 <div class="vital-card-value text-success">${correct}/${total}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">XP Verdiend</div>
 <div class="vital-card-value text-primary">+${xpEarned}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Reeks</div>
 <div class="vital-card-value text-warning">${AppState.user.streak}</div>
 </div>
 </div>
 
 <div class="btn-group" style="justify-content: center;">
 <button class="btn btn-primary btn-lg" onclick="ECGApp.startQuickQuiz()"> Nieuwe Quiz
 </button>
 <button class="btn btn-outline btn-lg" onclick="Navigation.navigateTo('dashboard')"> Dashboard
 </button>
 </div>
 </div>
 </div>
 </div>
 ${isExam ? `
 <div class="card mt-2">
 <div class="card-header">
 <h3 class="card-title"> Domeinrapport</h3>
 </div>
 <div class="card-body">
 <table class="data-table">
 <thead><tr><th>Domein</th><th>Score</th><th>Nauwkeurigheid</th></tr></thead>
 <tbody>
 ${examDomainStats.map(d => `
 <tr>
 <td>${domainLabel[d.cat] || d.cat}</td>
 <td>${d.correct}/${d.total}</td>
 <td>${d.accuracy}%</td>
 </tr>
 `).join('')}
 </tbody>
 </table>
 ${examAdvice.length ? `
 <div class="info-box warning" style="margin-top: 1rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Herkansingsadvies</h4>
 <ul class="styled-list">
${examAdvice.map(a => `<li>${domainLabel[a.cat] || a.cat}: ${a.accuracy}% - herhaal via Leercoach.</li>`).join('')}
 </ul>
 </div>
 </div>
 ` : ''}
 </div>
 </div>
 ` : ''}
 
 <!-- Answer Review -->
 <div class="card mt-2">
 <div class="card-header">
 <h3 class="card-title"> Antwoorden Overzicht</h3>
 </div>
 <div class="card-body">
 <table class="data-table">
 <thead>
 <tr>
 <th>#</th>
 <th>Ritme</th>
 <th>Jouw Antwoord</th>
 <th>Resultaat</th>
 <th>XP</th>
 </tr>
 </thead>
 <tbody>
 ${answers.map((answer, index) => {
 const selectedRhythm = ECGDatabase.getRhythmById(answer.selectedId);
 const selectedActionRhythmId = typeof answer.selectedId === 'string' && answer.selectedId.startsWith('action_')
 ? answer.selectedId.replace('action_', '')
 : null;
 const selectedActionRhythm = selectedActionRhythmId ? ECGDatabase.getRhythmById(selectedActionRhythmId) : null;
 const selectedLabel = answer.selectedId === 'timeout'
 ? 'Tijd op'
 : selectedRhythm
 ? selectedRhythm.name
 : selectedActionRhythm?.firstAction || answer.selectedId || 'Onbekend';
 return `
 <tr>
 <td>${index + 1}</td>
 <td>
 <span style="cursor: pointer; text-decoration: underline;" 
 onclick="ECGApp.showRhythmDetail('${answer.rhythmId}')">
 ${answer.rhythmName}
 </span>
 </td>
 <td>${selectedLabel}</td>
 <td>
${answer.correct 
? '<span class="text-success">Correct</span>' 
: '<span class="text-danger">Fout</span>'}
 </td>
 <td class="text-primary">+${answer.xpEarned}</td>
 </tr>
 `;
 }).join('')}
 </tbody>
 </table>
 </div>
 </div>
 `;
 },

 // ========== MONITOR FUNCTIONS ==========
getMonitorRenderOptions() {
const level = AppState.monitor.artifactLevel || 'none';
return ECGRenderer.getArtifactProfile(
level,
Number(AppState.monitor.speed) || 25,
Number(AppState.monitor.amplitude) || 1,
Number(AppState.monitor.zoom) || 1
);
},

 getMonitorVisualProfile() {
 const zoom = Math.max(1, Math.min(2, Number(AppState.monitor.zoom) || 1));
 return {
 verticalScale: zoom,
 lineWidth: Math.min(4, 2 + (zoom - 1) * 1),
 shadowBlur: Math.min(7, 4 + (zoom - 1) * 2)
 };
 },

 ensureMonitorUiState() {
 const defaults = {
 advancedOpen: false,
 rhythmPanelOpen: true,
 rhythmSearch: '',
 rhythmCategory: 'all',
 showLeadPad: false
 };
 if (!AppState.monitor) {
 AppState.monitor = StateFactory.createMonitor();
 }
 AppState.monitor.ui = {
 ...defaults,
 ...(AppState.monitor.ui || {})
 };
 return AppState.monitor.ui;
 },

toggleMonitorAdvanced() {
 const ui = this.ensureMonitorUiState();
 ui.advancedOpen = !ui.advancedOpen;
 if (AppState.currentSection === 'monitor') {
 Sections.renderMonitor(Utils.$('#contentArea'));
 }
 Storage.scheduleSave(600);
},

toggleMonitorRhythmPanel() {
 const ui = this.ensureMonitorUiState();
 ui.rhythmPanelOpen = !ui.rhythmPanelOpen;
 if (AppState.currentSection === 'monitor') {
 Sections.renderMonitor(Utils.$('#contentArea'));
 }
 Storage.scheduleSave(600);
},

 setMonitorRhythmSearch(term = '') {
 const ui = this.ensureMonitorUiState();
 ui.rhythmSearch = String(term || '').slice(0, 120);
 if (AppState.currentSection === 'monitor') {
 Sections.renderMonitor(Utils.$('#contentArea'));
 }
 },

setMonitorRhythmCategory(category = 'all') {
 const valid = ['all', ...Object.keys(ECGDatabase.categories)];
 if (!valid.includes(category)) return;
 const ui = this.ensureMonitorUiState();
 ui.rhythmCategory = category;
 if (AppState.currentSection === 'monitor') {
 Sections.renderMonitor(Utils.$('#contentArea'));
 }
 Storage.scheduleSave(700);
},

toggleMonitorLeadPad() {
 const ui = this.ensureMonitorUiState();
 ui.showLeadPad = !ui.showLeadPad;
 if (AppState.currentSection === 'monitor') {
 Sections.renderMonitor(Utils.$('#contentArea'));
 }
 Storage.scheduleSave(700);
},

refreshMonitorStaticStrip() {
const renderOptions = this.getMonitorRenderOptions();
const visualProfile = this.getMonitorVisualProfile();
const theme = this.getPaperTheme();
ECGRenderer.drawStaticStrip('monitorCanvas', AppState.monitor.currentRhythm, {
heartRate: AppState.monitor.heartRate,
speed: AppState.monitor.speed || 25,
amplitude: AppState.monitor.amplitude || 1,
verticalScale: visualProfile.verticalScale,
 lineWidth: visualProfile.lineWidth,
 shadowBlur: visualProfile.shadowBlur,
lead: AppState.monitor.lead || 'II',
signalNoise: renderOptions.signalNoise,
muscleNoise: renderOptions.muscleNoise,
baselineWander: renderOptions.baselineWander,
powerlineNoise: renderOptions.powerlineNoise,
powerlineHz: renderOptions.powerlineHz,
showCalibrationPulse: false,
theme
});
this.redrawMonitorLeadOverview();
},

redrawMonitorLeadOverview() {
const allLeads = ECGRenderer.LEAD_ORDER || ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
const renderOptions = this.getMonitorRenderOptions();
ECGRenderer.drawTwelveLeadGrid('monitorLead', AppState.monitor.currentRhythm, {
heartRate: AppState.monitor.heartRate,
speed: AppState.monitor.speed || 25,
amplitude: AppState.monitor.amplitude || 1,
verticalScale: 0.94,
lineWidth: 1.15,
shadowBlur: 0,
signalNoise: renderOptions.signalNoise,
muscleNoise: renderOptions.muscleNoise,
baselineWander: renderOptions.baselineWander,
powerlineNoise: renderOptions.powerlineNoise,
powerlineHz: renderOptions.powerlineHz,
leads: allLeads,
canvasIdBuilder: (lead) => this.getMonitorLeadCanvasId(lead),
showCalibrationPulse: false,
theme: this.getPaperTheme()
});
},

toggleMonitor() {
const monitor = AppState.monitor;
const renderOptions = this.getMonitorRenderOptions();
const visualProfile = this.getMonitorVisualProfile();
const theme = this.getPaperTheme();
 
if (monitor.isRunning) {
ECGRenderer.stop('monitorCanvas');
monitor.isRunning = false;
 monitor.freezeFrame = false;
 } else {
 let config = ECGRenderer.activeCanvases.get('monitorCanvas');
 if (!config) {
 config = ECGRenderer.initCanvas('monitorCanvas', {
 rhythm: AppState.monitor.currentRhythm,
 heartRate: AppState.monitor.heartRate,
 speed: AppState.monitor.speed || 25,
 amplitude: AppState.monitor.amplitude || 1,
 verticalScale: visualProfile.verticalScale,
 lineWidth: visualProfile.lineWidth,
 shadowBlur: visualProfile.shadowBlur,
lead: AppState.monitor.lead || 'II',
signalNoise: renderOptions.signalNoise,
muscleNoise: renderOptions.muscleNoise,
baselineWander: renderOptions.baselineWander,
powerlineNoise: renderOptions.powerlineNoise,
powerlineHz: renderOptions.powerlineHz,
showCalibrationPulse: false,
theme
});
}
if (!config) return;
config.lead = AppState.monitor.lead || 'II';
config.signalNoise = renderOptions.signalNoise;
config.muscleNoise = renderOptions.muscleNoise;
config.baselineWander = renderOptions.baselineWander;
config.powerlineNoise = renderOptions.powerlineNoise;
config.powerlineHz = renderOptions.powerlineHz;
config.showCalibrationPulse = false;
config.theme = theme;
config.verticalScale = visualProfile.verticalScale;
config.lineWidth = visualProfile.lineWidth;
config.shadowBlur = visualProfile.shadowBlur;
ECGRenderer.start('monitorCanvas', { reset: false });
monitor.isRunning = true;
}
 
 // Update button
const btn = document.getElementById('monitorToggle');
if (btn) {
btn.className = `btn btn-sm ${monitor.isRunning ? 'btn-danger' : 'btn-success'}`;
btn.innerHTML = monitor.isRunning ? 'Pauze' : 'Start';
}
const freezeBtn = document.getElementById('monitorFreezeBtn');
if (freezeBtn) {
freezeBtn.textContent = AppState.monitor.freezeFrame ? 'Hervat' : 'Freeze';
}
Storage.scheduleSave(650);
},

toggleMonitorFreeze() {
AppState.monitor.freezeFrame = !AppState.monitor.freezeFrame;
const config = ECGRenderer.activeCanvases.get('monitorCanvas');
if (!config) {
if (AppState.currentSection === 'monitor') Sections.renderMonitor(Utils.$('#contentArea'));
Storage.scheduleSave(650);
return;
}

 if (AppState.monitor.freezeFrame) {
 ECGRenderer.stop('monitorCanvas');
 } else if (AppState.monitor.isRunning) {
 ECGRenderer.start('monitorCanvas', { reset: false });
 }
const freezeBtn = document.getElementById('monitorFreezeBtn');
if (freezeBtn) {
freezeBtn.textContent = AppState.monitor.freezeFrame ? 'Hervat' : 'Freeze';
}
Storage.scheduleSave(700);
},

 setMonitorLead(lead = 'II') {
 const allowed = ECGRenderer.LEAD_ORDER || [];
 if (!allowed.includes(lead)) return;
 AppState.monitor.lead = lead;

 const config = ECGRenderer.activeCanvases.get('monitorCanvas');
 if (config) {
 config.lead = lead;
 ECGRenderer.resetSweep('monitorCanvas');
 }
if (!AppState.monitor.isRunning || AppState.monitor.freezeFrame) {
this.refreshMonitorStaticStrip();
}
if (AppState.currentSection === 'monitor') {
Sections.renderMonitor(Utils.$('#contentArea'));
}
Storage.scheduleSave(700);
},

 setMonitorArtifact(level = 'none') {
 const allowed = ['none', 'low', 'medium'];
 if (!allowed.includes(level)) return;
 AppState.monitor.artifactLevel = level;
 const renderOptions = this.getMonitorRenderOptions();

 const config = ECGRenderer.activeCanvases.get('monitorCanvas');
if (config) {
config.signalNoise = renderOptions.signalNoise;
config.muscleNoise = renderOptions.muscleNoise;
config.baselineWander = renderOptions.baselineWander;
config.powerlineNoise = renderOptions.powerlineNoise;
config.powerlineHz = renderOptions.powerlineHz;
ECGRenderer.resetSweep('monitorCanvas');
}
if (!AppState.monitor.isRunning || AppState.monitor.freezeFrame) {
this.refreshMonitorStaticStrip();
}
if (AppState.currentSection === 'monitor') {
Sections.renderMonitor(Utils.$('#contentArea'));
}
Storage.scheduleSave(700);
},

 setMonitorSpeed(speed = 25) {
 const allowed = [12.5, 25, 50];
 const parsed = Number(speed);
 if (!allowed.includes(parsed)) return;
 AppState.monitor.speed = parsed;

 const config = ECGRenderer.activeCanvases.get('monitorCanvas');
 if (config) {
 config.speed = parsed;
 ECGRenderer.resetSweep('monitorCanvas');
 }
if (!AppState.monitor.isRunning || AppState.monitor.freezeFrame) {
this.refreshMonitorStaticStrip();
}
if (AppState.currentSection === 'monitor') {
Sections.renderMonitor(Utils.$('#contentArea'));
}
Storage.scheduleSave(700);
},

 setMonitorGain(gain = 1) {
 const allowed = [0.5, 1, 2];
 const parsed = Number(gain);
 if (!allowed.includes(parsed)) return;
 AppState.monitor.amplitude = parsed;

 const config = ECGRenderer.activeCanvases.get('monitorCanvas');
 if (config) {
 config.amplitude = parsed;
 ECGRenderer.resetSweep('monitorCanvas');
 }
if (!AppState.monitor.isRunning || AppState.monitor.freezeFrame) {
this.refreshMonitorStaticStrip();
}
if (AppState.currentSection === 'monitor') {
Sections.renderMonitor(Utils.$('#contentArea'));
}
Storage.scheduleSave(700);
},

 setMonitorZoom(zoom = 1) {
 const allowed = [1, 1.5, 2];
 const parsed = Number(zoom);
 if (!allowed.includes(parsed)) return;
 AppState.monitor.zoom = parsed;

 const visualProfile = this.getMonitorVisualProfile();
 const config = ECGRenderer.activeCanvases.get('monitorCanvas');
 if (config) {
 config.verticalScale = visualProfile.verticalScale;
 config.lineWidth = visualProfile.lineWidth;
 config.shadowBlur = visualProfile.shadowBlur;
 ECGRenderer.resetSweep('monitorCanvas');
 }
if (!AppState.monitor.isRunning || AppState.monitor.freezeFrame) {
this.refreshMonitorStaticStrip();
}
if (AppState.currentSection === 'monitor') {
Sections.renderMonitor(Utils.$('#contentArea'));
}
Storage.scheduleSave(700);
},

 setMonitorRhythm(rhythmId) {
 const rhythm = ECGDatabase.getRhythmById(rhythmId);
 if (!rhythm) return;
 
 AppState.monitor.currentRhythm = rhythmId;
 
 // Update heart rate to typical for this rhythm
 if (rhythm.characteristics?.rate?.typical) {
 AppState.monitor.heartRate = rhythm.characteristics.rate.typical;
 const hrValue = document.getElementById('hrValue');
 if (hrValue) hrValue.textContent = AppState.monitor.heartRate;
 
 const hrInput = document.getElementById('monitorHrInput');
 if (hrInput) hrInput.value = AppState.monitor.heartRate;
 }
 
// Update renderer
const renderOptions = this.getMonitorRenderOptions();
const visualProfile = this.getMonitorVisualProfile();
const theme = this.getPaperTheme();
let config = ECGRenderer.activeCanvases.get('monitorCanvas');
if (!config) {
 config = ECGRenderer.initCanvas('monitorCanvas', {
rhythm: rhythmId,
heartRate: AppState.monitor.heartRate,
 speed: AppState.monitor.speed || 25,
 amplitude: AppState.monitor.amplitude || 1,
 verticalScale: visualProfile.verticalScale,
 lineWidth: visualProfile.lineWidth,
 shadowBlur: visualProfile.shadowBlur,
lead: AppState.monitor.lead || 'II',
signalNoise: renderOptions.signalNoise,
muscleNoise: renderOptions.muscleNoise,
baselineWander: renderOptions.baselineWander,
powerlineNoise: renderOptions.powerlineNoise,
powerlineHz: renderOptions.powerlineHz,
showCalibrationPulse: false,
theme
});
}
if (config) {
 config.speed = AppState.monitor.speed || config.speed || 25;
 config.amplitude = AppState.monitor.amplitude || config.amplitude || 1;
config.lead = AppState.monitor.lead || 'II';
config.signalNoise = renderOptions.signalNoise;
config.muscleNoise = renderOptions.muscleNoise;
config.baselineWander = renderOptions.baselineWander;
config.powerlineNoise = renderOptions.powerlineNoise;
config.powerlineHz = renderOptions.powerlineHz;
config.showCalibrationPulse = false;
config.theme = theme;
config.verticalScale = visualProfile.verticalScale;
config.lineWidth = visualProfile.lineWidth;
config.shadowBlur = visualProfile.shadowBlur;
ECGRenderer.setRhythm('monitorCanvas', rhythmId, AppState.monitor.heartRate);
 }
 
// Update display HR
const monitorHR = document.getElementById('monitorHR');
if (monitorHR) {
monitorHR.textContent = AppState.monitor.heartRate;
}
 
 // Update active button
 Utils.$$('.rhythm-btn').forEach(btn => {
 btn.classList.toggle('active', btn.dataset.rhythmId === rhythmId);
 });

 // Update rhythm info card in-place to avoid re-render race conditions.
 this.updateMonitorInfoPanel(rhythm);

 // Show the selected morphology immediately when paused.
if (!AppState.monitor.isRunning || AppState.monitor.freezeFrame) {
this.refreshMonitorStaticStrip();
}
this.redrawMonitorLeadOverview();
Storage.scheduleSave(800);
},

 updateMonitorInfoPanel(rhythm) {
 const titleEl = document.getElementById('monitorRhythmTitle');
 const diffEl = document.getElementById('monitorRhythmDifficulty');
 const descEl = document.getElementById('monitorRhythmDescription');
 const featuresEl = document.getElementById('monitorRhythmFeatures');

 if (titleEl) {
 titleEl.innerHTML = `${Utils.getCategoryIcon(rhythm?.category)} ${rhythm?.name || 'Selecteer een ritme'}`;
 }
 if (diffEl) {
 diffEl.className = `badge ${Utils.getDifficultyBadge(rhythm?.difficulty)}`;
 diffEl.textContent = rhythm?.difficulty || '';
 }
 if (descEl) {
 descEl.textContent = rhythm?.description || '';
 }
 if (featuresEl) {
 const features = Array.isArray(rhythm?.ecgFeatures) ? rhythm.ecgFeatures.slice(0, 4) : [];
 featuresEl.innerHTML = features.length ? `
 <div class="info-box info">
 <div class="info-box-icon">i</div>
 <div class="info-box-content">
 <h4>ECG Kenmerken</h4>
 <ul class="styled-list">
 ${features.map(f => `<li>${f}</li>`).join('')}
 </ul>
 </div>
 </div>
 ` : '';
 }
 },

setMonitorHR(value, commit = false) {
const parsed = parseInt(value, 10);
if (!Number.isFinite(parsed)) return;
AppState.monitor.heartRate = Math.min(200, Math.max(30, parsed));

const hrValue = document.getElementById('hrValue');
if (hrValue) hrValue.textContent = AppState.monitor.heartRate;

const monitorHR = document.getElementById('monitorHR');
if (monitorHR) monitorHR.textContent = AppState.monitor.heartRate;

// Update renderer
const config = ECGRenderer.activeCanvases.get('monitorCanvas');
if (config) {
config.heartRate = AppState.monitor.heartRate;
if (!AppState.monitor.isRunning || AppState.monitor.freezeFrame) {
this.refreshMonitorStaticStrip();
}
} else if (AppState.currentSection === 'monitor') {
this.refreshMonitorStaticStrip();
}
this.redrawMonitorLeadOverview();
if (commit) {
Storage.flushSave('manual');
} else {
Storage.scheduleSave(1400);
}
},

 // ========== LIBRARY FUNCTIONS ==========
 searchLibrary(query) {
 AppState.library.searchQuery = query;
 Sections.renderLibrary(Utils.$('#contentArea'));
 },

 filterLibrary(category) {
 AppState.library.selectedCategory = category;
 AppState.library.searchQuery = ''; // Clear search
 Sections.renderLibrary(Utils.$('#contentArea'));
 },

 showRhythmDetail(rhythmId) {
 const rhythm = ECGDatabase.getRhythmById(rhythmId);
 if (!rhythm) return;
 
 const urgencyInfo = Utils.getUrgencyLabel(rhythm.urgency);
 const category = ECGDatabase.categories[rhythm.category];
 const source = MedicalContentAudit.getSource(rhythm.sourceId);
 const looksLikeText = (Array.isArray(rhythm.looksLike) && rhythm.looksLike.length)
 ? rhythm.looksLike.slice(0, 3).join(', ')
 : (Array.isArray(rhythm.differentialIds) && rhythm.differentialIds.length
 ? rhythm.differentialIds.map(id => ECGDatabase.getRhythmById(id)?.name).filter(Boolean).slice(0, 3).join(', ')
 : 'Geen directe lookalike opgegeven.');
 const distinguishers = (Array.isArray(rhythm.keyDistinguishers) && rhythm.keyDistinguishers.length)
 ? rhythm.keyDistinguishers.slice(0, 4)
 : (Array.isArray(rhythm.ecgFeatures) ? rhythm.ecgFeatures.slice(0, 3) : []);
 const firstSafeStep = rhythm.firstSafeStep || rhythm.firstAction || 'Beoordeel eerst hemodynamiek en volg lokaal protocol.';
 
 const content = `
 <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
 <span class="badge ${Utils.getDifficultyBadge(rhythm.difficulty)}">${rhythm.difficulty}</span>
 <span class="badge badge-info">${category?.icon} ${category?.name}</span>
 ${rhythm.urgency !== 'none' ? `<span class="badge ${rhythm.urgency === 'critical' ? 'badge-critical' : 'badge-hard'}">${urgencyInfo.text}</span>` : ''}
 </div>
 
 <p style="margin-bottom: 1.5rem; font-size: 1.05rem;">${rhythm.description}</p>
 <div class="info-box success mb-3">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Bron (richtlijn/paper)</h4>
 <p><a href="${source.url}" target="_blank" rel="noopener noreferrer">${source.title}</a></p>
 <p class="text-muted" style="margin-top:0.35rem;">${rhythm.sourceNote || 'ERC/ESC default; volg lokaal protocol.'}</p>
 </div>
 </div>
 
 <!-- ECG Strip -->
 <div class="ecg-monitor mb-3">
 <div class="ecg-monitor-header">
 <div class="ecg-monitor-title">ECG Voorbeeld (Lead ${ECGApp.getLibraryViewState().defaultLead || 'II'})</div>
 <div class="vital-display">
 <div class="vital-label">HR</div>
 <div class="vital-value green">${rhythm.characteristics?.rate?.typical || '--'}</div>
 </div>
 </div>
 <div class="ecg-canvas-wrapper">
 <canvas id="detailECG" class="ecg-canvas" style="height: 150px;"></canvas>
 </div>
 </div>
 
 <!-- Characteristics -->
 ${rhythm.characteristics ? `
 <h4 style="margin-bottom: 0.75rem;"> Karakteristieken</h4>
 <table class="data-table mb-3">
 <tbody>
 ${rhythm.characteristics.rate ? `
 <tr>
 <td><strong>Frequentie</strong></td>
 <td>${rhythm.characteristics.rate.min}-${rhythm.characteristics.rate.max} bpm (typisch: ${rhythm.characteristics.rate.typical})</td>
 </tr>
 ` : ''}
 ${rhythm.characteristics.rhythm ? `
 <tr><td><strong>Ritme</strong></td><td>${rhythm.characteristics.rhythm}</td></tr>
 ` : ''}
 ${rhythm.characteristics.pWave ? `
 <tr><td><strong>P-golf</strong></td><td>${rhythm.characteristics.pWave}</td></tr>
 ` : ''}
 ${rhythm.characteristics.prInterval ? `
 <tr>
 <td><strong>PR-interval</strong></td>
 <td>${typeof rhythm.characteristics.prInterval === 'object' 
 ? `${rhythm.characteristics.prInterval.min}-${rhythm.characteristics.prInterval.max} ms` 
 : rhythm.characteristics.prInterval}</td>
 </tr>
 ` : ''}
 ${rhythm.characteristics.qrsComplex ? `
 <tr>
 <td><strong>QRS-complex</strong></td>
 <td>${typeof rhythm.characteristics.qrsComplex === 'object'
 ? `${rhythm.characteristics.qrsComplex.min || ''}-${rhythm.characteristics.qrsComplex.max || ''} ${rhythm.characteristics.qrsComplex.unit || 'ms'}`
 : rhythm.characteristics.qrsComplex}</td>
 </tr>
 ` : ''}
 </tbody>
 </table>
 ` : ''}
 
 <!-- ECG Features -->
 <h4 style="margin-bottom: 0.75rem;"> ECG Kenmerken</h4>
 <div class="info-box info mb-3">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <ul class="styled-list">
 ${rhythm.ecgFeatures.map(f => `<li>${f}</li>`).join('')}
 </ul>
 </div>
 </div>

 <h4 style="margin-bottom: 0.75rem;">Differentiatie</h4>
 <div class="algorithm-box info mb-3">
 <p><strong>Kernpatroon:</strong> ${rhythm.signaturePattern || rhythm.whyCorrect}</p>
 <p style="margin-top:0.35rem;"><strong>Lijkt op:</strong> ${looksLikeText}</p>
 <p style="margin-top:0.45rem;"><strong>Zo onderscheid je het:</strong></p>
 <ul class="styled-list" style="margin-top:0.35rem;">
 ${distinguishers.map(item => `<li>${item}</li>`).join('')}
 </ul>
 <p style="margin-top:0.45rem;"><strong>Eerste veilige stap:</strong> ${firstSafeStep}</p>
 </div>
 
 <!-- Clinical Significance -->
 ${rhythm.clinicalSignificance ? `
 <h4 style="margin-bottom: 0.75rem;"> Klinische Betekenis</h4>
 <p style="margin-bottom: 1rem;">${rhythm.clinicalSignificance}</p>
 ` : ''}
 
 <!-- Causes -->
 ${rhythm.commonCauses ? `
 <h4 style="margin-bottom: 0.75rem;"> Oorzaken</h4>
 <ul class="styled-list mb-3">
 ${rhythm.commonCauses.map(c => `<li>${c}</li>`).join('')}
 </ul>
 ` : ''}
 
 <!-- Treatment -->
 ${rhythm.treatment ? `
 <h4 style="margin-bottom: 0.75rem;"> Behandeling</h4>
 <div class="algorithm-box ${rhythm.urgency === 'critical' ? 'critical' : rhythm.urgency === 'high' ? 'warning' : 'success'}">
 <p>${rhythm.treatment}</p>
 ${rhythm.medications ? `
 <div style="margin-top: 0.75rem;">
 ${Object.entries(rhythm.medications).map(([key, meds]) => `
 <p><strong>${key}:</strong> ${Array.isArray(meds) ? meds.join(', ') : meds}</p>
 `).join('')}
 </div>
 ` : ''}
 </div>
 ` : ''}
 
 <!-- Clinical Pearl -->
 ${rhythm.clinicalPearl ? `
 <div class="info-box warning mt-3">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Klinische Parel</h4>
 <p>${rhythm.clinicalPearl}</p>
 </div>
 </div>
 ` : ''}
 
 <!-- Quiz Hints -->
 ${rhythm.quizHints ? `
 <h4 style="margin: 1.5rem 0 0.75rem;"> Herkenningspunten</h4>
 <ul class="styled-list">
 ${rhythm.quizHints.map(h => `<li>${h}</li>`).join('')}
 </ul>
 ` : ''}
 `;
 
 this.showModal(`${Utils.getCategoryIcon(rhythm.category)} ${rhythm.name}`, content, [
 { text: 'Oefen dit ritme', class: 'btn-primary', action: () => {
 this.closeModal();
 this.practiceRhythm(rhythmId);
 }},
 { text: 'Sluiten', class: 'btn-outline', action: () => this.closeModal() }
 ]);
 
 // Draw ECG after modal is shown
 setTimeout(() => {
 ECGRenderer.drawStaticStrip('detailECG', rhythmId, ECGApp.getLibraryRenderOptions(rhythm));
 }, 100);
 },

 practiceRhythm(rhythmId) {
 // Start a quiz focused on this rhythm's category
 const rhythm = ECGDatabase.getRhythmById(rhythmId);
 if (!rhythm) return;
 
 QuizEngine.init({
 mode: 'standard',
 difficulty: rhythm.difficulty,
 category: rhythm.category,
 totalQuestions: 5
 });
 
 // Make sure this rhythm appears first
 AppState.quiz.currentRhythm = rhythm;
 
 Navigation.navigateTo('quiz');
 },

 // ========== CLINICAL CASES ==========
 startDailyCase(caseId) {
 const daily = LearningPathEngine.getDailyRound();
 if (!daily.caseIds.includes(caseId)) {
 this.showModal('Dagelijkse Ronde', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Deze case zit niet in de dagelijkse ronde van vandaag.</p>
 </div>
 </div>
 `);
 return;
 }
 this.startCase(caseId);
 },

 startCase(caseId) {
 const caseData = ClinicalCases.getCaseById(caseId);
 if (!caseData) return;
 
 this.currentCase = {
 ...caseData,
 currentQuestion: 0,
 answers: []
 };
 
 this.showCaseQuestion();
 },

 showCaseQuestion() {
 const caseData = this.currentCase;
 if (!caseData) return;
 
 const question = caseData.questions[caseData.currentQuestion];
 const rhythm = ECGDatabase.getRhythmById(caseData.rhythm);
 
 const content = Utils.$('#contentArea');
 content.innerHTML = `
 <div class="emergency-banner" style="background: linear-gradient(90deg, var(--primary), var(--purple));">
 <span></span>
 <span>${caseData.title}</span>
 </div>
 
 <!-- Patient Info -->
 <div class="card mb-2">
 <div class="card-body">
 <div class="case-header">
 <div class="case-avatar">${caseData.patientIcon}</div>
 <div class="case-info">
 <h3>${caseData.patientInfo}</h3>
 <p>${caseData.presentation}</p>
 </div>
 </div>
 
 <div class="vitals-grid mt-3">
 <div class="vital-card">
 <div class="vital-card-label">HR</div>
 <div class="vital-card-value ${caseData.vitals.hr > 100 || caseData.vitals.hr < 50 ? 'text-danger' : 'text-success'}">${caseData.vitals.hr || '--'}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">BP</div>
 <div class="vital-card-value text-primary">${caseData.vitals.bp || '--'}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">SpO2</div>
 <div class="vital-card-value ${caseData.vitals.spo2 < 94 ? 'text-warning' : 'text-info'}">${caseData.vitals.spo2 || '--'}%</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">RR</div>
 <div class="vital-card-value text-warning">${caseData.vitals.rr || '--'}</div>
 </div>
 </div>
 </div>
 </div>

 ${Array.isArray(caseData.learningObjectives) && caseData.learningObjectives.length ? `
 <div class="info-box info mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Leerdoelen</h4>
 <ul class="styled-list" style="margin-top:0.35rem;">
 ${caseData.learningObjectives.map(item => `<li>${item}</li>`).join('')}
 </ul>
 </div>
 </div>
 ` : ''}
 
 <!-- ECG Monitor -->
 <div class="ecg-monitor mb-2">
 <div class="ecg-monitor-header">
 <div class="ecg-monitor-title">
 <span class="pulse">*</span> Monitor
 </div>
 </div>
 <div class="ecg-canvas-wrapper">
 <canvas id="caseECG" class="ecg-canvas large"></canvas>
 <div class="ecg-lead-label">II</div>
 </div>
 </div>
 
 <!-- Question -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title">Vraag ${caseData.currentQuestion + 1} van ${caseData.questions.length}</h3>
 <span class="badge badge-info">${(question.type || 'recognition').replace('_', ' ')}</span>
 </div>
 <div class="card-body">
 <p style="font-size: 1.1rem; margin-bottom: 1.5rem;"><strong>${question.question}</strong></p>
 
 <div class="quiz-options" id="caseOptions">
 ${question.options.map((opt, index) => `
 <div class="quiz-option" data-index="${index}" onclick="ECGApp.selectCaseAnswer(${index})">
 <span class="quiz-option-key">${String.fromCharCode(65 + index)}</span>
 <div class="quiz-option-content">
 <div class="quiz-option-title">${opt}</div>
 </div>
 </div>
 `).join('')}
 </div>
 
 <div class="feedback-panel" id="caseFeedback"></div>
 
 <div class="btn-group mt-3" style="justify-content: space-between;">
 <button class="btn btn-outline" onclick="Navigation.navigateTo('cases')">
 Terug
 </button>
 <button class="btn btn-primary hidden" id="caseNextBtn" onclick="ECGApp.nextCaseQuestion()"> Volgende
 </button>
 </div>
 </div>
 </div>
 `;
 this.updateBreadcrumb(`Cases > Vraag ${caseData.currentQuestion + 1}/${caseData.questions.length}`);
 
 // Draw ECG
 setTimeout(() => {
 const rate = caseData.vitals.hr || 72;
 ECGRenderer.drawStaticStrip('caseECG', caseData.rhythm, { heartRate: rate });
 }, 100);
 },

 selectCaseAnswer(index) {
 const caseData = this.currentCase;
 if (!caseData) return;
 
 const question = caseData.questions[caseData.currentQuestion];
 const isCorrect = index === question.correct;
 const source = MedicalContentAudit.getSource(question.sourceId);
 const guidelineRef = MedicalContentAudit.getGuidelineReferenceForQuestion(caseData.id, caseData.currentQuestion, question);
 const examinerEnabled = AppState.settings?.examinerMode !== false;
 
 // Visual feedback
 Utils.$$('#caseOptions .quiz-option').forEach((opt, i) => {
 opt.classList.add('disabled');
 if (i === question.correct) {
 opt.classList.add('correct');
 } else if (i === index && !isCorrect) {
 opt.classList.add('incorrect');
 }
 });
 
 // Show explanation
 const feedback = document.getElementById('caseFeedback');
 if (feedback) {
 feedback.className = `feedback-panel show ${isCorrect ? 'correct' : 'incorrect'}`;
 feedback.innerHTML = `
 <div class="feedback-header">
 <div class="feedback-icon">${isCorrect ? '&#10004;' : '&#10006;'}</div>
 <div>
 <div class="feedback-title">${isCorrect ? 'Correct!' : 'Niet juist'}</div>
 </div>
 </div>
 <div style="margin-top: 1rem;">
 <p>${question.explanation}</p>
 <div class="info-box success" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Bron (richtlijn/paper)</h4>
 <p><a href="${source.url}" target="_blank" rel="noopener noreferrer">${source.title}</a></p>
 </div>
 </div>
 ${!isCorrect && examinerEnabled ? `
 <div class="info-box danger" style="margin-top: 0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Examiner Mode - relevante guideline-paragraaf</h4>
 <p>${guidelineRef || source.keySection || 'Zie primaire richtlijnbron voor de onderliggende paragraaf.'}</p>
 </div>
 </div>
 ` : ''}
 </div>
 `;
 }
 
 // Record answer
 caseData.answers.push({
 questionIndex: caseData.currentQuestion,
 selected: index,
 correct: isCorrect
 });
 
 // Show next button
 const nextBtn = document.getElementById('caseNextBtn');
 if (nextBtn) {
 nextBtn.classList.remove('hidden');
 if (caseData.currentQuestion >= caseData.questions.length - 1) {
 nextBtn.textContent = 'Bekijk Resultaten';
 }
 }
 
 // Update stats
 if (isCorrect) {
 AppState.user.totalCorrect++;
 AppState.user.xp += 25;
 }
AppState.user.totalAnswered++;
Storage.scheduleSave(900);
this.updateSidebarStats();
 },

 nextCaseQuestion() {
 const caseData = this.currentCase;
 if (!caseData) return;
 
 caseData.currentQuestion++;
 
 if (caseData.currentQuestion >= caseData.questions.length) {
 // Show case results
 this.showCaseResults();
 } else {
 this.showCaseQuestion();
 }
 },

 showCaseResults() {
 const caseData = this.currentCase;
 if (!caseData) return;
 
 const correct = caseData.answers.filter(a => a.correct).length;
 const total = caseData.answers.length;
 const accuracy = Math.round((correct / total) * 100);
 
 const content = Utils.$('#contentArea');
 content.innerHTML = `
 <div class="card">
 <div class="card-body">
<div class="score-display">
<div style="font-size: 4rem; margin-bottom: 1rem;">
${accuracy >= 80 ? '&#x1F3C6;' : accuracy >= 60 ? '&#x1F44D;' : '&#x1F4DA;'}
</div>
<h2>Case Voltooid!</h2>
 <p class="text-muted mb-3">${caseData.title}</p>
 <div class="vitals-grid" style="max-width: 300px; margin: 0 auto 2rem;">
 <div class="vital-card">
 <div class="vital-card-label">Score</div>
 <div class="vital-card-value text-success">${correct}/${total}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Nauwkeurigheid</div>
 <div class="vital-card-value text-primary">${accuracy}%</div>
 </div>
 </div>
 ${caseData.debrief ? `
 <div class="info-box info mb-3" style="max-width:700px; margin:0 auto 1.25rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Debrief</h4>
 <p>${caseData.debrief}</p>
 </div>
 </div>
 ` : ''}
 <div class="btn-group" style="justify-content: center;">
 <button class="btn btn-primary" onclick="Navigation.navigateTo('cases')"> Meer Cases
 </button>
 <button class="btn btn-outline" onclick="Navigation.navigateTo('dashboard')"> Dashboard
 </button>
 </div>
 </div>
 </div>
 </div>
 `;
 this.updateBreadcrumb('Cases > Resultaat');
 
 // Clear current case
 if (caseData.id) {
 if (!AppState.learningPath.completedCases.includes(caseData.id)) {
 AppState.learningPath.completedCases.push(caseData.id);
 }
LearningPathEngine.completeDailyCase(caseData.id);
LearningPathEngine.syncState();
Storage.flushSave('manual');
}
this.currentCase = null;
 },

 // ========== TAB SWITCHING ==========
 switchACLSTab(tabId) {
 Utils.$$('.tab-content').forEach(tc => tc.classList.remove('active'));
 Utils.$$('.tab').forEach(t => t.classList.remove('active'));
 
 const tabContent = document.getElementById(`tab-${tabId}`);
 if (tabContent) tabContent.classList.add('active');
 
 // Find and activate the tab button
 Utils.$$('.tab').forEach(t => {
 if (t.textContent.toLowerCase().includes(tabId.substring(0, 5))) {
 t.classList.add('active');
 }
 });
 },

 switchDrugTab(tabId) {
 Utils.$$('.tab-content').forEach(tc => tc.classList.remove('active'));
 Utils.$$('.tab').forEach(t => t.classList.remove('active'));
 
 const tabContent = document.getElementById(`tab-${tabId}`);
 if (tabContent) tabContent.classList.add('active');
 
 Utils.$$('.tab').forEach(t => {
 if (t.onclick && t.onclick.toString().includes(tabId)) {
 t.classList.add('active');
 }
 });
 },

 switchCriteriaTab(tabId) {
 Utils.$$('.tab-content').forEach(tc => tc.classList.remove('active'));
 Utils.$$('.tab').forEach(t => t.classList.remove('active'));
 
 const tabContent = document.getElementById(`tab-${tabId}`);
 if (tabContent) tabContent.classList.add('active');
 
 Utils.$$('.tab').forEach(t => {
 if (t.onclick && t.onclick.toString().includes(tabId)) {
 t.classList.add('active');
 }
 });
 },

 // ========== MODAL ==========
 showModal(title, content, buttons = null) {
 const modal = document.getElementById('modal');
 const modalTitle = document.getElementById('modalTitle');
 const modalBody = document.getElementById('modalBody');
 const modalFooter = document.getElementById('modalFooter');
 
 if (modalTitle) modalTitle.textContent = title;
 if (modalBody) modalBody.innerHTML = content;
 
 if (modalFooter) {
 if (buttons) {
 modalFooter.innerHTML = buttons.map(btn => 
 `<button class="btn ${btn.class || 'btn-outline'}" onclick="${btn.action ? btn.action.toString().includes('=>') ? btn.action : `ECGApp.${btn.action}()` : 'ECGApp.closeModal()'}">${btn.text}</button>`
 ).join('');
 
 // Re-bind click handlers for complex actions
 buttons.forEach((btn, index) => {
 if (btn.action && typeof btn.action === 'function') {
 modalFooter.children[index].onclick = btn.action;
 }
 });
 } else {
 modalFooter.innerHTML = '<button class="btn btn-outline" onclick="ECGApp.closeModal()">Sluiten</button>';
 }
 }
 
 if (modal) modal.classList.add('show');
 },

 closeModal() {
 const modal = document.getElementById('modal');
 if (modal) modal.classList.remove('show');
 },

 // ========== KEYBOARD SHORTCUTS ==========
 setupKeyboardShortcuts() {
 document.addEventListener('keydown', (e) => {
 // Don't trigger if typing in input
 if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
 
 const quiz = AppState.quiz;
 
 // Quiz answer shortcuts (A, B, C, D)
 if (quiz.active && !quiz.showingFeedback) {
 const key = e.key.toUpperCase();
 if (['A', 'B', 'C', 'D'].includes(key)) {
 const index = key.charCodeAt(0) - 65;
 const options = Utils.$$('.quiz-option');
 if (options[index]) {
 const answerId = options[index].dataset.answer;
 if (answerId) this.selectAnswer(answerId);
 }
 }
 }
 
 // Enter/Space for next question
 if ((e.key === 'Enter' || e.key === ' ') && quiz.showingFeedback) {
 e.preventDefault();
 this.nextQuestion();
 }
 
 // Escape to close modal
 if (e.key === 'Escape') {
 this.closeModal();
 }
 
 // Number keys for navigation (1-9)
 if (!quiz.active && e.key >= '1' && e.key <= '9') {
 const sections = ['dashboard', 'monitor', 'coach', 'learningPath', 'library', 'systematic', 'quiz', 'cases', 'acls'];
 const index = parseInt(e.key) - 1;
 if (sections[index]) {
 Navigation.navigateTo(sections[index]);
 }
 }
 });
 },

 // ========== UTILITY ==========
startChecklistTraining() {
AppState.learningPath.checklistTraining.activeSince = new Date().toISOString();
Storage.scheduleSave(700);
if (AppState.currentSection === 'systematic') {
Sections.renderSystematic(Utils.$('#contentArea'));
}
 },

 completeChecklistTraining() {
 const checks = Array.from(document.querySelectorAll('.sys-checklist-step'));
 if (checks.length > 0 && checks.some(c => !c.checked)) {
 this.showModal('Checklist niet compleet', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Vink eerst alle checkliststappen aan.</p>
 </div>
 </div>
 `);
 return;
 }

 AppState.learningPath.checklistTraining.sessions += 1;
 AppState.learningPath.checklistTraining.lastCompleted = new Date().toISOString();
 AppState.learningPath.checklistTraining.activeSince = null;
AppState.user.xp += 15;
LearningPathEngine.syncState();
Storage.flushSave('manual');
this.updateSidebarStats();
 if (AppState.currentSection === 'systematic') {
 Sections.renderSystematic(Utils.$('#contentArea'));
 }
 },

 openSystematicDrill(drillType = 'rate') {
 const drills = {
 rate: {
 title: 'Frequentie drill',
 task: 'Gebruik 25 mm/s: bij 4 grote hokjes tussen R-toppen, wat is de hartfrequentie?',
 answer: '300 / 4 = 75 bpm',
 tip: 'Gebruik eerst de 300-regel, daarna check je of het ritme regelmatig is.'
 },
 rhythm: {
 title: 'Ritme drill',
 task: 'Noem 3 vragen die je altijd stelt voor ritmeanalyse.',
 answer: '1) Regelmatig? 2) P voor elk QRS? 3) Constante P-QRS relatie?',
 tip: 'Ritmeregelmaat en AV-relatie geven vaak direct de differentiaalrichting.'
 },
 conduction: {
 title: 'Geleiding drill',
 task: 'Welke grenswaarden gebruik je voor PR en QRS?',
 answer: 'PR 120-200 ms; QRS < 120 ms',
 tip: 'Bij brede QRS en tachycardie: behandel als VT tot tegendeel bewezen.'
 },
 ischemia: {
 title: 'ST/T drill',
 task: 'Noem 2 rode vlaggen voor acute ischemie op ECG.',
 answer: 'Territoriale ST-elevatie met reciproque veranderingen; STEMI-equivalenten zoals de Winter.',
 tip: 'Gebruik altijd klinische context en escaleer bij hoog-risico patroon.'
 }
 };
 const drill = drills[drillType] || drills.rate;
 this.showModal(`${drill.title}`, `
 <div class="info-box info">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Opdracht</h4>
 <p>${drill.task}</p>
 </div>
 </div>
 <div class="info-box success" style="margin-top:0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Modelantwoord</h4>
 <p>${drill.answer}</p>
 </div>
 </div>
 <div class="info-box warning" style="margin-top:0.75rem;">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Tip</h4>
 <p>${drill.tip}</p>
 </div>
 </div>
 `);
 },

 resetProgress() {
 if (confirm(`Weet je zeker dat je alle voortgang van profiel "${AppState.profile?.name || 'Standaard'}" wilt wissen? Dit kan niet ongedaan worden gemaakt.`)) {
 Storage.clear();
 }
 },

 createProfile() {
 const name = prompt('Naam voor nieuw profiel:');
 if (!name) return;
 try {
 Storage.createProfile(name);
 location.reload();
 } catch (error) {
 this.showModal('Profiel aanmaken mislukt', `
 <div class="info-box danger">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>${error.message}</p>
 </div>
 </div>
 `);
 }
 },

 switchProfile() {
 const profiles = Storage.listProfiles();
 if (!profiles.length) return;

 const list = profiles
 .map((p, i) => `${i + 1}. ${p.name}${p.id === AppState.profile.id ? ' (actief)' : ''}`)
 .join('\n');

 const input = prompt(`Kies profielnummer:\n\n${list}`, '1');
 if (!input) return;

 const index = parseInt(input, 10) - 1;
 if (isNaN(index) || index < 0 || index >= profiles.length) {
 this.showModal('Ongeldige keuze', `
 <div class="info-box warning">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Kies een geldig profielnummer.</p>
 </div>
 </div>
 `);
 return;
 }

 const target = profiles[index];
 if (target.id === AppState.profile.id) return;
 Storage.setActiveProfile(target.id);
 location.reload();
 },

 renameCurrentProfile() {
 const currentName = AppState.profile?.name || 'Standaard';
 const newName = prompt('Nieuwe profielnaam:', currentName);
 if (!newName || newName.trim() === currentName) return;

try {
Storage.renameActiveProfile(newName);
Storage.scheduleSave(600);
this.updateSidebarStats();
 if (AppState.currentSection === 'settings') {
 Sections.renderSettings(Utils.$('#contentArea'));
 }
 } catch (error) {
 this.showModal('Hernoemen mislukt', `
 <div class="info-box danger">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>${error.message}</p>
 </div>
 </div>
 `);
 }
 },

 deleteCurrentProfile() {
 const currentName = AppState.profile?.name || 'Standaard';
 if (!confirm(`Weet je zeker dat je profiel "${currentName}" wilt verwijderen?`)) return;

 try {
 Storage.deleteProfile(AppState.profile.id);
 location.reload();
 } catch (error) {
 this.showModal('Verwijderen mislukt', `
 <div class="info-box danger">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>${error.message}</p>
 </div>
 </div>
 `);
 }
 }
 };

 // ==================== DEEL 5 GAAT HIER VERDER ====================

 // ==================== ACHIEVEMENTS SYSTEM ====================
 const Achievements = {
 definitions: [
 // Learning milestones
{
id: 'first_quiz',
name: 'Eerste Stappen',
description: 'Voltooi je eerste quiz',
icon: '&#x1F331;',
category: 'learning',
condition: (user) => user.quizHistory.length >= 1,
xpReward: 50
},
{
id: 'quiz_master_10',
name: 'Quiz Veteraan',
description: 'Voltooi 10 quizzen',
icon: '&#x1F4D8;',
category: 'learning',
condition: (user) => user.quizHistory.length >= 10,
xpReward: 100
},
{
id: 'quiz_master_50',
name: 'Quiz Meester',
description: 'Voltooi 50 quizzen',
icon: '&#x1F3C6;',
category: 'learning',
condition: (user) => user.quizHistory.length >= 50,
xpReward: 250
},
{
id: 'perfect_quiz',
name: 'Perfect!',
description: 'Behaal 100% op een quiz',
icon: '&#x1F3AF;',
category: 'learning',
condition: (user) => user.quizHistory.some(q => q.accuracy === 100 && q.total >= 5),
xpReward: 75
},
 
 // Streak achievements
{
id: 'streak_3',
name: 'Op Dreef',
description: 'Behaal een reeks van 3',
icon: '&#x1F525;',
category: 'streak',
condition: (user) => user.streak >= 3,
xpReward: 25
},
{
id: 'streak_10',
name: 'Onstopbaar',
description: 'Behaal een reeks van 10',
icon: '&#x1F4A5;',
category: 'streak',
condition: (user) => user.streak >= 10,
xpReward: 75
},
{
id: 'streak_25',
name: 'Legendarisch',
description: 'Behaal een reeks van 25',
icon: '&#x1F30B;',
category: 'streak',
condition: (user) => user.streak >= 25,
xpReward: 200
},
 
 // Mastery achievements
{
id: 'master_5',
name: 'Ritme Kenner',
description: 'Beheers 5 ritmes',
icon: '&#x1F4DA;',
category: 'mastery',
condition: (user) => user.masteredRhythms.length >= 5,
xpReward: 100
},
{
id: 'master_15',
name: 'Ritme Expert',
description: 'Beheers 15 ritmes',
icon: '&#x1F393;',
category: 'mastery',
condition: (user) => user.masteredRhythms.length >= 15,
xpReward: 250
},
{
id: 'master_all',
name: 'ECG Meester',
description: 'Beheers alle ritmes',
icon: '&#x1F451;',
category: 'mastery',
condition: (user) => user.masteredRhythms.length >= ECGDatabase.getAllRhythms().length,
xpReward: 1000
},
 
 // Category specialists
{
id: 'sinus_expert',
name: 'Sinus Specialist',
description: 'Beheers alle sinusritmes',
icon: '&#x2665;',
category: 'specialist',
condition: (user) => {
const sinusRhythms = ECGDatabase.getRhythmsByCategory('normal').map(r => r.id);
return sinusRhythms.every(id => user.masteredRhythms.includes(id));
},
xpReward: 150
},
{
id: 'block_expert',
name: 'Blok Specialist',
description: 'Beheers alle AV-blokken',
icon: '&#x1F517;',
category: 'specialist',
condition: (user) => {
const blockRhythms = ECGDatabase.getRhythmsByCategory('blocks').map(r => r.id);
return blockRhythms.every(id => user.masteredRhythms.includes(id));
 },
 xpReward: 200
 },
{
id: 'emergency_expert',
name: 'Spoed Expert',
description: 'Beheers alle kritieke ritmes',
icon: '&#x26A0;',
category: 'specialist',
condition: (user) => {
const criticalRhythms = ECGDatabase.getCriticalRhythms().map(r => r.id);
return criticalRhythms.every(id => user.masteredRhythms.includes(id));
 },
 xpReward: 300
 },
 
 // XP milestones
{
id: 'xp_500',
name: 'Beginner',
description: 'Verdien 500 XP',
icon: '&#x2B50;',
category: 'xp',
condition: (user) => user.xp >= 500,
xpReward: 50
},
{
id: 'xp_2000',
name: 'Gevorderde',
description: 'Verdien 2000 XP',
icon: '&#x1F31F;',
category: 'xp',
condition: (user) => user.xp >= 2000,
xpReward: 100
},
{
id: 'xp_5000',
name: 'Expert',
description: 'Verdien 5000 XP',
icon: '&#x1F4AB;',
category: 'xp',
condition: (user) => user.xp >= 5000,
xpReward: 250
},
{
id: 'xp_10000',
name: 'Grootmeester',
description: 'Verdien 10000 XP',
icon: '&#x1F48E;',
category: 'xp',
condition: (user) => user.xp >= 10000,
xpReward: 500
},
 
 // Special achievements
{
id: 'speed_demon',
name: 'Snelheidsduivel',
description: 'Beantwoord 5 vragen binnen 10 seconden elk',
icon: '&#x26A1;',
category: 'special',
condition: (user) => {
const recentAnswers = user.quizHistory
.flatMap(q => q.answers || [])
.filter(a => a.timeSpent && a.timeSpent < 10 && a.correct);
 return recentAnswers.length >= 5;
 },
 xpReward: 100
 },
{
id: 'night_owl',
name: 'Nachtuil',
description: 'Oefen na middernacht',
icon: '&#x1F989;',
category: 'special',
condition: () => {
const hour = new Date().getHours();
return hour >= 0 && hour < 5;
 },
 xpReward: 25
 },
{
id: 'survivor',
name: 'Overlever',
description: 'Behaal 15+ correcte antwoorden in survivalmodus',
icon: '&#x1F6E1;',
category: 'special',
condition: (user) => {
return user.quizHistory.some(q => q.mode === 'survival' && q.correct >= 15);
 },
 xpReward: 200
 }
 ],

 // Check and award new achievements
 checkAchievements() {
 const user = AppState.user;
 const newAchievements = [];

 this.definitions.forEach(achievement => {
 if (!user.achievements.includes(achievement.id)) {
 try {
 if (achievement.condition(user)) {
 user.achievements.push(achievement.id);
 user.xp += achievement.xpReward;
 newAchievements.push(achievement);
 }
 } catch (e) {
 console.warn(`Error checking achievement ${achievement.id}:`, e);
 }
 }
 });

if (newAchievements.length > 0) {
Storage.scheduleSave(800);
this.showAchievementNotification(newAchievements);
}

 return newAchievements;
 },

 // Show achievement notification
 showAchievementNotification(achievements) {
 achievements.forEach((achievement, index) => {
 setTimeout(() => {
 const notification = document.createElement('div');
 notification.className = 'achievement-notification';
 notification.innerHTML = `
 <div class="achievement-icon">${achievement.icon}</div>
 <div class="achievement-content">
 <div class="achievement-title"> Achievement Unlocked!</div>
 <div class="achievement-name">${achievement.name}</div>
 <div class="achievement-desc">${achievement.description}</div>
 <div class="achievement-reward">+${achievement.xpReward} XP</div>
 </div>
 `;
 document.body.appendChild(notification);

 // Animate in
 setTimeout(() => notification.classList.add('show'), 10);

 // Remove after delay
 setTimeout(() => {
 notification.classList.remove('show');
 setTimeout(() => notification.remove(), 300);
 }, 4000);
 }, index * 1000);
 });
 },

 // Get all achievements with status
 getAllWithStatus() {
 const user = AppState.user;
 return this.definitions.map(achievement => ({
 ...achievement,
 unlocked: user.achievements.includes(achievement.id)
 }));
 },

 // Get unlocked achievements
 getUnlocked() {
 return this.getAllWithStatus().filter(a => a.unlocked);
 },

 // Get locked achievements
 getLocked() {
 return this.getAllWithStatus().filter(a => !a.unlocked);
 },

 // Get achievement by ID
 getById(id) {
 return this.definitions.find(a => a.id === id);
 }
 };

 // ==================== PROGRESS & STATISTICS ====================
 const ProgressTracker = {
 // Get detailed statistics
 getStatistics() {
 const user = AppState.user;
 const history = user.quizHistory;

 // Basic stats
 const totalQuizzes = history.length;
 const totalAnswered = user.totalAnswered;
 const totalCorrect = user.totalCorrect;
 const accuracy = Utils.calcAccuracy(totalCorrect, totalAnswered);

 // Category breakdown
 const categoryStats = {};
 Object.keys(ECGDatabase.categories).forEach(catId => {
 categoryStats[catId] = { correct: 0, total: 0 };
 });

 history.forEach(quiz => {
 if (quiz.answers) {
 quiz.answers.forEach(answer => {
 const rhythm = ECGDatabase.getRhythmById(answer.rhythmId);
 if (rhythm && categoryStats[rhythm.category]) {
 categoryStats[rhythm.category].total++;
 if (answer.correct) {
 categoryStats[rhythm.category].correct++;
 }
 }
 });
 }
 });

 // Difficulty breakdown
 const difficultyStats = { easy: { correct: 0, total: 0 }, medium: { correct: 0, total: 0 }, hard: { correct: 0, total: 0 } };
 history.forEach(quiz => {
 if (quiz.answers) {
 quiz.answers.forEach(answer => {
 const rhythm = ECGDatabase.getRhythmById(answer.rhythmId);
 if (rhythm && difficultyStats[rhythm.difficulty]) {
 difficultyStats[rhythm.difficulty].total++;
 if (answer.correct) {
 difficultyStats[rhythm.difficulty].correct++;
 }
 }
 });
 }
 });

 // Time-based stats
 const lastWeek = history.filter(q => {
 const quizDate = new Date(q.date);
 const weekAgo = new Date();
 weekAgo.setDate(weekAgo.getDate() - 7);
 return quizDate > weekAgo;
 });

 // Average accuracy trend
 const recentAccuracy = lastWeek.length > 0
 ? Math.round(lastWeek.reduce((sum, q) => sum + q.accuracy, 0) / lastWeek.length)
 : 0;

 return {
 totalQuizzes,
 totalAnswered,
 totalCorrect,
 accuracy,
 xp: user.xp,
 level: Utils.calculateLevel(user.xp),
 streak: user.streak,
 masteredRhythms: user.masteredRhythms.length,
 totalRhythms: ECGDatabase.getAllRhythms().length,
 achievements: user.achievements.length,
 totalAchievements: Achievements.definitions.length,
 categoryStats,
 difficultyStats,
 quizzesThisWeek: lastWeek.length,
 recentAccuracy,
 bestStreak: Math.max(user.streak, ...history.map(q => q.correct || 0))
 };
 },

 // Get rhythm-specific progress
 getRhythmProgress() {
 const rhythms = ECGDatabase.getAllRhythms();
 const user = AppState.user;
 const history = user.quizHistory;

 const rhythmStats = {};

 // Initialize
 rhythms.forEach(r => {
 rhythmStats[r.id] = {
 rhythm: r,
 attempts: 0,
 correct: 0,
 mastered: user.masteredRhythms.includes(r.id)
 };
 });

 // Aggregate from history
 history.forEach(quiz => {
 if (quiz.answers) {
 quiz.answers.forEach(answer => {
 if (rhythmStats[answer.rhythmId]) {
 rhythmStats[answer.rhythmId].attempts++;
 if (answer.correct) {
 rhythmStats[answer.rhythmId].correct++;
 }
 }
 });
 }
 });

 return Object.values(rhythmStats).map(stat => ({
 ...stat,
 accuracy: stat.attempts > 0 ? Math.round((stat.correct / stat.attempts) * 100) : 0
 }));
 },

 // Get weak areas (rhythms with low accuracy)
 getWeakAreas() {
 const progress = this.getRhythmProgress();
 return progress
 .filter(p => p.attempts >= 2 && p.accuracy < 70)
 .sort((a, b) => a.accuracy - b.accuracy)
 .slice(0, 5);
 },

 // Get strong areas
 getStrongAreas() {
 const progress = this.getRhythmProgress();
 return progress
 .filter(p => p.attempts >= 3 && p.accuracy >= 80)
 .sort((a, b) => b.accuracy - a.accuracy)
 .slice(0, 5);
 }
 };

 // ==================== LEARNING PATH ENGINE ====================
 const LearningPathEngine = {
 moduleDefinitions: [
{
id: 'module_1',
icon: '&#x1F4D0;',
title: 'Module 1: Fundamenten',
description: 'Kalibratie, frequentie, ritmeregelmaat en assen.',
categories: ['normal', 'bradycardia'],
 requiredQuestions: 8,
 requiredAccuracy: 80
 },
{
id: 'module_2',
icon: '&#x1F4CB;',
title: 'Module 2: Systematische Analyse',
description: 'Vast 8-10 stappenmodel + checklist training.',
categories: ['normal', 'bradycardia', 'tachycardia'],
 requiredQuestions: 10,
 requiredAccuracy: 80,
 requiredChecklistSessions: 1
 },
{
id: 'module_3',
icon: '&#x1F499;',
title: 'Module 3: Supraventriculaire Ritmes',
description: 'Sinusvarianten, AF/AFL/SVT en eerste behandeling.',
categories: ['atrial', 'tachycardia'],
 requiredQuestions: 12,
 requiredAccuracy: 80
 },
{
id: 'module_4',
icon: '&#x1F517;',
title: 'Module 4: Geleiding',
description: 'AV-blokken, RBBB/LBBB en fasciculaire patronen.',
categories: ['blocks'],
 requiredQuestions: 12,
 requiredAccuracy: 80
 },
{
id: 'module_5',
icon: '&#x1F6A8;',
title: 'Module 5: Ventriculaire & Arrest',
description: 'VT/VF/asystolie/PEA en ACLS-kernacties.',
categories: ['ventricular'],
 rhythmIds: ['asystole', 'pea'],
 requiredQuestions: 12,
 requiredAccuracy: 80
 },
{
id: 'module_6',
icon: '&#x1FA78;',
title: 'Module 6: Ischemie & Equivalenten',
description: 'STEMI/NSTEMI, Wellens, de Winter, posterior.',
categories: ['ischemia'],
 requiredQuestions: 12,
 requiredAccuracy: 80
 },
{
id: 'module_7',
icon: '&#x2697;',
title: 'Module 7: Elektrolyten & Toxiciteit',
description: 'K/Calcium, QT, digoxine, pacingproblemen.',
rhythmIds: ['hyperkalemia', 'hypokalemia', 'hypercalcemia', 'hypocalcemia', 'long_qt', 'digoxin_toxicity', 'pacemaker_malfunction'],
 requiredQuestions: 10,
 requiredAccuracy: 80
 },
{
id: 'module_8',
icon: '&#x1F3C1;',
title: 'Module 8: Integratie',
description: 'Klinische cases met prioritering en tijdsdruk.',
allRhythms: true,
 caseIds: [
 'case_chest_pain',
 'case_syncope',
 'case_palpitations',
 'case_resuscitation',
 'case_potassium',
 'case_af_rvr',
 'case_post_arrest_stemi',
 'case_sepsis_tachyarrhythmia',
 'case_intox_qt',
 'case_hypokalemia_qt',
 'case_pacemaker_failure',
 'case_dewinter_acs',
 'case_unstable_brady',
 'case_wide_complex_tachy'
 ],
 requiredQuestions: 15,
 requiredAccuracy: 80,
 requiredCases: 4
 }
 ],

 getModuleById(moduleId) {
 return this.moduleDefinitions.find(m => m.id === moduleId) || null;
 },

 getModulePitfalls(moduleId) {
 const map = {
 module_1: [
 'Kalibratie/snelheid niet eerst controleren',
 'Hartfrequentie op het oog schatten zonder methode',
 'Regelmaat niet objectief beoordelen'
 ],
 module_2: [
 'Stappen overslaan in de checklist',
 'QRS/PR wel noemen maar niet kwantificeren',
 'QTc niet in context van ritme/frequentie plaatsen'
 ],
 module_3: [
 'AF en flutter door elkaar halen',
 'SVT meteen medicamenteus behandelen zonder vagale stap',
 'Instabiliteit niet eerst uitsluiten'
 ],
 module_4: [
 'Mobitz II onderschatten als laag-risico',
 'LBBB absoluut als STEMI diagnosticeren',
 'AV-dissociatie missen'
 ],
 module_5: [
 'Brede tachy niet primair als VT benaderen',
 'Defibrillatie/cardioversie vertragen',
 'Niet-schokbaar ritme toch schokken'
 ],
 module_6: [
 'STEMI-equivalenten (de Winter/posterior) missen',
 'Reciproke veranderingen niet meenemen',
 'Reperfusiepad uitstellen door extra tests'
 ],
 module_7: [
 'Elektrolytstoornissen niet koppelen aan ECG',
 'QT-risico onderschatten bij intoxicatie',
 'Pacemakerdysfunctie niet herkennen'
 ],
 module_8: [
 'Diagnose wel goed, eerste stap te laat',
 'Urgentie-inschatting los van hemodynamiek',
 'Geen expliciet escalatiemoment benoemen'
 ]
 };
 return map[moduleId] || [];
 },

 getModuleRhythms(moduleId) {
 const module = this.getModuleById(moduleId);
 if (!module) return ECGDatabase.getAllRhythms();
 if (module.allRhythms) return ECGDatabase.getAllRhythms();

 let rhythms = [];
 if (Array.isArray(module.categories)) {
 module.categories.forEach(cat => {
 rhythms = rhythms.concat(ECGDatabase.getRhythmsByCategory(cat));
 });
 }
 if (Array.isArray(module.rhythmIds)) {
 module.rhythmIds.forEach(id => {
 const rhythm = ECGDatabase.getRhythmById(id);
 if (rhythm) rhythms.push(rhythm);
 });
 }

 const unique = [];
 const seen = new Set();
 rhythms.forEach(r => {
 if (!seen.has(r.id)) {
 seen.add(r.id);
 unique.push(r);
 }
 });
 return unique;
 },

 getModuleQuestionStats(moduleId) {
 const rhythmIds = new Set(this.getModuleRhythms(moduleId).map(r => r.id));
 let total = 0;
 let correct = 0;

 AppState.user.quizHistory.forEach(quiz => {
 if (!quiz.answers) return;
 quiz.answers.forEach(answer => {
 if (rhythmIds.has(answer.rhythmId)) {
 total++;
 if (answer.correct) correct++;
 }
 });
 });

 const accuracy = total > 0 ? Math.round((correct / total) * 100) : 0;
 return { total, correct, accuracy };
 },

 getModuleCaseProgress(moduleId) {
 const module = this.getModuleById(moduleId);
 const requiredCases = module?.requiredCases || 0;
 const pool = module?.caseIds || [];
 const completed = new Set(AppState.learningPath.completedCases || []);
 const done = pool.filter(id => completed.has(id)).length;
 return { requiredCases, done, totalPool: pool.length };
 },

 calculateStatuses() {
 const statuses = {};
 const checklistSessions = AppState.learningPath.checklistTraining?.sessions || 0;

 this.moduleDefinitions.forEach((module, index) => {
 let unlocked = false;
 if (index === 0) {
 unlocked = true;
 } else if (index <= 3) {
 const prev = this.moduleDefinitions[index - 1];
 unlocked = !!statuses[prev.id]?.completed;
 } else {
 unlocked = !!statuses['module_4']?.completed;
 }

 const q = this.getModuleQuestionStats(module.id);
 const c = this.getModuleCaseProgress(module.id);
 const qMet = q.total >= module.requiredQuestions && q.accuracy >= module.requiredAccuracy;
 const cMet = !module.requiredCases || c.done >= module.requiredCases;
 const sMet = !module.requiredChecklistSessions || checklistSessions >= module.requiredChecklistSessions;
 const completed = unlocked && qMet && cMet && sMet;

 statuses[module.id] = {
 ...module,
 unlocked,
 completed,
 questionStats: q,
 caseStats: c,
 checklistSessions,
 requirementsMet: { qMet, cMet, sMet }
 };
 });

 return statuses;
 },

 syncState() {
 const statuses = this.calculateStatuses();
 const completedModules = this.moduleDefinitions
 .filter(m => statuses[m.id]?.completed)
 .map(m => m.id);

 AppState.learningPath.completedModules = completedModules;
 const nextModule = this.moduleDefinitions.find(m => statuses[m.id].unlocked && !statuses[m.id].completed);
 AppState.learningPath.currentModule = nextModule?.id || this.moduleDefinitions[this.moduleDefinitions.length - 1].id;
 AppState.learningPath.weeklyFocus = this.getWeeklyFocus();
 this.ensureDailyRound();
 return statuses;
 },

 getModuleStatus(moduleId) {
 return this.calculateStatuses()[moduleId];
 },

 getCurrentModule() {
 return this.getModuleById(AppState.learningPath.currentModule);
 },

 hashString(input) {
 let hash = 0;
 for (let i = 0; i < input.length; i++) {
 hash = ((hash << 5) - hash) + input.charCodeAt(i);
 hash |= 0;
 }
 return Math.abs(hash);
 },

 ensureDailyRound() {
 const today = new Date().toISOString().slice(0, 10);
 const state = AppState.learningPath.dailyRoundState || {};
 const allCases = ClinicalCases.getAllCases().map(c => c.id);

 if (state.date !== today || !Array.isArray(state.caseIds) || state.caseIds.length === 0) {
 const scored = allCases
 .map(id => ({ id, score: this.hashString(`${today}:${id}`) }))
 .sort((a, b) => a.score - b.score)
 .slice(0, Math.min(3, allCases.length))
 .map(x => x.id);

 AppState.learningPath.dailyRoundState = {
 date: today,
 caseIds: scored,
 completedCaseIds: []
 };
 }

 return AppState.learningPath.dailyRoundState;
 },

 completeDailyCase(caseId) {
 const state = this.ensureDailyRound();
 if (!state.caseIds.includes(caseId)) return;
 if (!state.completedCaseIds.includes(caseId)) {
 state.completedCaseIds.push(caseId);
 }
 },

 getDailyRound() {
 return this.ensureDailyRound();
 },

 getWeeklyFocus() {
 if (typeof LearningCoachEngine !== 'undefined') {
 const coachFocus = LearningCoachEngine.getWeeklyFocus();
 if (coachFocus && coachFocus.length > 0) {
 return coachFocus.slice(0, 3);
 }
 }
 const weak = ProgressTracker.getWeakAreas().slice(0, 3).map(item => ({
 id: item.rhythm.id,
 name: item.rhythm.name,
 accuracy: item.accuracy
 }));

 if (weak.length > 0) return weak;

 const current = this.getCurrentModule();
 return this.getModuleRhythms(current?.id || 'module_1')
 .slice(0, 3)
 .map(r => ({ id: r.id, name: r.name, accuracy: 0 }));
 },

 getChecklistElapsedMinutes() {
 const activeSince = AppState.learningPath.checklistTraining?.activeSince;
 if (!activeSince) return 0;
 const diffMs = Date.now() - new Date(activeSince).getTime();
 return Math.max(0, Math.floor(diffMs / 60000));
 },

 getOverallProgress() {
 const done = AppState.learningPath.completedModules.length;
 const total = this.moduleDefinitions.length;
 return total > 0 ? Math.round((done / total) * 100) : 0;
 }
 };

 // ==================== LEARNING COACH ENGINE ====================
 const LearningCoachEngine = {
 ensureState() {
 if (!AppState.coachState || typeof AppState.coachState !== 'object') {
 AppState.coachState = StateFactory.createCoachState();
 }
 if (!AppState.coachState.rhythmSchedule) AppState.coachState.rhythmSchedule = {};
 if (!Array.isArray(AppState.coachState.recentErrors)) AppState.coachState.recentErrors = [];
 if (!Array.isArray(AppState.coachState.confidenceMismatches)) AppState.coachState.confidenceMismatches = [];
 if (!AppState.coachState.dailyPlanState) {
 AppState.coachState.dailyPlanState = { date: '', items: [], completedIds: [] };
 }
 if (!Array.isArray(AppState.coachState.dailyPlanState.items)) AppState.coachState.dailyPlanState.items = [];
 if (!Array.isArray(AppState.coachState.dailyPlanState.completedIds)) AppState.coachState.dailyPlanState.completedIds = [];
 if (!AppState.learningAnalytics || typeof AppState.learningAnalytics !== 'object') {
 AppState.learningAnalytics = StateFactory.createLearningAnalytics();
 }
 if (!Array.isArray(AppState.learningAnalytics.rolling14d)) AppState.learningAnalytics.rolling14d = [];
 if (!Array.isArray(AppState.learningAnalytics.riskFlags)) AppState.learningAnalytics.riskFlags = [];
 if (!Array.isArray(AppState.learningAnalytics.examWeakDomains)) AppState.learningAnalytics.examWeakDomains = [];

 const nowIso = new Date().toISOString();
 ECGDatabase.getAllRhythms().forEach(rhythm => {
 if (!AppState.coachState.rhythmSchedule[rhythm.id]) {
 AppState.coachState.rhythmSchedule[rhythm.id] = {
 ease: 2.5,
 intervalDays: 0,
 repetitions: 0,
 nextReviewAt: nowIso,
 lastQuality: null,
 lapseCount: 0
 };
 }
 });
 },

 scoreAnswerWithConfidence(isCorrect, confidence) {
 const normalized = confidence || 'guess';
 if (isCorrect && normalized === 'sure') return 5;
 if (isCorrect && normalized === 'doubt') return 4;
 if (isCorrect && normalized === 'guess') return 3;
 if (!isCorrect && normalized === 'guess') return 2;
 if (!isCorrect && normalized === 'doubt') return 1;
 return 0;
 },

 updateSchedule(rhythmId, quality) {
 this.ensureState();
 const now = new Date();
 const schedule = AppState.coachState.rhythmSchedule[rhythmId] || {
 ease: 2.5,
 intervalDays: 0,
 repetitions: 0,
 nextReviewAt: now.toISOString(),
 lastQuality: null,
 lapseCount: 0
 };

 schedule.lastQuality = quality;
 if (quality < 3) {
 schedule.repetitions = 0;
 schedule.intervalDays = 1;
 schedule.lapseCount = (schedule.lapseCount || 0) + 1;
 } else {
 schedule.repetitions = (schedule.repetitions || 0) + 1;
 if (schedule.repetitions === 1) {
 schedule.intervalDays = 1;
 } else if (schedule.repetitions === 2) {
 schedule.intervalDays = 3;
 } else {
 schedule.intervalDays = Math.max(1, Math.round((schedule.intervalDays || 1) * (schedule.ease || 2.5)));
 }
 }

 const easeDelta = 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02);
 schedule.ease = Math.max(1.3, (schedule.ease || 2.5) + easeDelta);
 const next = new Date(now);
 next.setDate(next.getDate() + schedule.intervalDays);
 schedule.nextReviewAt = next.toISOString();

 AppState.coachState.rhythmSchedule[rhythmId] = schedule;
 },

 registerAnswerReview(answer) {
 if (!answer || !answer.rhythmId || !answer.confidence) return;
 this.ensureState();

 const quality = this.scoreAnswerWithConfidence(!!answer.correct, answer.confidence);
 this.updateSchedule(answer.rhythmId, quality);

 if (!answer.correct) {
 AppState.coachState.recentErrors.push({
 rhythmId: answer.rhythmId,
 date: answer.answeredAt || new Date().toISOString(),
 mode: answer.mode || 'standard'
 });
 }
 if (!answer.correct && answer.confidence === 'sure') {
 AppState.coachState.confidenceMismatches.push({
 rhythmId: answer.rhythmId,
 date: answer.answeredAt || new Date().toISOString()
 });
 }

 const cut14 = Date.now() - (14 * 24 * 60 * 60 * 1000);
 AppState.coachState.recentErrors = AppState.coachState.recentErrors
 .filter(e => new Date(e.date).getTime() >= cut14);
 AppState.coachState.confidenceMismatches = AppState.coachState.confidenceMismatches
 .filter(e => new Date(e.date).getTime() >= cut14);
 },

 getOverdueItems() {
 this.ensureState();
 const now = Date.now();
 return ECGDatabase.getAllRhythms()
 .filter(r => {
 const sch = AppState.coachState.rhythmSchedule[r.id];
 return sch && new Date(sch.nextReviewAt).getTime() <= now;
 })
 .map(r => r.id);
 },

 getRecentErrors(days = 7) {
 this.ensureState();
 const cut = Date.now() - (days * 24 * 60 * 60 * 1000);
 return AppState.coachState.recentErrors.filter(e => new Date(e.date).getTime() >= cut);
 },

 buildRecoveryQueue(maxItems = 10) {
 const recent = this.getRecentErrors(7)
 .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
 const seen = new Set();
 const queue = [];
 recent.forEach(item => {
 if (!seen.has(item.rhythmId)) {
 seen.add(item.rhythmId);
 queue.push(item.rhythmId);
 }
 });
 return queue.slice(0, maxItems);
 },

 buildDailyQueue(size = 10) {
 this.ensureState();
 const unique = [];
 const seen = new Set();
 const pushUnique = (id) => {
 if (!id || seen.has(id)) return;
 seen.add(id);
 unique.push(id);
 };

 const overdue = Utils.shuffle(this.getOverdueItems());
 const overdueMin = Math.min(overdue.length, Math.ceil(size * 0.4));
 overdue.slice(0, overdueMin).forEach(pushUnique);

 const today = new Date().toISOString().slice(0, 10);
 this.getRecentErrors(1)
 .filter(e => (e.date || '').slice(0, 10) === today)
 .forEach(e => pushUnique(e.rhythmId));

 ProgressTracker.getWeakAreas().forEach(item => pushUnique(item.rhythm.id));

 const focus = (AppState.learningPath.weeklyFocus || []).map(f => f.id);
 focus.forEach(pushUnique);

 Utils.shuffle(ECGDatabase.getAllRhythms().map(r => r.id)).forEach(pushUnique);

 const queue = unique.slice(0, size);
 AppState.coachState.dailyPlanState = {
 date: today,
 items: queue,
 completedIds: []
 };
 return queue;
 },

 markCoachCompletion(rhythmIds) {
 this.ensureState();
 if (!Array.isArray(rhythmIds) || rhythmIds.length === 0) return;
 const today = new Date().toISOString().slice(0, 10);
 if (AppState.coachState.dailyPlanState.date !== today) return;
 rhythmIds.forEach(id => {
 if (AppState.coachState.dailyPlanState.items.includes(id) &&
 !AppState.coachState.dailyPlanState.completedIds.includes(id)) {
 AppState.coachState.dailyPlanState.completedIds.push(id);
 }
 });
 AppState.coach.active = false;
 AppState.coach.completed = [...new Set([...(AppState.coach.completed || []), ...rhythmIds])];
 },

 getDailyPlan() {
 this.ensureState();
 const today = new Date().toISOString().slice(0, 10);
 const plan = AppState.coachState.dailyPlanState;
 if (plan.date !== today || !Array.isArray(plan.items) || plan.items.length === 0) {
 this.buildDailyQueue(10);
 }
 return AppState.coachState.dailyPlanState;
 },

 getWeeklyFocus() {
 const overdue = this.getOverdueItems().slice(0, 5).map(id => {
 const rhythm = ECGDatabase.getRhythmById(id);
 return rhythm ? { id, name: rhythm.name, accuracy: 0 } : null;
 }).filter(Boolean);

 const weak = ProgressTracker.getWeakAreas().slice(0, 5).map(item => ({
 id: item.rhythm.id,
 name: item.rhythm.name,
 accuracy: item.accuracy
 }));

 const merged = [...overdue, ...weak];
 const seen = new Set();
 const focused = [];
 merged.forEach(item => {
 if (!seen.has(item.id)) {
 seen.add(item.id);
 focused.push(item);
 }
 });
 return focused.slice(0, 3);
 },

 getHeatmapSummary() {
 this.ensureState();
 const progress = ProgressTracker.getRhythmProgress();
 const overdueSet = new Set(this.getOverdueItems());
 const summary = { nieuw: 0, oefenen: 0, beheerst: 0, overdue: 0 };

 progress.forEach(item => {
 if (overdueSet.has(item.rhythm.id)) {
 summary.overdue++;
 } else if (item.mastered || (item.attempts >= 3 && item.accuracy >= 80)) {
 summary.beheerst++;
 } else if (item.attempts === 0) {
 summary.nieuw++;
 } else {
 summary.oefenen++;
 }
 });
 return summary;
 },

 computeRolling14d() {
 const today = new Date();
 const map = new Map();
 for (let i = 13; i >= 0; i--) {
 const d = new Date(today);
 d.setDate(today.getDate() - i);
 const key = d.toISOString().slice(0, 10);
 map.set(key, { date: key, total: 0, correct: 0, consistencySum: 0, consistencyN: 0 });
 }

 AppState.user.quizHistory.forEach(quiz => {
 const key = (quiz.date || '').slice(0, 10);
 if (!map.has(key) || !Array.isArray(quiz.answers)) return;
 const slot = map.get(key);
 quiz.answers.forEach(a => {
 slot.total++;
 if (a.correct) slot.correct++;
 if (a.confidence) {
 const c = a.confidence;
 let score = 0.5;
 if (c === 'sure') score = a.correct ? 1 : 0;
 else if (c === 'doubt') score = 0.6;
 else if (c === 'guess') score = a.correct ? 0.4 : 1;
 slot.consistencySum += score;
 slot.consistencyN++;
 }
 });
 });

 return [...map.values()].map(slot => ({
 date: slot.date,
 answered: slot.total,
 accuracy: slot.total > 0 ? Math.round((slot.correct / slot.total) * 100) : 0,
 consistency: slot.consistencyN > 0 ? Math.round((slot.consistencySum / slot.consistencyN) * 100) : 0
 }));
 },

 getRiskFlags() {
 const highSet = new Set(
 ECGDatabase.getAllRhythms()
 .filter(r => r.urgency === 'critical' || r.urgency === 'high')
 .map(r => r.id)
 );

 const last48h = this.getRecentErrors(2).filter(e => highSet.has(e.rhythmId));
 const grouped = {};
 last48h.forEach(e => {
 grouped[e.rhythmId] = (grouped[e.rhythmId] || 0) + 1;
 });

 const repeated = Object.entries(grouped)
 .filter(([, count]) => count >= 2)
 .map(([rhythmId, count]) => ({
 rhythmId,
 count,
 rhythmName: ECGDatabase.getRhythmById(rhythmId)?.name || rhythmId,
 message: `Herhaalfout ${count}x in 48 uur`
 }));

 const mismatches = (AppState.coachState.confidenceMismatches || []).slice(-3).map(m => ({
 rhythmId: m.rhythmId,
 rhythmName: ECGDatabase.getRhythmById(m.rhythmId)?.name || m.rhythmId,
 message: 'Zeker maar fout: herhaal systematische analyse.'
 }));

 return [...repeated, ...mismatches].slice(0, 5);
 },

 applyExamDomainRecommendations(examDomainStats) {
 if (!Array.isArray(examDomainStats)) return;
 const weakDomains = examDomainStats
 .filter(d => d.total > 0)
 .sort((a, b) => a.accuracy - b.accuracy)
 .slice(0, 3)
 .map(d => d.cat);
 AppState.learningAnalytics.examWeakDomains = weakDomains;
 },

syncAnalytics() {
this.ensureState();
AppState.learningAnalytics.rolling14d = this.computeRolling14d();
AppState.learningAnalytics.riskFlags = this.getRiskFlags();
}
};

const VisualValidationEngine = {
defaultTestRhythms: ['sinus_normal', 'atrial_fibrillation', 'rbbb', 'lbbb', 'vtach_monomorphic'],

clamp(value, min, max) {
return Math.min(max, Math.max(min, value));
},

computeNoiseEnergy(profile) {
const muscle = Number(profile?.muscleNoise || 0);
const baseline = Number(profile?.baselineWander || 0);
const powerline = Number(profile?.powerlineNoise || 0);
return Math.sqrt((muscle * muscle) + (baseline * baseline) + (powerline * powerline));
},

computeArtifactContrast(speed, gain, zoom) {
const none = ECGRenderer.getArtifactProfile('none', speed, gain, zoom);
const low = ECGRenderer.getArtifactProfile('low', speed, gain, zoom);
const medium = ECGRenderer.getArtifactProfile('medium', speed, gain, zoom);
const eNone = this.computeNoiseEnergy(none);
const eLow = this.computeNoiseEnergy(low);
const eMed = this.computeNoiseEnergy(medium);
const noneToLowPct = eNone >= 0.0001 ? Math.round(((eLow - eNone) / eNone) * 100) : Math.round(eLow * 1000);
const lowToMediumPct = eLow >= 0.0001 ? Math.round(((eMed - eLow) / eLow) * 100) : Math.round(eMed * 1000);
return {
none,
low,
medium,
energy: { none: eNone, low: eLow, medium: eMed },
noneToLowPct,
lowToMediumPct,
ok: noneToLowPct >= 12 && lowToMediumPct >= 12
};
},

sampleLeadSeries(rhythmId, lead, heartRate = 72, samples = 900) {
const out = new Array(samples);
const bpm = Math.max(20, Number(heartRate) || 72);
const beatSeconds = Math.max(0.3, 60 / bpm);
for (let i = 0; i < samples; i++) {
const t = i / samples;
const phase = (t * 2.6) % 1;
out[i] = ECGRenderer.generateWaveformPoint(rhythmId, phase, {
amplitude: 1,
heartRate: bpm,
lead,
time: t * beatSeconds * 2.6
});
}
return out;
},

correlation(a, b) {
const n = Math.min(a.length, b.length);
if (n < 4) return 1;
let sumA = 0;
let sumB = 0;
for (let i = 0; i < n; i++) {
sumA += a[i];
sumB += b[i];
}
const meanA = sumA / n;
const meanB = sumB / n;
let num = 0;
let denA = 0;
let denB = 0;
for (let i = 0; i < n; i++) {
const da = a[i] - meanA;
const db = b[i] - meanB;
num += da * db;
denA += da * da;
denB += db * db;
}
const den = Math.sqrt(denA * denB);
if (!Number.isFinite(den) || den <= 1e-9) return 1;
return num / den;
},

evaluateLeadDistinctiveness(rhythmId, threshold = 0.92) {
const pairs = [
['II', 'aVR'],
['II', 'V1'],
['V1', 'V6'],
['I', 'III'],
['aVL', 'aVF']
];
const values = [];
pairs.forEach(([a, b]) => {
const seriesA = this.sampleLeadSeries(rhythmId, a);
const seriesB = this.sampleLeadSeries(rhythmId, b);
const corr = Math.abs(this.correlation(seriesA, seriesB));
values.push({ pair: `${a}-${b}`, corr: Math.round(corr * 1000) / 1000 });
});
const pairsBelowThreshold = values.filter(v => v.corr < threshold).length;
const minCorrelation = values.length ? Math.min(...values.map(v => v.corr)) : 1;
return {
pairs: values,
pairsBelowThreshold,
minCorrelation,
ok: pairsBelowThreshold >= 4 && minCorrelation < threshold
};
},

evaluateOverlayRhythm(rhythmId) {
const fid = ECGRenderer.getBeatFiducials(rhythmId, 72);
const invalidExpected = new Set(['vfib', 'asystole', 'pea']);
if (invalidExpected.has(rhythmId)) {
return {
valid: fid.valid,
segments: Array.isArray(fid.segments) ? fid.segments.length : 0,
reason: fid.reason || '',
ok: fid.valid === false
};
}
const segmentIds = (fid.segments || []).map(s => s.id);
const rhythm = ECGDatabase.getRhythmById(rhythmId);
const isAF = rhythmId === 'atrial_fibrillation';
const isVT = rhythmId.includes('vtach');
let expected = ['QRS'];
if (!isAF && !isVT) expected = ['PR', 'QRS', 'QT'];
if (isAF) expected = ['QRS', 'QT'];
const hasExpected = expected.every(id => segmentIds.includes(id));
const anchorOk = Number.isFinite(fid.qrsStartPhase) && fid.qrsStartPhase >= 0.08 && fid.qrsStartPhase <= 0.75;
return {
valid: fid.valid,
segments: segmentIds.length,
segmentIds,
reason: fid.reason || '',
ok: fid.valid && hasExpected && anchorOk
};
},

runQuizConsistencyCheck(sampleCount = 10) {
const total = Math.max(1, parseInt(sampleCount, 10) || 10);
const rhythms = ECGDatabase.getAllRhythms();
if (!Array.isArray(rhythms) || rhythms.length === 0 || typeof QuizEngine?.buildQuestionPayload !== 'function') {
return {
ok: false,
sampleCount: total,
generated: 0,
invalid: total,
leadHints: 0
};
}
const quizStub = {
mode: 'standard',
moduleId: 'module_1',
currentQuestion: 0,
totalQuestions: total,
questionTypeMix: AppState.quiz?.questionTypeMix || { recognition: 0.5, differential: 0.3, first_action: 0.2 }
};
let generated = 0;
let invalid = 0;
let leadHints = 0;
for (let i = 0; i < total; i++) {
const rhythm = rhythms[i % rhythms.length];
const payload = QuizEngine.buildQuestionPayload(quizStub, rhythm, 'recognition');
generated++;
if (!payload || !payload.visualContext) {
invalid++;
continue;
}
const focusLead = payload.visualContext.defaultFocusLead;
const keyLeads = Array.isArray(payload.visualContext.keyLeads) ? payload.visualContext.keyLeads : [];
if (keyLeads.length > 0) leadHints++;
if (!ECGRenderer.LEAD_ORDER.includes(focusLead)) invalid++;
}
return {
ok: invalid === 0 && generated === total,
sampleCount: total,
generated,
invalid,
leadHints
};
},

runMonitorSuite() {
if (!AppState.monitorValidation) {
AppState.monitorValidation = StateFactory.createMonitorValidation();
}
const speed = Number(AppState.monitor?.speed) || 25;
const gain = Number(AppState.monitor?.amplitude) || 1;
const zoom = Number(AppState.monitor?.zoom) || 1;
const configured = Array.isArray(AppState.monitorValidation.testRhythms) ? AppState.monitorValidation.testRhythms.filter(id => !!ECGDatabase.getRhythmById(id)) : [];
const testRhythms = configured.length ? configured : [...this.defaultTestRhythms];
const artifact = this.computeArtifactContrast(speed, gain, zoom);
const quizCheck = this.runQuizConsistencyCheck(10);
 const perRhythm = testRhythms.map(id => ({
 id,
 lead: this.evaluateLeadDistinctiveness(id, 0.92)
 }));
 const leadDistinctivenessOk = perRhythm.every(item => item.lead.ok);
 const result = {
 testedAt: new Date().toISOString(),
 testRhythms,
 artifactContrastOk: artifact.ok,
 leadDistinctivenessOk,
 overlayBeatLockOk: 'n/a',
 quizLeadConsistencyOk: quizCheck.ok,
 artifact,
 quizCheck,
 perRhythm
};
AppState.monitorValidation.enabled = true;
AppState.monitorValidation.lastRun = result.testedAt;
AppState.monitorValidation.results = result;
return result;
}
};

const DiagnosticsEngine = {
 runBindingsCheck() {
 const requiredMethods = [
 'startQuickQuiz', 'startCriticalQuiz', 'startQuiz', 'startModulePractice',
 'startCoachSession', 'showPrerequisiteHelp', 'toggleMonitor', 'toggleMonitorFreeze',
 'toggleMonitorAdvanced', 'toggleMonitorRhythmPanel',
 'setMonitorRhythm', 'setMonitorLead', 'setMonitorArtifact', 'setMonitorRhythmSearch',
 'setMonitorRhythmCategory', 'toggleMonitorLeadPad',
 'setQuizFocusLead', 'toggleQuizCalibrationDetails',
 'openSystematicDrill',
 'showRhythmDetail', 'startCase', 'selectCaseAnswer', 'nextCaseQuestion',
 'switchACLSTab', 'switchDrugTab', 'switchCriteriaTab', 'runDiagnostics'
 ];
 const missingMethods = requiredMethods.filter(name => typeof ECGApp[name] !== 'function');

 const invalidOnclick = [];
 Utils.$$('[onclick]').forEach((node, index) => {
 const handler = node.getAttribute('onclick') || '';
 const matches = [...handler.matchAll(/ECGApp\.([A-Za-z0-9_]+)/g)];
 matches.forEach(match => {
 const method = match[1];
 if (typeof ECGApp[method] !== 'function') {
 const anchor = `${node.tagName.toLowerCase()}${node.id ? `#${node.id}` : `@${index}`}`;
 invalidOnclick.push(`${method} (${anchor})`);
 }
 });
 });

 return {
 ok: missingMethods.length === 0 && invalidOnclick.length === 0,
 missingMethods,
 invalidOnclick
 };
 },

 runNavigationCheck() {
 const missingSections = [];
 const navSections = [];
 Utils.$$('.nav-item[data-section]').forEach(item => {
 const sectionId = item.dataset.section;
 navSections.push(sectionId);
 if (!Navigation.sections[sectionId]) {
 missingSections.push(sectionId);
 }
 });

 const unlinkedSections = Object.keys(Navigation.sections)
 .filter(id => !navSections.includes(id));

 return {
 ok: missingSections.length === 0 && unlinkedSections.length === 0,
 missingSections,
 unlinkedSections
 };
 },

 runMedicalCoverageCheck() {
 const coverage = MedicalContentAudit.validateCoverage();
 const sourceCoverageOk = coverage.missingRhythm === 0 && coverage.missingQuestions === 0 && coverage.invalidUrls.length === 0 && (coverage.sourceFieldIssues || 0) === 0 && (coverage.rhythmDepthIssues || 0) === 0 && (coverage.caseMetaMissing || 0) === 0 && (coverage.caseTypeViolations || 0) === 0 && (coverage.sectionClaimIssues || 0) === 0 && (coverage.conflictPresentationIssues || 0) === 0;
 return {
 ok: sourceCoverageOk,
 ...coverage
 };
 },

 runQuizVariationCheck() {
 const allRhythms = ECGDatabase.getAllRhythms();
 const quality = AppState.quizQuality || {};
 const repeatWindow = Math.max(1, parseInt(quality.repeatGuardWindow, 10) || 5);
 const diversityWindow = Math.max(repeatWindow, parseInt(quality.diversityWindow, 10) || 10);
 const maxCategoryShare = Math.max(0.1, Math.min(0.9, Number(quality.maxCategoryShare) || 0.4));
 const minUniqueTarget = Math.round((Number(quality.minUniqueRatioTarget) || 0.75) * 100);
 const runs = 10;
 const questionsPerRun = 20;

 if (!allRhythms.length) {
 return {
 ok: false,
 sampleAnswers: 0,
 uniqueRhythms: 0,
 uniqueRatio: 0,
 immediateRepeats: 0,
 minUniqueRatio: 0,
 target: minUniqueTarget
 };
 }

 let immediateRepeats = 0;
 const allAsked = [];
 const runRatios = [];

 for (let run = 0; run < runs; run++) {
 const asked = [];
 const usage = {};

 for (let i = 0; i < questionsPerRun; i++) {
 const recentIds = asked.slice(-repeatWindow);
 let candidates = allRhythms.filter(r => !recentIds.includes(r.id));
 if (!candidates.length) candidates = [...allRhythms];

 const recentWindowIds = asked.slice(-diversityWindow);
 const categoryCounts = {};
 recentWindowIds.forEach(id => {
 const rhythm = ECGDatabase.getRhythmById(id);
 if (!rhythm?.category) return;
 categoryCounts[rhythm.category] = (categoryCounts[rhythm.category] || 0) + 1;
 });
 const maxCategoryCount = Math.max(1, Math.floor(diversityWindow * maxCategoryShare));
 const balanced = candidates.filter(r => (categoryCounts[r.category] || 0) < maxCategoryCount);
 if (balanced.length) candidates = balanced;

 let minUsage = Infinity;
 candidates.forEach(c => {
 const count = usage[c.id] || 0;
 if (count < minUsage) minUsage = count;
 });
 const leastUsed = candidates.filter(c => (usage[c.id] || 0) === minUsage);
 const pickPool = leastUsed.length ? leastUsed : candidates;
 const chosen = pickPool[Math.floor(Math.random() * pickPool.length)];
 if (!chosen) continue;

 asked.push(chosen.id);
 allAsked.push(chosen.id);
 usage[chosen.id] = (usage[chosen.id] || 0) + 1;

 if (asked.length > 1 && asked[asked.length - 1] === asked[asked.length - 2]) {
 immediateRepeats++;
 }
 }

 const runUnique = new Set(asked).size;
 runRatios.push(asked.length ? Math.round((runUnique / asked.length) * 100) : 0);
 }

 const unique = new Set(allAsked);
 const uniqueRatio = runRatios.length
 ? Math.round(runRatios.reduce((sum, ratio) => sum + ratio, 0) / runRatios.length)
 : 0;
 const minUniqueRatio = runRatios.length ? Math.min(...runRatios) : 0;

 return {
 ok: immediateRepeats === 0 && minUniqueRatio >= minUniqueTarget,
 sampleAnswers: allAsked.length,
 uniqueRhythms: unique.size,
 uniqueRatio,
 minUniqueRatio,
 target: minUniqueTarget,
 immediateRepeats
 };
 },

runMonitorSanityCheck() {
const issues = [];
 const allowedSpeed = [12.5, 25, 50];
 const allowedAmp = [0.5, 1, 2];
 const allowedLead = ECGRenderer.LEAD_ORDER || ['II'];
 const allowedArtifact = ['none', 'low', 'medium'];
 if (!allowedSpeed.includes(Number(AppState.monitor.speed))) {
 issues.push(`Onverwachte snelheid: ${AppState.monitor.speed}`);
 }
 if (!allowedAmp.includes(Number(AppState.monitor.amplitude))) {
 issues.push(`Onverwachte gain: ${AppState.monitor.amplitude}`);
 }
 if (!allowedLead.includes(AppState.monitor.lead || 'II')) {
 issues.push(`Onverwachte lead: ${AppState.monitor.lead}`);
 }
 if (!allowedArtifact.includes(AppState.monitor.artifactLevel || 'none')) {
 issues.push(`Onverwacht artifactniveau: ${AppState.monitor.artifactLevel}`);
 }
 if (typeof AppState.monitor.freezeFrame !== 'boolean') {
 issues.push('freezeFrame moet boolean zijn.');
 }
 const monitorUi = AppState.monitor.ui || {};
 if (typeof monitorUi.advancedOpen !== 'boolean') {
 issues.push('monitor.ui.advancedOpen moet boolean zijn.');
 }
 if (typeof monitorUi.rhythmPanelOpen !== 'boolean') {
 issues.push('monitor.ui.rhythmPanelOpen moet boolean zijn.');
 }
 if (typeof monitorUi.showLeadPad !== 'boolean') {
 issues.push('monitor.ui.showLeadPad moet boolean zijn.');
 }
 const validCategory = monitorUi.rhythmCategory === 'all' || Object.prototype.hasOwnProperty.call(ECGDatabase.categories, monitorUi.rhythmCategory);
 if (!validCategory) {
 issues.push(`monitor.ui.rhythmCategory ongeldig: ${monitorUi.rhythmCategory}`);
 }
 if (!ECGDatabase.getRhythmById(AppState.monitor.currentRhythm)) {
 issues.push(`Onbekend monitorritme: ${AppState.monitor.currentRhythm}`);
 }
 if (AppState.currentSection !== 'monitor' && ECGRenderer.activeCanvases.has('monitorCanvas')) {
 issues.push('Monitorcanvas actief buiten monitorsectie.');
 }

return {
ok: issues.length === 0,
issues
};
},

runMonitorVisualCheck() {
const suite = VisualValidationEngine.runMonitorSuite();
const issues = [];
if (!suite.artifactContrastOk) {
issues.push(`Artifactcontrast te laag: none->low ${suite.artifact.noneToLowPct}% en low->medium ${suite.artifact.lowToMediumPct}% (doel: >=12%).`);
}
if (!suite.leadDistinctivenessOk) {
const firstFail = (suite.perRhythm || []).find(r => !r.lead.ok);
if (firstFail) {
issues.push(`Lead-differentiatie onvoldoende bij ${firstFail.id}: ${firstFail.lead.pairsBelowThreshold}/5 leadparen onder correlatiedrempel.`);
} else {
issues.push('Lead-differentiatie onvoldoende (onbekende oorzaak).');
}
}
if (!suite.quizLeadConsistencyOk) {
issues.push(`Quiz lead-consistentiecheck faalt (${suite.quizCheck?.invalid ?? '?'} ongeldige payloads op ${suite.quizCheck?.sampleCount ?? 10}).`);
}
return {
ok: issues.length === 0,
issues,
...suite
};
},

runQuick() {
const binding = this.runBindingsCheck();
const navigation = this.runNavigationCheck();
const monitor = this.runMonitorSanityCheck();
const scoreParts = [binding.ok, navigation.ok, monitor.ok];
const score = Math.round((scoreParts.filter(Boolean).length / scoreParts.length) * 100);
const scoreBand = score >= 90 ? 'Groen' : score >= 70 ? 'Oranje' : 'Rood';
const previous = AppState.diagnostics || {};
const result = {
lastRunAt: new Date().toISOString(),
bindingIssues: [...binding.missingMethods, ...binding.invalidOnclick],
sectionIssues: [
...navigation.missingSections.map(i => `Ontbrekende nav-section: ${i}`),
...navigation.unlinkedSections.map(i => `Zonder sidebar-link: ${i}`)
],
sourceCoverage: previous.sourceCoverage || null,
variationMetrics: previous.variationMetrics || null,
monitorHealth: monitor,
monitorVisual: previous.monitorVisual || null,
score,
scoreBand
};
AppState.diagnostics = result;
if (AppState.runtime?.diagnostics) {
AppState.runtime.diagnostics.quickLastRunAt = result.lastRunAt;
}
return {
result,
checks: { binding, navigation, monitor }
};
},

runFull() {
const binding = this.runBindingsCheck();
const navigation = this.runNavigationCheck();
const coverage = this.runMedicalCoverageCheck();
const variation = this.runQuizVariationCheck();
const monitor = this.runMonitorSanityCheck();
const visual = this.runMonitorVisualCheck();
const scoreParts = [binding.ok, navigation.ok, coverage.ok, variation.ok, monitor.ok, visual.ok];
const score = Math.round((scoreParts.filter(Boolean).length / scoreParts.length) * 100);
const scoreBand = score >= 90 ? 'Groen' : score >= 70 ? 'Oranje' : 'Rood';

 const result = {
 lastRunAt: new Date().toISOString(),
 bindingIssues: [...binding.missingMethods, ...binding.invalidOnclick],
 sectionIssues: [
 ...navigation.missingSections.map(i => `Ontbrekende nav-section: ${i}`),
 ...navigation.unlinkedSections.map(i => `Zonder sidebar-link: ${i}`)
 ],
sourceCoverage: coverage,
variationMetrics: variation,
monitorHealth: monitor,
monitorVisual: visual,
score,
scoreBand
};

 AppState.diagnostics = result;
 if (AppState.runtime?.diagnostics) {
 AppState.runtime.diagnostics.fullLastRunAt = result.lastRunAt;
 AppState.runtime.diagnostics.fullResultCache = result;
 }
return {
result,
checks: { binding, navigation, coverage, variation, monitor, visual }
};
},

runAll() {
return this.runFull();
}
};

 // ==================== ADDITIONAL SECTION RENDERERS ====================
 
 // Add to Sections object
 Sections.renderCoach = function(container) {
 LearningCoachEngine.ensureState();
 LearningCoachEngine.syncAnalytics();
 const plan = LearningCoachEngine.getDailyPlan();
 const overdueIds = LearningCoachEngine.getOverdueItems();
 const recoveryIds = LearningCoachEngine.buildRecoveryQueue(10);
 const weak = ProgressTracker.getWeakAreas().slice(0, 3);
 const completionPct = plan.items.length > 0
 ? Math.round((plan.completedIds.length / plan.items.length) * 100)
 : 0;

 container.innerHTML = `
 <div class="card mb-2">
 <div class="card-header">
 <h3 class="card-title"> Leercoach</h3>
 </div>
 <div class="card-body">
 <div class="info-box info mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Vandaag oefenen (adaptief)</h4>
 <p>De leercoach combineert overdue ritmes, recente fouten en zwakke gebieden. Richtlijnmodus: ERC/ESC default; volg lokaal protocol.</p>
 </div>
 </div>
 <div class="vitals-grid">
 <div class="vital-card">
 <div class="vital-card-label">Dagplan</div>
 <div class="vital-card-value text-primary">${plan.completedIds.length}/${plan.items.length}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Completion</div>
 <div class="vital-card-value text-success">${completionPct}%</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Overdue</div>
 <div class="vital-card-value text-warning">${overdueIds.length}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Herstelitems</div>
 <div class="vital-card-value text-danger">${recoveryIds.length}</div>
 </div>
 </div>
 <div class="btn-group mt-2">
<button class="btn btn-primary" onclick="ECGApp.startCoachSession('daily')">Start Coach-sessie (10)</button>
 <button class="btn btn-outline" onclick="ECGApp.startCoachSession('recovery')" ${recoveryIds.length ? '' : 'disabled'}> Start Herstelronde</button>
<button class="btn btn-outline" onclick="ECGApp.startCoachSession('sprint')">5-minuten sprint</button>
 </div>
 ${!recoveryIds.length ? '<p class="text-muted" style="font-size:0.85rem; margin-top:0.5rem;">Herstelronde wordt actief nadat je fouten hebt gemaakt in de laatste 7 dagen.</p>' : ''}
 </div>
 </div>

 <div class="grid-2">
 <div class="card">
 <div class="card-header"><h3 class="card-title"> Vandaag oefenen</h3></div>
 <div class="card-body">
 ${plan.items.length ? `
 <div class="rhythm-grid">
 ${plan.items.map(id => {
 const rhythm = ECGDatabase.getRhythmById(id);
 if (!rhythm) return '';
 const done = plan.completedIds.includes(id);
 return `<button class="rhythm-btn ${done ? 'active' : ''}" onclick="ECGApp.showRhythmDetail('${id}')">
 <span class="rhythm-indicator ${done ? 'green' : 'yellow'}"></span>
 <span>${rhythm.name}</span>
 </button>`;
 }).join('')}
 </div>
 ` : '<p class="text-muted">Nog geen dagplan beschikbaar. Start een coach-sessie.</p>'}
 </div>
 </div>
 <div class="card">
 <div class="card-header"><h3 class="card-title"> Weekfocus</h3></div>
 <div class="card-body">
 <ul class="styled-list">
 ${(LearningCoachEngine.getWeeklyFocus()).map(item => `<li>${item.name}${item.accuracy ? ` (${item.accuracy}%)` : ''}</li>`).join('')}
 </ul>
 ${weak.length ? `
 <p class="text-muted" style="margin-top:0.75rem; font-size:0.85rem;">Zwakke gebieden op basis van quizhistorie:</p>
 <ul class="styled-list">
 ${weak.map(w => `<li>${w.rhythm.name} (${w.accuracy}%)</li>`).join('')}
 </ul>
 ` : ''}
 </div>
 </div>
 </div>
 `;
 };

 // Add to Sections object
 Sections.renderLearningPath = function(container) {
 const statuses = LearningPathEngine.syncState();
 const progress = LearningPathEngine.getOverallProgress();
 const daily = LearningPathEngine.getDailyRound();
 const focus = LearningPathEngine.getWeeklyFocus();
 const current = LearningPathEngine.getCurrentModule();

 container.innerHTML = `
 ${ECGApp.getContextHelpHTML('learningPath')}
 <div class="card mb-2">
 <div class="card-header">
 <h3 class="card-title"> Leerpad (Hybride)</h3>
 </div>
 <div class="card-body">
 <div class="info-box info mb-2">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Richtlijnmodus: ERC/ESC standaard</h4>
 <p>Educatieve omgeving. Volg altijd lokale protocollen en supervisie.</p>
 </div>
 </div>
 <p class="text-muted">Huidige focus: <strong>${current?.title || 'Module 1'}</strong></p>
 <div class="progress-bar mt-1 mb-1">
 <div class="progress-fill" style="width: ${progress}%"></div>
 </div>
 <p class="text-muted" style="font-size: 0.85rem;">${progress}% voltooid * ${AppState.learningPath.completedModules.length}/${LearningPathEngine.moduleDefinitions.length} modules afgerond</p>
 </div>
 </div>

 <div class="grid-2">
 ${LearningPathEngine.moduleDefinitions.map(module => {
 const s = statuses[module.id];
 const badge = s.completed ? '<span class="badge badge-success">Voltooid</span>' : s.unlocked ? '<span class="badge badge-info">Open</span>' : '<span class="badge badge-hard">Vergrendeld</span>';
 const moduleIndex = LearningPathEngine.moduleDefinitions.findIndex(m => m.id === module.id);
 const prevStatus = moduleIndex > 0 ? statuses[LearningPathEngine.moduleDefinitions[moduleIndex - 1].id] : null;
 const prerequisiteText = prevStatus
 ? `Voltooi eerst <strong>${prevStatus.title}</strong>.`
 : 'Rond eerst eerdere module(s) af om deze vrij te spelen.';
 const lockedHint = !s.unlocked
 ? `<p class="text-muted" style="font-size: 0.8rem; margin-top: 0.5rem;"> ${prerequisiteText}</p>`
 : '';
 const corePitfalls = LearningPathEngine.getModulePitfalls(module.id).slice(0, 3);
 const corePitfallsHtml = corePitfalls.length
 ? `<div class="info-box warning mt-1">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Kernfouten</h4>
 <ul class="styled-list" style="margin-top:0.35rem;">
 ${corePitfalls.map(item => `<li>${item}</li>`).join('')}
 </ul>
 </div>
 </div>`
 : '';
 return `
 <div class="card">
 <div class="card-header">
 <h3 class="card-title">${module.icon} ${module.title}</h3>
 ${badge}
 </div>
 <div class="card-body">
 <p class="text-muted mb-2">${module.description}</p>
 <p style="font-size: 0.85rem;"> Quiz: ${s.questionStats.correct}/${s.questionStats.total} correct (${s.questionStats.accuracy}%) * Doel: ${module.requiredQuestions} vragen op ${module.requiredAccuracy}%+
 </p>
 ${module.requiredChecklistSessions ? `<p style="font-size: 0.85rem;">Checklist sessies: ${s.checklistSessions}/${module.requiredChecklistSessions}</p>` : ''}
 ${module.requiredCases ? `<p style="font-size: 0.85rem;">Cases: ${s.caseStats.done}/${module.requiredCases}</p>` : ''}
 ${corePitfallsHtml}
 <button class="btn btn-sm ${s.unlocked ? 'btn-primary' : 'btn-outline'} mt-1" onclick="ECGApp.startModulePractice('${module.id}')">
 ${s.completed ? 'Herhalen' : s.unlocked ? 'Oefen module' : 'Bekijk vrijspeel-eisen'}
 </button>
 ${lockedHint}
 </div>
 </div>
 `;
 }).join('')}
 </div>

 <div class="card mt-2">
 <div class="card-header">
 <h3 class="card-title"> Dagelijkse Klinische Ronde</h3>
 </div>
 <div class="card-body">
 <p class="text-muted">Vandaag voltooid: <strong>${daily.completedCaseIds.length}/${daily.caseIds.length}</strong></p>
 <div class="btn-group mt-1">
 ${daily.caseIds.map(caseId => {
 const c = ClinicalCases.getCaseById(caseId);
 if (!c) return '';
 const done = daily.completedCaseIds.includes(caseId);
 return `<button class="btn btn-sm ${done ? 'btn-success' : 'btn-outline'}" onclick="ECGApp.startDailyCase('${caseId}')">${done ? '&#10003;' : '&#9675;'} ${c.title}</button>`;
 }).join('')}
 </div>
 </div>
 </div>

 <div class="grid-2 mt-2">
 <div class="card">
 <div class="card-header"><h3 class="card-title"> Focus van de week</h3></div>
 <div class="card-body">
 <ul class="styled-list">
 ${focus.map(f => `<li>${f.name} ${f.accuracy > 0 ? `(${f.accuracy}%)` : '(nieuw)'}</li>`).join('')}
 </ul>
 </div>
 </div>
 <div class="card">
 <div class="card-header"><h3 class="card-title"> Examenmodus</h3></div>
 <div class="card-body">
 <p class="text-muted">20 vragen, geen hints, eindrapport per domein.</p>
 <button class="btn btn-primary" onclick="ECGApp.startQuiz('exam')">Start Examenmodus</button>
 </div>
 </div>
 </div>
 `;
 };

 Sections.renderProgress = function(container) {
 const stats = ProgressTracker.getStatistics();
 const weakAreas = ProgressTracker.getWeakAreas();
 const strongAreas = ProgressTracker.getStrongAreas();
 LearningCoachEngine.syncAnalytics();
 const heatmap = LearningCoachEngine.getHeatmapSummary();
 const trend = (AppState.learningAnalytics?.rolling14d || []).slice(-7);
 const trendAvgAccuracy = trend.length ? Math.round(trend.reduce((s, d) => s + (d.accuracy || 0), 0) / trend.length) : 0;
 const trendAvgConsistency = trend.length ? Math.round(trend.reduce((s, d) => s + (d.consistency || 0), 0) / trend.length) : 0;
 const riskFlags = AppState.learningAnalytics?.riskFlags || [];

 container.innerHTML = `
 <div class="card mb-2">
 <div class="card-header">
 <h3 class="card-title"> Voortgang Overzicht</h3>
 </div>
 <div class="card-body">
<!-- Level Progress -->
<div class="score-display" style="margin-bottom: 2rem;">
<div style="font-size: 4rem; margin-bottom: 0.5rem;">
${stats.level.level <= 5 ? '&#x1F331;' : stats.level.level <= 10 ? '&#x1F4AA;' : stats.level.level <= 20 ? '&#x1F3C5;' : '&#x1F451;'}
</div>
<h2>Niveau ${stats.level.level}</h2>
 <p class="text-muted">${stats.xp} totaal XP</p>
 <div class="progress-bar" style="max-width: 300px; margin: 1rem auto;">
 <div class="progress-fill" style="width: ${(stats.level.currentXP / stats.level.nextLevelXP) * 100}%"></div>
 </div>
 <p class="text-muted" style="font-size: 0.85rem;">
 ${stats.level.currentXP} / ${stats.level.nextLevelXP} XP naar niveau ${stats.level.level + 1}
 </p>
 </div>

 <!-- Stats Grid -->
 <div class="vitals-grid">
 <div class="vital-card">
 <div class="vital-card-label">Quizzen</div>
 <div class="vital-card-value text-primary">${stats.totalQuizzes}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Vragen</div>
 <div class="vital-card-value text-info">${stats.totalAnswered}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Correct</div>
 <div class="vital-card-value text-success">${stats.totalCorrect}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Nauwkeurigheid</div>
 <div class="vital-card-value ${stats.accuracy >= 80 ? 'text-success' : stats.accuracy >= 60 ? 'text-warning' : 'text-danger'}">${stats.accuracy}%</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Reeks</div>
 <div class="vital-card-value text-warning">${stats.streak}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Beheerst</div>
 <div class="vital-card-value text-primary">${stats.masteredRhythms}/${stats.totalRhythms}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Prestaties</div>
 <div class="vital-card-value text-info">${stats.achievements}/${stats.totalAchievements}</div>
 </div>
 <div class="vital-card">
 <div class="vital-card-label">Deze Week</div>
 <div class="vital-card-value text-success">${stats.quizzesThisWeek} quizzen</div>
 </div>
 </div>
 </div>
 </div>

 <div class="grid-3">
 <div class="card">
 <div class="card-header"><h3 class="card-title"> Ritme Heatmap</h3></div>
 <div class="card-body">
 <div class="vitals-grid">
 <div class="vital-card"><div class="vital-card-label">Nieuw</div><div class="vital-card-value">${heatmap.nieuw}</div></div>
 <div class="vital-card"><div class="vital-card-label">Oefenen</div><div class="vital-card-value text-warning">${heatmap.oefenen}</div></div>
 <div class="vital-card"><div class="vital-card-label">Beheerst</div><div class="vital-card-value text-success">${heatmap.beheerst}</div></div>
 <div class="vital-card"><div class="vital-card-label">Overdue</div><div class="vital-card-value text-danger">${heatmap.overdue}</div></div>
 </div>
 </div>
 </div>
 <div class="card">
 <div class="card-header"><h3 class="card-title"> 14-dagen Trend</h3></div>
 <div class="card-body">
 <p class="text-muted">Laatste 7 dagen samengevat</p>
 <div style="display:grid; gap:0.5rem;">
 <div style="display:flex; justify-content:space-between;"><span>Gem. accuratesse</span><strong>${trendAvgAccuracy}%</strong></div>
 <div style="display:flex; justify-content:space-between;"><span>Consistentie (zekerheid)</span><strong>${trendAvgConsistency}%</strong></div>
 <div style="display:flex; justify-content:space-between;"><span>Beantwoorde items</span><strong>${trend.reduce((s, d) => s + (d.answered || 0), 0)}</strong></div>
 </div>
 </div>
 </div>
 <div class="card">
 <div class="card-header"><h3 class="card-title"> Risicoprofiel</h3></div>
 <div class="card-body">
 ${riskFlags.length ? `
 <ul class="styled-list">
 ${riskFlags.map(r => `<li><strong>${r.rhythmName}</strong>: ${r.message}</li>`).join('')}
 </ul>
 ` : '<p class="text-muted">Geen actuele risicoflags gevonden.</p>'}
 </div>
 </div>
 </div>

 <div class="grid-2">
 <!-- Category Performance -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Prestatie per Categorie</h3>
 </div>
 <div class="card-body">
 ${Object.entries(stats.categoryStats).map(([catId, catStats]) => {
 const category = ECGDatabase.categories[catId];
 const accuracy = catStats.total > 0 ? Math.round((catStats.correct / catStats.total) * 100) : 0;
 return `
 <div style="margin-bottom: 1rem;">
 <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
 <span>${category?.icon || ''} ${category?.name || catId}</span>
 <span class="${accuracy >= 80 ? 'text-success' : accuracy >= 60 ? 'text-warning' : 'text-danger'}">
 ${accuracy}% (${catStats.correct}/${catStats.total})
 </span>
 </div>
 <div class="progress-bar" style="height: 8px;">
 <div class="progress-fill ${accuracy >= 80 ? '' : accuracy >= 60 ? 'warning' : 'danger'}" style="width: ${accuracy}%"></div>
 </div>
 </div>
 `;
 }).join('')}
 </div>
 </div>

 <!-- Difficulty Performance -->
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Prestatie per Moeilijkheid</h3>
 </div>
 <div class="card-body">
 ${Object.entries(stats.difficultyStats).map(([diff, diffStats]) => {
 const accuracy = diffStats.total > 0 ? Math.round((diffStats.correct / diffStats.total) * 100) : 0;
 const labels = { easy: 'Makkelijk', medium: 'Gemiddeld', hard: 'Moeilijk' };
 return `
 <div style="margin-bottom: 1.5rem;">
 <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
 <span class="badge ${Utils.getDifficultyBadge(diff)}">${labels[diff]}</span>
 <span>${accuracy}% (${diffStats.correct}/${diffStats.total})</span>
 </div>
 <div class="progress-bar" style="height: 8px;">
 <div class="progress-fill" style="width: ${accuracy}%"></div>
 </div>
 </div>
 `;
 }).join('')}

 ${weakAreas.length > 0 ? `
 <div class="info-box warning mt-3">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Aandachtspunten</h4>
 <p>Deze ritmes verdienen extra oefening:</p>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 ${weakAreas.map(w => `<li>${w.rhythm.name} (${w.accuracy}%)</li>`).join('')}
 </ul>
 </div>
 </div>
 ` : ''}

 ${strongAreas.length > 0 ? `
 <div class="info-box success mt-3">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Sterke Punten</h4>
 <ul class="styled-list" style="margin-top: 0.5rem;">
 ${strongAreas.slice(0, 3).map(s => `<li>${s.rhythm.name} (${s.accuracy}%)</li>`).join('')}
 </ul>
 </div>
 </div>
 ` : ''}
 </div>
 </div>
 </div>

 <!-- Mastered Rhythms -->
 <div class="card mt-2">
 <div class="card-header">
 <h3 class="card-title"> Beheerste Ritmes (${stats.masteredRhythms}/${stats.totalRhythms})</h3>
 </div>
 <div class="card-body">
 <div class="progress-bar mb-3">
 <div class="progress-fill" style="width: ${(stats.masteredRhythms / stats.totalRhythms) * 100}%"></div>
 </div>
 ${AppState.user.masteredRhythms.length > 0 ? `
 <div class="rhythm-grid">
 ${AppState.user.masteredRhythms.map(rhythmId => {
 const rhythm = ECGDatabase.getRhythmById(rhythmId);
 if (!rhythm) return '';
 return `
 <button class="rhythm-btn" onclick="ECGApp.showRhythmDetail('${rhythmId}')">
 <span class="rhythm-indicator green"></span>
 <span>${rhythm.name}</span>
 <span>*</span>
 </button>
 `;
 }).join('')}
 </div>
 ` : `
 <p class="text-muted text-center">Nog geen ritmes beheerst. Blijf oefenen!</p>
 `}
 </div>
 </div>
 `;
 };

 Sections.renderAchievements = function(container) {
 const unlocked = Achievements.getUnlocked();
 const locked = Achievements.getLocked();

 container.innerHTML = `
 <div class="card mb-2">
 <div class="card-header">
 <h3 class="card-title"> Prestaties (${unlocked.length}/${Achievements.definitions.length})</h3>
 </div>
 <div class="card-body">
 <div class="progress-bar mb-3">
 <div class="progress-fill" style="width: ${(unlocked.length / Achievements.definitions.length) * 100}%"></div>
 </div>
 <p class="text-muted text-center mb-3"> Totaal verdiend: ${unlocked.reduce((sum, a) => sum + a.xpReward, 0)} XP via prestaties
 </p>
 </div>
 </div>

 <!-- Unlocked Achievements -->
 ${unlocked.length > 0 ? `
 <div class="card mb-2">
 <div class="card-header">
 <h3 class="card-title">Behaald</h3>
 </div>
 <div class="card-body">
 <div class="grid-3">
 ${unlocked.map(achievement => `
 <div class="achievement-card unlocked">
 <div class="achievement-card-icon">${achievement.icon}</div>
 <div class="achievement-card-name">${achievement.name}</div>
 <div class="achievement-card-desc">${achievement.description}</div>
 <div class="achievement-card-reward">+${achievement.xpReward} XP</div>
 </div>
 `).join('')}
 </div>
 </div>
 </div>
 ` : ''}

 <!-- Locked Achievements -->
 ${locked.length > 0 ? `
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Nog te Behalen</h3>
 </div>
 <div class="card-body">
 <div class="grid-3">
 ${locked.map(achievement => `
 <div class="achievement-card locked">
 <div class="achievement-card-icon">*</div>
 <div class="achievement-card-name">${achievement.name}</div>
 <div class="achievement-card-desc">${achievement.description}</div>
 <div class="achievement-card-reward">+${achievement.xpReward} XP</div>
 </div>
 `).join('')}
 </div>
 </div>
 </div>
 ` : ''}
 `;
 };

 Sections.renderSettings = function(container) {
 const coverage = MedicalContentAudit.validateCoverage();
 const auditMatrixCount = MedicalContentAudit.buildAuditMatrix().length;
 const sourceCount = Object.keys(MedicalSourceRegistry).length;
 const diagnostics = AppState.diagnostics || {};
 const diagnosticsAt = diagnostics.lastRunAt
 ? diagnostics.lastRunAt.replace('T', ' ').slice(0, 19)
 : 'Nog niet uitgevoerd';
const bindingIssueCount = Array.isArray(diagnostics.bindingIssues) ? diagnostics.bindingIssues.length : 0;
const sectionIssueCount = Array.isArray(diagnostics.sectionIssues) ? diagnostics.sectionIssues.length : 0;
const visualIssueCount = Array.isArray(diagnostics.monitorVisual?.issues) ? diagnostics.monitorVisual.issues.length : 0;
const artifactDeltaLow = Number(diagnostics.monitorVisual?.artifact?.noneToLowPct || 0);
const artifactDeltaMed = Number(diagnostics.monitorVisual?.artifact?.lowToMediumPct || 0);
const diagnosticsScore = Number(diagnostics.score || 0);
const diagnosticsBand = diagnostics.scoreBand || (diagnosticsScore >= 90 ? 'Groen' : diagnosticsScore >= 70 ? 'Oranje' : 'Rood');
const diagnosticsBandClass = diagnosticsScore >= 90 ? 'text-success' : diagnosticsScore >= 70 ? 'text-warning' : 'text-danger';
 container.innerHTML = `
 <div class="card">
 <div class="card-header">
 <h3 class="card-title"> Instellingen</h3>
 </div>
 <div class="card-body">
 <div class="info-box info mb-3">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <h4>Richtlijnmodus</h4>
 <p>ERC/ESC standaard actief. Volg altijd lokale protocollen bij klinische besluitvorming.</p>
 </div>
 </div>

 <!-- Profile Management -->
 <h4 style="margin-bottom: 1rem;"> Profielen</h4>
 <div class="settings-group">
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Actief profiel</div>
 <div class="setting-desc">Huidig profiel: <strong>${AppState.profile?.name || 'Standaard'}</strong></div>
 </div>
 <button class="btn btn-outline btn-sm" onclick="ECGApp.switchProfile()"> Wisselen
 </button>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Nieuw profiel</div>
 <div class="setting-desc">Maak een extra lokaal profiel met eigen voortgang</div>
 </div>
 <button class="btn btn-outline btn-sm" onclick="ECGApp.createProfile()">
 Aanmaken
 </button>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Profiel hernoemen</div>
 <div class="setting-desc">Pas de naam van het actieve profiel aan</div>
 </div>
 <button class="btn btn-outline btn-sm" onclick="ECGApp.renameCurrentProfile()"> Hernoemen
 </button>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Profiel verwijderen</div>
 <div class="setting-desc">Verwijder alleen het actieve profiel (minimaal 1 profiel blijft bestaan)</div>
 </div>
 <button class="btn btn-danger btn-sm" onclick="ECGApp.deleteCurrentProfile()"> Verwijderen
 </button>
 </div>
 </div>

 <!-- Quiz Settings -->
 <h4 style="margin-bottom: 1rem;"> Quiz Instellingen</h4>
 <div class="settings-group">
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Standaard aantal vragen</div>
 <div class="setting-desc">Aantal vragen bij een standaard quiz</div>
 </div>
 <select onchange="ECGApp.updateSetting('defaultQuizCount', this.value)">
 <option value="5" ${AppState.settings?.defaultQuizCount === 5 ? 'selected' : ''}>5</option>
 <option value="10" ${AppState.settings?.defaultQuizCount === 10 || !AppState.settings?.defaultQuizCount ? 'selected' : ''}>10</option>
 <option value="20" ${AppState.settings?.defaultQuizCount === 20 ? 'selected' : ''}>20</option>
 </select>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Timer (tijdsdruk)</div>
 <div class="setting-desc">Seconden per vraag in tijdsdrukmodus</div>
 </div>
 <select onchange="ECGApp.updateSetting('timerSeconds', this.value)">
 <option value="20" ${AppState.settings?.timerSeconds === 20 ? 'selected' : ''}>20s</option>
 <option value="30" ${AppState.settings?.timerSeconds === 30 || !AppState.settings?.timerSeconds ? 'selected' : ''}>30s</option>
 <option value="45" ${AppState.settings?.timerSeconds === 45 ? 'selected' : ''}>45s</option>
 <option value="60" ${AppState.settings?.timerSeconds === 60 ? 'selected' : ''}>60s</option>
 </select>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Examiner Mode</div>
 <div class="setting-desc">Toon bij foute antwoorden direct de relevante guideline-paragraaf</div>
 </div>
 <select onchange="ECGApp.updateSetting('examinerMode', this.value)">
 <option value="true" ${AppState.settings?.examinerMode !== false ? 'selected' : ''}>Aan</option>
 <option value="false" ${AppState.settings?.examinerMode === false ? 'selected' : ''}>Uit</option>
 </select>
 </div>
 </div>

 <!-- UX Settings -->
 <h4 style="margin: 2rem 0 1rem;"> UX Instellingen</h4>
 <div class="settings-group">
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Contextuele hulp</div>
 <div class="setting-desc">Toon hulptekst per sectie met wat je als volgende stap moet doen</div>
 </div>
 <select onchange="ECGApp.updateSetting('contextualHelp', this.value)">
 <option value="true" ${AppState.ui?.contextualHelp !== false ? 'selected' : ''}>Aan</option>
 <option value="false" ${AppState.ui?.contextualHelp === false ? 'selected' : ''}>Uit</option>
 </select>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Snelle start opnieuw tonen</div>
 <div class="setting-desc">Reset de onboardingkaart op het dashboard</div>
 </div>
 <button class="btn btn-outline btn-sm" onclick="ECGApp.resetOnboarding()">
 Reset onboarding
 </button>
 </div>
 </div>

 <!-- Monitor Settings -->
 <h4 style="margin: 2rem 0 1rem;"> Monitor Instellingen</h4>
 <div class="settings-group">
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">ECG Snelheid</div>
 <div class="setting-desc">Papiersnelheid in mm/s</div>
 </div>
 <select onchange="ECGApp.updateSetting('ecgSpeed', this.value)">
 <option value="12.5" ${AppState.monitor?.speed === 12.5 ? 'selected' : ''}>12.5 mm/s</option>
 <option value="25" ${AppState.monitor?.speed === 25 || !AppState.monitor?.speed ? 'selected' : ''}>25 mm/s</option>
 <option value="50" ${AppState.monitor?.speed === 50 ? 'selected' : ''}>50 mm/s</option>
 </select>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">ECG Amplitude</div>
 <div class="setting-desc">Signaalversterking</div>
 </div>
 <select onchange="ECGApp.updateSetting('ecgAmplitude', this.value)">
 <option value="0.5" ${AppState.monitor?.amplitude === 0.5 ? 'selected' : ''}>0.5x</option>
 <option value="1" ${AppState.monitor?.amplitude === 1 || !AppState.monitor?.amplitude ? 'selected' : ''}>1x</option>
 <option value="2" ${AppState.monitor?.amplitude === 2 ? 'selected' : ''}>2x</option>
 </select>
 </div>
 </div>

 <!-- Data Management -->
 <h4 style="margin: 2rem 0 1rem;"> Data Beheer</h4>
 <div class="settings-group">
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Exporteer Voortgang</div>
 <div class="setting-desc">Download voortgang van het actieve profiel als JSON bestand</div>
 </div>
 <button class="btn btn-outline btn-sm" onclick="ECGApp.exportData()"> Exporteren
 </button>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Importeer Voortgang</div>
 <div class="setting-desc">Herstel back-up in het actieve profiel</div>
 </div>
 <button class="btn btn-outline btn-sm" onclick="ECGApp.importData()"> Importeren
 </button>
 </div>
 <div class="setting-item">
 <div class="setting-info">
 <div class="setting-name">Reset Voortgang</div>
 <div class="setting-desc">Wis voortgang van het actieve profiel en begin opnieuw</div>
 </div>
 <button class="btn btn-danger btn-sm" onclick="ECGApp.resetProgress()"> Reset
 </button>
 </div>
 </div>

 <!-- Diagnostics -->
 <h4 style="margin: 2rem 0 1rem;"> Systeemchecks</h4>
 <div class="settings-group">
<div class="setting-item">
<div class="setting-info">
<div class="setting-name">App-check (bindings/flow/data)</div>
<div class="setting-desc">Laatste run: ${diagnosticsAt}. Score: <strong class="${diagnosticsBandClass}">${diagnosticsScore}/100 (${diagnosticsBand})</strong>. Issues: bindings ${bindingIssueCount}, navigatie ${sectionIssueCount}, visual ${visualIssueCount}. Artifact delta: ${artifactDeltaLow}% / ${artifactDeltaMed}%.</div>
</div>
<button class="btn btn-outline btn-sm" onclick="ECGApp.runDiagnostics()">
Uitvoeren
</button>
</div>
</div>
<div class="info-box ${diagnostics.monitorVisual?.artifactContrastOk && diagnostics.monitorVisual?.leadDistinctivenessOk ? 'success' : 'warning'}" style="margin-top:0.75rem;">
<div class="info-box-icon">*</div>
<div class="info-box-content">
<h4>Visual QA Scorekaart</h4>
<ul class="styled-list" style="margin-top:0.35rem;">
<li>Artifact contrast: ${diagnostics.monitorVisual?.artifactContrastOk ? 'OK' : 'Niet OK'} (${artifactDeltaLow}% / ${artifactDeltaMed}%)</li>
<li>Lead distinctiveness: ${diagnostics.monitorVisual?.leadDistinctivenessOk ? 'OK' : 'Niet OK'}</li>
<li>Quiz lead-consistentie: ${diagnostics.monitorVisual?.quizLeadConsistencyOk ? 'OK' : 'Niet OK'}</li>
</ul>
</div>
</div>

<!-- About -->
<h4 style="margin: 2rem 0 1rem;"> Over</h4>
 <div class="info-box info">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
<h4>ECG Trainer Pro v2.5</h4>
 <p>Een uitgebreide ECG leerapp voor IC/SEH verpleegkundigen en medisch professionals.</p>
 <p style="margin-top: 0.5rem;">
 <strong>Bevat:</strong> ${ECGDatabase.getAllRhythms().length} ECG ritmes, 
 ${Object.keys(ECGDatabase.categories).length} categorieën, 
 ${Achievements.definitions.length} prestaties
 </p>
 <p style="margin-top: 0.5rem; font-size: 0.85rem;" class="text-muted"> Disclaimer: Deze app is bedoeld voor educatieve doeleinden en vervangt geen lokale protocollen, supervisie of klinisch oordeel. 
 Volg altijd het geldende ziekenhuis-/ambulanceprotocol.
 </p>
 <p style="margin-top: 0.5rem; font-size: 0.85rem;" class="text-muted"> Medische inhoud laatst herzien op: <strong>${AppState.learningAnalytics?.lastReviewDate || '2026-02-16'}</strong>
 </p>
 <p style="margin-top: 0.35rem; font-size: 0.85rem;" class="text-muted">
 Brondekking quiz/cases: ritmes ${coverage.rhythmTotal - coverage.missingRhythm}/${coverage.rhythmTotal}, vragen ${coverage.caseQuestionTotal - coverage.missingQuestions}/${coverage.caseQuestionTotal}, bronnen ${sourceCount}
 </p>
 <p style="margin-top: 0.35rem; font-size: 0.85rem;" class="text-muted"> Auditmatrix items: <strong>${auditMatrixCount}</strong> (rhythm/case/ACLS/drugs/criteria)
 </p>
 </div>
 </div>
 </div>
 </div>
 `;
 };

 // ==================== ADDITIONAL APP METHODS ====================
 
 // Add settings methods to ECGApp
 ECGApp.updateSetting = function(key, value) {
 if (!AppState.settings) AppState.settings = {};

if (key === 'examinerMode') {
AppState.settings.examinerMode = value === true || value === 'true';
Storage.scheduleSave(600);
return;
}
if (key === 'contextualHelp') {
if (!AppState.ui) AppState.ui = StateFactory.createUi();
AppState.ui.contextualHelp = value === true || value === 'true';
Storage.scheduleSave(600);
if (AppState.currentSection && typeof Navigation?.renderSection === 'function') {
Navigation.renderSection(AppState.currentSection);
}
 return;
 }
 
 // Parse numeric values
 const numValue = parseFloat(value);
 AppState.settings[key] = isNaN(numValue) ? value : numValue;
 
 // Apply certain settings immediately
 if (key === 'ecgSpeed') {
 const allowed = [12.5, 25, 50];
 AppState.monitor.speed = allowed.includes(numValue) ? numValue : 25;
 } else if (key === 'ecgAmplitude') {
 const allowed = [0.5, 1, 2];
 AppState.monitor.amplitude = allowed.includes(numValue) ? numValue : 1;
 } else if (key === 'defaultQuizCount') {
 AppState.settings.defaultQuizCount = parseInt(value, 10) || 10;
 } else if (key === 'timerSeconds') {
 AppState.settings.timerSeconds = parseInt(value, 10) || 30;
 }

 if ((key === 'ecgSpeed' || key === 'ecgAmplitude') && AppState.currentSection === 'monitor') {
 Sections.renderMonitor(Utils.$('#contentArea'));
 }
 
Storage.scheduleSave(600);
};

ECGApp.resetOnboarding = function() {
if (!AppState.ui) AppState.ui = StateFactory.createUi();
AppState.ui.onboardingCompleted = false;
Storage.scheduleSave(600);
if (AppState.currentSection === 'dashboard') {
Sections.renderDashboard(Utils.$('#contentArea'));
}
 };

ECGApp.exportData = function() {
const data = {
version: '2.5.0',
exportDate: new Date().toISOString(),
profile: AppState.profile,
ui: AppState.ui,
quizQuality: AppState.quizQuality,
libraryView: AppState.libraryView,
quizView: AppState.quizView,
monitor: AppState.monitor,
user: AppState.user,
settings: AppState.settings,
learningPath: AppState.learningPath,
coachState: AppState.coachState,
learningAnalytics: AppState.learningAnalytics,
monitorValidation: AppState.monitorValidation,
diagnostics: AppState.diagnostics
};
 
 const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
 const url = URL.createObjectURL(blob);
 
 const a = document.createElement('a');
 const safeProfileName = (AppState.profile?.name || 'profiel')
 .toLowerCase()
 .replace(/[^a-z0-9]+/g, '-')
 .replace(/^-+|-+$/g, '');
 a.href = url;
 a.download = `ecg-trainer-${safeProfileName || 'profiel'}-backup-${new Date().toISOString().split('T')[0]}.json`;
 a.click();
 
 URL.revokeObjectURL(url);
 
 this.showModal('Export Voltooid', `
 <div class="info-box success">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Je voortgang is gedownload als JSON bestand.</p>
 <p class="text-muted" style="margin-top: 0.5rem;">Bewaar dit bestand veilig om later te kunnen herstellen.</p>
 </div>
 </div>
 `);
 };

 ECGApp.importData = function() {
 const input = document.createElement('input');
 input.type = 'file';
 input.accept = '.json';
 
 input.onchange = (e) => {
 const file = e.target.files[0];
 if (!file) return;
 
 const reader = new FileReader();
 reader.onload = (event) => {
 try {
 const data = JSON.parse(event.target.result);
 
 if (!data.user) {
 throw new Error('Ongeldig back-upbestand');
 }
 
 // Merge data
 if (data.profile?.name) {
 AppState.profile.name = data.profile.name;
 }
 if (data.ui) {
 AppState.ui = { ...AppState.ui, ...data.ui };
 }
 if (data.quizQuality) {
 AppState.quizQuality = { ...AppState.quizQuality, ...data.quizQuality };
 }
 if (data.libraryView) {
 AppState.libraryView = { ...StateFactory.createLibraryView(), ...AppState.libraryView, ...data.libraryView };
 }
 if (data.quizView) {
 AppState.quizView = { ...AppState.quizView, ...data.quizView };
 }
 if (data.monitor) {
 const baseMonitor = StateFactory.createMonitor();
 AppState.monitor = {
 ...baseMonitor,
 ...data.monitor,
 ui: {
 ...baseMonitor.ui,
 ...(data.monitor.ui || {})
 },
 isRunning: false,
 freezeFrame: false,
 animationId: null
 };
 }
 AppState.user = { ...AppState.user, ...data.user };
 if (data.settings) {
 AppState.settings = data.settings;
 }
 if (data.learningPath) {
 AppState.learningPath = {
 ...AppState.learningPath,
 ...data.learningPath,
 dailyRoundState: {
 ...AppState.learningPath.dailyRoundState,
 ...(data.learningPath.dailyRoundState || {})
 },
 checklistTraining: {
 ...AppState.learningPath.checklistTraining,
 ...(data.learningPath.checklistTraining || {})
 }
 };
 }
 if (data.coachState) {
 AppState.coachState = {
 ...AppState.coachState,
 ...data.coachState,
 dailyPlanState: {
 ...AppState.coachState.dailyPlanState,
 ...(data.coachState.dailyPlanState || {})
 }
 };
 }
if (data.learningAnalytics) {
AppState.learningAnalytics = {
...AppState.learningAnalytics,
...data.learningAnalytics
};
}
if (data.monitorValidation) {
AppState.monitorValidation = {
...StateFactory.createMonitorValidation(),
...AppState.monitorValidation,
...data.monitorValidation
};
}
if (data.diagnostics) {
AppState.diagnostics = {
...AppState.diagnostics,
...data.diagnostics
};
 }
 LearningPathEngine.syncState();
 LearningCoachEngine.syncAnalytics();
 MedicalContentAudit.ensureRhythmMetadata();
 MedicalContentAudit.ensureCaseQuestionSources();
 if (!AppState.learningAnalytics.lastReviewDate) {
 AppState.learningAnalytics.lastReviewDate = '2026-02-16';
 }
AppState.learningAnalytics.medicalCoverage = MedicalContentAudit.validateCoverage();
DiagnosticsEngine.runFull();

Storage.flushSave('manual');
 
 this.showModal('Import Voltooid', `
 <div class="info-box success">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Je voortgang is succesvol hersteld!</p>
 <p class="text-muted" style="margin-top: 0.5rem;">De pagina wordt ververst om de wijzigingen toe te passen.</p>
 </div>
 </div>
 `, [
 { text: 'Ververs Pagina', class: 'btn-primary', action: () => location.reload() }
 ]);
 
 } catch (error) {
 this.showModal('Import Mislukt', `
 <div class="info-box danger">
 <div class="info-box-icon">*</div>
 <div class="info-box-content">
 <p>Kon het bestand niet importeren.</p>
 <p class="text-muted" style="margin-top: 0.5rem;">${error.message}</p>
 </div>
 </div>
 `);
 }
 };
 
 reader.readAsText(file);
 };
 
 input.click();
 };

 // ==================== PERIODIC CHECKS ====================
 
 // Check achievements periodically
 setInterval(() => {
 if (AppState.user.totalAnswered > 0) {
 Achievements.checkAchievements();
 }
 }, 30000); // Every 30 seconds

// Auto-save periodically
setInterval(() => {
Storage.flushSave('interval');
}, 60000); // Every minute

 // ==================== FINAL INITIALIZATION ====================
 
 // Wait for DOM to be ready
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', () => ECGApp.init());
 } else {
 ECGApp.init();
 }

 // Expose to global scope for onclick handlers
 window.ECGApp = ECGApp;
 window.Navigation = Navigation;

</script>
</body>
</html>















